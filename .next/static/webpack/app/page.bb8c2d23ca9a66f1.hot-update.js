/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FAnimatedContent.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FFallingText.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FblogSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FfooterSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FheroSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnavbarSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnewsSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FprojectSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FvaleursSection.tsx&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FAnimatedContent.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FFallingText.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FblogSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FfooterSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FheroSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnavbarSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnewsSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FprojectSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FvaleursSection.tsx&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/Animations/AnimatedContent.tsx */ \"(app-pages-browser)/./src/Animations/AnimatedContent.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/Animations/FallingText.tsx */ \"(app-pages-browser)/./src/Animations/FallingText.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/blogSection.tsx */ \"(app-pages-browser)/./src/components/blogSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/footerSection.tsx */ \"(app-pages-browser)/./src/components/footerSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/heroSection.tsx */ \"(app-pages-browser)/./src/components/heroSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/navbarSection.tsx */ \"(app-pages-browser)/./src/components/navbarSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/newsSection.tsx */ \"(app-pages-browser)/./src/components/newsSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/projectSection.tsx */ \"(app-pages-browser)/./src/components/projectSection.tsx\"));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/valeursSection.tsx */ \"(app-pages-browser)/./src/components/valeursSection.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmNzaCUyRlByb2pldCUyRmNzaFN0dWRpbyUyRmNzaFN0dWRpbyUyRnNyYyUyRkFuaW1hdGlvbnMlMkZBbmltYXRlZENvbnRlbnQudHN4Jm1vZHVsZXM9JTJGVXNlcnMlMkZjc2glMkZQcm9qZXQlMkZjc2hTdHVkaW8lMkZjc2hTdHVkaW8lMkZzcmMlMkZBbmltYXRpb25zJTJGRmFsbGluZ1RleHQudHN4Jm1vZHVsZXM9JTJGVXNlcnMlMkZjc2glMkZQcm9qZXQlMkZjc2hTdHVkaW8lMkZjc2hTdHVkaW8lMkZzcmMlMkZjb21wb25lbnRzJTJGYmxvZ1NlY3Rpb24udHN4Jm1vZHVsZXM9JTJGVXNlcnMlMkZjc2glMkZQcm9qZXQlMkZjc2hTdHVkaW8lMkZjc2hTdHVkaW8lMkZzcmMlMkZjb21wb25lbnRzJTJGZm9vdGVyU2VjdGlvbi50c3gmbW9kdWxlcz0lMkZVc2VycyUyRmNzaCUyRlByb2pldCUyRmNzaFN0dWRpbyUyRmNzaFN0dWRpbyUyRnNyYyUyRmNvbXBvbmVudHMlMkZoZXJvU2VjdGlvbi50c3gmbW9kdWxlcz0lMkZVc2VycyUyRmNzaCUyRlByb2pldCUyRmNzaFN0dWRpbyUyRmNzaFN0dWRpbyUyRnNyYyUyRmNvbXBvbmVudHMlMkZuYXZiYXJTZWN0aW9uLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGY3NoJTJGUHJvamV0JTJGY3NoU3R1ZGlvJTJGY3NoU3R1ZGlvJTJGc3JjJTJGY29tcG9uZW50cyUyRm5ld3NTZWN0aW9uLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGY3NoJTJGUHJvamV0JTJGY3NoU3R1ZGlvJTJGY3NoU3R1ZGlvJTJGc3JjJTJGY29tcG9uZW50cyUyRnByb2plY3RTZWN0aW9uLnRzeCZtb2R1bGVzPSUyRlVzZXJzJTJGY3NoJTJGUHJvamV0JTJGY3NoU3R1ZGlvJTJGY3NoU3R1ZGlvJTJGc3JjJTJGY29tcG9uZW50cyUyRnZhbGV1cnNTZWN0aW9uLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGtNQUE2RztBQUM3RywwTEFBeUc7QUFDekcsMExBQXlHO0FBQ3pHLDhMQUEyRztBQUMzRywwTEFBeUc7QUFDekcsOExBQTJHO0FBQzNHLDBMQUF5RztBQUN6RyxnTUFBNEc7QUFDNUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9hMmFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2NzaC9Qcm9qZXQvY3NoU3R1ZGlvL2NzaFN0dWRpby9zcmMvQW5pbWF0aW9ucy9BbmltYXRlZENvbnRlbnQudHN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvY3NoL1Byb2pldC9jc2hTdHVkaW8vY3NoU3R1ZGlvL3NyYy9BbmltYXRpb25zL0ZhbGxpbmdUZXh0LnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2NzaC9Qcm9qZXQvY3NoU3R1ZGlvL2NzaFN0dWRpby9zcmMvY29tcG9uZW50cy9ibG9nU2VjdGlvbi50c3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9jc2gvUHJvamV0L2NzaFN0dWRpby9jc2hTdHVkaW8vc3JjL2NvbXBvbmVudHMvZm9vdGVyU2VjdGlvbi50c3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9jc2gvUHJvamV0L2NzaFN0dWRpby9jc2hTdHVkaW8vc3JjL2NvbXBvbmVudHMvaGVyb1NlY3Rpb24udHN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvY3NoL1Byb2pldC9jc2hTdHVkaW8vY3NoU3R1ZGlvL3NyYy9jb21wb25lbnRzL25hdmJhclNlY3Rpb24udHN4XCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvY3NoL1Byb2pldC9jc2hTdHVkaW8vY3NoU3R1ZGlvL3NyYy9jb21wb25lbnRzL25ld3NTZWN0aW9uLnRzeFwiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2NzaC9Qcm9qZXQvY3NoU3R1ZGlvL2NzaFN0dWRpby9zcmMvY29tcG9uZW50cy9wcm9qZWN0U2VjdGlvbi50c3hcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9jc2gvUHJvamV0L2NzaFN0dWRpby9jc2hTdHVkaW8vc3JjL2NvbXBvbmVudHMvdmFsZXVyc1NlY3Rpb24udHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FAnimatedContent.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2FAnimations%2FFallingText.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FblogSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FfooterSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FheroSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnavbarSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FnewsSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FprojectSection.tsx&modules=%2FUsers%2Fcsh%2FProjet%2FcshStudio%2FcshStudio%2Fsrc%2Fcomponents%2FvaleursSection.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/matter-js/build/matter.js":
/*!************************************************!*\
  !*** ./node_modules/matter-js/build/matter.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*!\n * matter-js 0.20.0 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_1821__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_1821__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_1821__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_1821__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_1821__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_1821__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_1821__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_1821__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_1821__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_1821__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_1821__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_1821__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_1821__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_1821__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_1821__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_1821__(__nested_webpack_require_1821__.s = 20);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/ var Common = {};\n            module1.exports = Common;\n            (function() {\n                Common._baseDelta = 1000 / 60;\n                Common._nextId = 0;\n                Common._seed = 0;\n                Common._nowStartTime = +new Date();\n                Common._warnedOnce = {};\n                Common._decomp = null;\n                /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */ Common.extend = function(obj, deep) {\n                    var argsStart, args, deepClone;\n                    if (typeof deep === \"boolean\") {\n                        argsStart = 2;\n                        deepClone = deep;\n                    } else {\n                        argsStart = 1;\n                        deepClone = true;\n                    }\n                    for(var i = argsStart; i < arguments.length; i++){\n                        var source = arguments[i];\n                        if (source) {\n                            for(var prop in source){\n                                if (deepClone && source[prop] && source[prop].constructor === Object) {\n                                    if (!obj[prop] || obj[prop].constructor === Object) {\n                                        obj[prop] = obj[prop] || {};\n                                        Common.extend(obj[prop], deepClone, source[prop]);\n                                    } else {\n                                        obj[prop] = source[prop];\n                                    }\n                                } else {\n                                    obj[prop] = source[prop];\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                };\n                /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */ Common.clone = function(obj, deep) {\n                    return Common.extend({}, deep, obj);\n                };\n                /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */ Common.keys = function(obj) {\n                    if (Object.keys) return Object.keys(obj);\n                    // avoid hasOwnProperty for performance\n                    var keys = [];\n                    for(var key in obj)keys.push(key);\n                    return keys;\n                };\n                /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */ Common.values = function(obj) {\n                    var values = [];\n                    if (Object.keys) {\n                        var keys = Object.keys(obj);\n                        for(var i = 0; i < keys.length; i++){\n                            values.push(obj[keys[i]]);\n                        }\n                        return values;\n                    }\n                    // avoid hasOwnProperty for performance\n                    for(var key in obj)values.push(obj[key]);\n                    return values;\n                };\n                /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */ Common.get = function(obj, path, begin, end) {\n                    path = path.split(\".\").slice(begin, end);\n                    for(var i = 0; i < path.length; i += 1){\n                        obj = obj[path[i]];\n                    }\n                    return obj;\n                };\n                /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */ Common.set = function(obj, path, val, begin, end) {\n                    var parts = path.split(\".\").slice(begin, end);\n                    Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n                    return val;\n                };\n                /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */ Common.shuffle = function(array) {\n                    for(var i = array.length - 1; i > 0; i--){\n                        var j = Math.floor(Common.random() * (i + 1));\n                        var temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                    }\n                    return array;\n                };\n                /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */ Common.choose = function(choices) {\n                    return choices[Math.floor(Common.random() * choices.length)];\n                };\n                /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */ Common.isElement = function(obj) {\n                    if (typeof HTMLElement !== \"undefined\") {\n                        return obj instanceof HTMLElement;\n                    }\n                    return !!(obj && obj.nodeType && obj.nodeName);\n                };\n                /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */ Common.isArray = function(obj) {\n                    return Object.prototype.toString.call(obj) === \"[object Array]\";\n                };\n                /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */ Common.isFunction = function(obj) {\n                    return typeof obj === \"function\";\n                };\n                /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */ Common.isPlainObject = function(obj) {\n                    return typeof obj === \"object\" && obj.constructor === Object;\n                };\n                /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */ Common.isString = function(obj) {\n                    return toString.call(obj) === \"[object String]\";\n                };\n                /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */ Common.clamp = function(value, min, max) {\n                    if (value < min) return min;\n                    if (value > max) return max;\n                    return value;\n                };\n                /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */ Common.sign = function(value) {\n                    return value < 0 ? -1 : 1;\n                };\n                /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */ Common.now = function() {\n                    if ( true && window.performance) {\n                        if (window.performance.now) {\n                            return window.performance.now();\n                        } else if (window.performance.webkitNow) {\n                            return window.performance.webkitNow();\n                        }\n                    }\n                    if (Date.now) {\n                        return Date.now();\n                    }\n                    return new Date() - Common._nowStartTime;\n                };\n                /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */ Common.random = function(min, max) {\n                    min = typeof min !== \"undefined\" ? min : 0;\n                    max = typeof max !== \"undefined\" ? max : 1;\n                    return min + _seededRandom() * (max - min);\n                };\n                var _seededRandom = function() {\n                    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n                    Common._seed = (Common._seed * 9301 + 49297) % 233280;\n                    return Common._seed / 233280;\n                };\n                /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */ Common.colorToNumber = function(colorString) {\n                    colorString = colorString.replace(\"#\", \"\");\n                    if (colorString.length == 3) {\n                        colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);\n                    }\n                    return parseInt(colorString, 16);\n                };\n                /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @static\n     * @property logLevel\n     * @type {Number}\n     * @default 1\n     */ Common.logLevel = 1;\n                /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */ Common.log = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n                        console.log.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */ Common.info = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n                        console.info.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */ Common.warn = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n                        console.warn.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */ Common.warnOnce = function() {\n                    var message = Array.prototype.slice.call(arguments).join(\" \");\n                    if (!Common._warnedOnce[message]) {\n                        Common.warn(message);\n                        Common._warnedOnce[message] = true;\n                    }\n                };\n                /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */ Common.deprecated = function(obj, prop, warning) {\n                    obj[prop] = Common.chain(function() {\n                        Common.warnOnce(\"\\uD83D\\uDD05 deprecated \\uD83D\\uDD05\", warning);\n                    }, obj[prop]);\n                };\n                /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */ Common.nextId = function() {\n                    return Common._nextId++;\n                };\n                /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */ Common.indexOf = function(haystack, needle) {\n                    if (haystack.indexOf) return haystack.indexOf(needle);\n                    for(var i = 0; i < haystack.length; i++){\n                        if (haystack[i] === needle) return i;\n                    }\n                    return -1;\n                };\n                /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */ Common.map = function(list, func) {\n                    if (list.map) {\n                        return list.map(func);\n                    }\n                    var mapped = [];\n                    for(var i = 0; i < list.length; i += 1){\n                        mapped.push(func(list[i]));\n                    }\n                    return mapped;\n                };\n                /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */ Common.topologicalSort = function(graph) {\n                    // https://github.com/mgechev/javascript-algorithms\n                    // Copyright (c) Minko Gechev (MIT license)\n                    // Modifications: tidy formatting and naming\n                    var result = [], visited = [], temp = [];\n                    for(var node in graph){\n                        if (!visited[node] && !temp[node]) {\n                            Common._topologicalSort(node, visited, temp, graph, result);\n                        }\n                    }\n                    return result;\n                };\n                Common._topologicalSort = function(node, visited, temp, graph, result) {\n                    var neighbors = graph[node] || [];\n                    temp[node] = true;\n                    for(var i = 0; i < neighbors.length; i += 1){\n                        var neighbor = neighbors[i];\n                        if (temp[neighbor]) {\n                            continue;\n                        }\n                        if (!visited[neighbor]) {\n                            Common._topologicalSort(neighbor, visited, temp, graph, result);\n                        }\n                    }\n                    temp[node] = false;\n                    visited[node] = true;\n                    result.push(node);\n                };\n                /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */ Common.chain = function() {\n                    var funcs = [];\n                    for(var i = 0; i < arguments.length; i += 1){\n                        var func = arguments[i];\n                        if (func._chained) {\n                            // flatten already chained functions\n                            funcs.push.apply(funcs, func._chained);\n                        } else {\n                            funcs.push(func);\n                        }\n                    }\n                    var chain = function() {\n                        // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n                        var lastResult, args = new Array(arguments.length);\n                        for(var i = 0, l = arguments.length; i < l; i++){\n                            args[i] = arguments[i];\n                        }\n                        for(i = 0; i < funcs.length; i += 1){\n                            var result = funcs[i].apply(lastResult, args);\n                            if (typeof result !== \"undefined\") {\n                                lastResult = result;\n                            }\n                        }\n                        return lastResult;\n                    };\n                    chain._chained = funcs;\n                    return chain;\n                };\n                /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */ Common.chainPathBefore = function(base, path, func) {\n                    return Common.set(base, path, Common.chain(func, Common.get(base, path)));\n                };\n                /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */ Common.chainPathAfter = function(base, path, func) {\n                    return Common.set(base, path, Common.chain(Common.get(base, path), func));\n                };\n                /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */ Common.setDecomp = function(decomp) {\n                    Common._decomp = decomp;\n                };\n                /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */ Common.getDecomp = function() {\n                    // get user provided decomp if set\n                    var decomp = Common._decomp;\n                    try {\n                        // otherwise from window global\n                        if (!decomp && \"object\" !== \"undefined\") {\n                            decomp = window.decomp;\n                        }\n                        // otherwise from node global\n                        if (!decomp && typeof __webpack_require__.g !== \"undefined\") {\n                            decomp = __webpack_require__.g.decomp;\n                        }\n                    } catch (e) {\n                        // decomp not available\n                        decomp = null;\n                    }\n                    return decomp;\n                };\n            })();\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/ var Bounds = {};\n            module1.exports = Bounds;\n            (function() {\n                /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */ Bounds.create = function(vertices) {\n                    var bounds = {\n                        min: {\n                            x: 0,\n                            y: 0\n                        },\n                        max: {\n                            x: 0,\n                            y: 0\n                        }\n                    };\n                    if (vertices) Bounds.update(bounds, vertices);\n                    return bounds;\n                };\n                /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */ Bounds.update = function(bounds, vertices, velocity) {\n                    bounds.min.x = Infinity;\n                    bounds.max.x = -Infinity;\n                    bounds.min.y = Infinity;\n                    bounds.max.y = -Infinity;\n                    for(var i = 0; i < vertices.length; i++){\n                        var vertex = vertices[i];\n                        if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n                        if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n                        if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n                        if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n                    }\n                    if (velocity) {\n                        if (velocity.x > 0) {\n                            bounds.max.x += velocity.x;\n                        } else {\n                            bounds.min.x += velocity.x;\n                        }\n                        if (velocity.y > 0) {\n                            bounds.max.y += velocity.y;\n                        } else {\n                            bounds.min.y += velocity.y;\n                        }\n                    }\n                };\n                /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */ Bounds.contains = function(bounds, point) {\n                    return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;\n                };\n                /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */ Bounds.overlaps = function(boundsA, boundsB) {\n                    return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;\n                };\n                /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */ Bounds.translate = function(bounds, vector) {\n                    bounds.min.x += vector.x;\n                    bounds.max.x += vector.x;\n                    bounds.min.y += vector.y;\n                    bounds.max.y += vector.y;\n                };\n                /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */ Bounds.shift = function(bounds, position) {\n                    var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;\n                    bounds.min.x = position.x;\n                    bounds.max.x = position.x + deltaX;\n                    bounds.min.y = position.y;\n                    bounds.max.y = position.y + deltaY;\n                };\n            })();\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/ // TODO: consider params for reusing vector objects\n            var Vector = {};\n            module1.exports = Vector;\n            (function() {\n                /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */ Vector.create = function(x, y) {\n                    return {\n                        x: x || 0,\n                        y: y || 0\n                    };\n                };\n                /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */ Vector.clone = function(vector) {\n                    return {\n                        x: vector.x,\n                        y: vector.y\n                    };\n                };\n                /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */ Vector.magnitude = function(vector) {\n                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n                };\n                /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */ Vector.magnitudeSquared = function(vector) {\n                    return vector.x * vector.x + vector.y * vector.y;\n                };\n                /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */ Vector.rotate = function(vector, angle, output) {\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    if (!output) output = {};\n                    var x = vector.x * cos - vector.y * sin;\n                    output.y = vector.x * sin + vector.y * cos;\n                    output.x = x;\n                    return output;\n                };\n                /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */ Vector.rotateAbout = function(vector, angle, point, output) {\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    if (!output) output = {};\n                    var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n                    output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n                    output.x = x;\n                    return output;\n                };\n                /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */ Vector.normalise = function(vector) {\n                    var magnitude = Vector.magnitude(vector);\n                    if (magnitude === 0) return {\n                        x: 0,\n                        y: 0\n                    };\n                    return {\n                        x: vector.x / magnitude,\n                        y: vector.y / magnitude\n                    };\n                };\n                /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */ Vector.dot = function(vectorA, vectorB) {\n                    return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n                };\n                /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */ Vector.cross = function(vectorA, vectorB) {\n                    return vectorA.x * vectorB.y - vectorA.y * vectorB.x;\n                };\n                /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */ Vector.cross3 = function(vectorA, vectorB, vectorC) {\n                    return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n                };\n                /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */ Vector.add = function(vectorA, vectorB, output) {\n                    if (!output) output = {};\n                    output.x = vectorA.x + vectorB.x;\n                    output.y = vectorA.y + vectorB.y;\n                    return output;\n                };\n                /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */ Vector.sub = function(vectorA, vectorB, output) {\n                    if (!output) output = {};\n                    output.x = vectorA.x - vectorB.x;\n                    output.y = vectorA.y - vectorB.y;\n                    return output;\n                };\n                /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */ Vector.mult = function(vector, scalar) {\n                    return {\n                        x: vector.x * scalar,\n                        y: vector.y * scalar\n                    };\n                };\n                /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */ Vector.div = function(vector, scalar) {\n                    return {\n                        x: vector.x / scalar,\n                        y: vector.y / scalar\n                    };\n                };\n                /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */ Vector.perp = function(vector, negate) {\n                    negate = negate === true ? -1 : 1;\n                    return {\n                        x: negate * -vector.y,\n                        y: negate * vector.x\n                    };\n                };\n                /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */ Vector.neg = function(vector) {\n                    return {\n                        x: -vector.x,\n                        y: -vector.y\n                    };\n                };\n                /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */ Vector.angle = function(vectorA, vectorB) {\n                    return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n                };\n                /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */ Vector._temp = [\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create()\n                ];\n            })();\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_41202__) {\n            /**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/ var Vertices = {};\n            module1.exports = Vertices;\n            var Vector = __nested_webpack_require_41202__(2);\n            var Common = __nested_webpack_require_41202__(0);\n            (function() {\n                /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */ Vertices.create = function(points, body) {\n                    var vertices = [];\n                    for(var i = 0; i < points.length; i++){\n                        var point = points[i], vertex = {\n                            x: point.x,\n                            y: point.y,\n                            index: i,\n                            body: body,\n                            isInternal: false\n                        };\n                        vertices.push(vertex);\n                    }\n                    return vertices;\n                };\n                /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */ Vertices.fromPath = function(path, body) {\n                    var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig, points = [];\n                    path.replace(pathPattern, function(match, x, y) {\n                        points.push({\n                            x: parseFloat(x),\n                            y: parseFloat(y)\n                        });\n                    });\n                    return Vertices.create(points, body);\n                };\n                /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */ Vertices.centre = function(vertices) {\n                    var area = Vertices.area(vertices, true), centre = {\n                        x: 0,\n                        y: 0\n                    }, cross, temp, j;\n                    for(var i = 0; i < vertices.length; i++){\n                        j = (i + 1) % vertices.length;\n                        cross = Vector.cross(vertices[i], vertices[j]);\n                        temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n                        centre = Vector.add(centre, temp);\n                    }\n                    return Vector.div(centre, 6 * area);\n                };\n                /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */ Vertices.mean = function(vertices) {\n                    var average = {\n                        x: 0,\n                        y: 0\n                    };\n                    for(var i = 0; i < vertices.length; i++){\n                        average.x += vertices[i].x;\n                        average.y += vertices[i].y;\n                    }\n                    return Vector.div(average, vertices.length);\n                };\n                /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */ Vertices.area = function(vertices, signed) {\n                    var area = 0, j = vertices.length - 1;\n                    for(var i = 0; i < vertices.length; i++){\n                        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n                        j = i;\n                    }\n                    if (signed) return area / 2;\n                    return Math.abs(area) / 2;\n                };\n                /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */ Vertices.inertia = function(vertices, mass) {\n                    var numerator = 0, denominator = 0, v = vertices, cross, j;\n                    // find the polygon's moment of inertia, using second moment of area\n                    // from equations at http://www.physicsforums.com/showthread.php?t=25293\n                    for(var n = 0; n < v.length; n++){\n                        j = (n + 1) % v.length;\n                        cross = Math.abs(Vector.cross(v[j], v[n]));\n                        numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n                        denominator += cross;\n                    }\n                    return mass / 6 * (numerator / denominator);\n                };\n                /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */ Vertices.translate = function(vertices, vector, scalar) {\n                    scalar = typeof scalar !== \"undefined\" ? scalar : 1;\n                    var verticesLength = vertices.length, translateX = vector.x * scalar, translateY = vector.y * scalar, i;\n                    for(i = 0; i < verticesLength; i++){\n                        vertices[i].x += translateX;\n                        vertices[i].y += translateY;\n                    }\n                    return vertices;\n                };\n                /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */ Vertices.rotate = function(vertices, angle, point) {\n                    if (angle === 0) return;\n                    var cos = Math.cos(angle), sin = Math.sin(angle), pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex, dx, dy, i;\n                    for(i = 0; i < verticesLength; i++){\n                        vertex = vertices[i];\n                        dx = vertex.x - pointX;\n                        dy = vertex.y - pointY;\n                        vertex.x = pointX + (dx * cos - dy * sin);\n                        vertex.y = pointY + (dx * sin + dy * cos);\n                    }\n                    return vertices;\n                };\n                /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */ Vertices.contains = function(vertices, point) {\n                    var pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex = vertices[verticesLength - 1], nextVertex;\n                    for(var i = 0; i < verticesLength; i++){\n                        nextVertex = vertices[i];\n                        if ((pointX - vertex.x) * (nextVertex.y - vertex.y) + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {\n                            return false;\n                        }\n                        vertex = nextVertex;\n                    }\n                    return true;\n                };\n                /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */ Vertices.scale = function(vertices, scaleX, scaleY, point) {\n                    if (scaleX === 1 && scaleY === 1) return vertices;\n                    point = point || Vertices.centre(vertices);\n                    var vertex, delta;\n                    for(var i = 0; i < vertices.length; i++){\n                        vertex = vertices[i];\n                        delta = Vector.sub(vertex, point);\n                        vertices[i].x = point.x + delta.x * scaleX;\n                        vertices[i].y = point.y + delta.y * scaleY;\n                    }\n                    return vertices;\n                };\n                /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */ Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n                    if (typeof radius === \"number\") {\n                        radius = [\n                            radius\n                        ];\n                    } else {\n                        radius = radius || [\n                            8\n                        ];\n                    }\n                    // quality defaults to -1, which is auto\n                    quality = typeof quality !== \"undefined\" ? quality : -1;\n                    qualityMin = qualityMin || 2;\n                    qualityMax = qualityMax || 14;\n                    var newVertices = [];\n                    for(var i = 0; i < vertices.length; i++){\n                        var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];\n                        if (currentRadius === 0) {\n                            newVertices.push(vertex);\n                            continue;\n                        }\n                        var prevNormal = Vector.normalise({\n                            x: vertex.y - prevVertex.y,\n                            y: prevVertex.x - vertex.x\n                        });\n                        var nextNormal = Vector.normalise({\n                            x: nextVertex.y - vertex.y,\n                            y: vertex.x - nextVertex.x\n                        });\n                        var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n                        var precision = quality;\n                        if (quality === -1) {\n                            // automatically decide precision\n                            precision = Math.pow(currentRadius, 0.32) * 1.75;\n                        }\n                        precision = Common.clamp(precision, qualityMin, qualityMax);\n                        // use an even value for precision, more likely to reduce axes by using symmetry\n                        if (precision % 2 === 1) precision += 1;\n                        var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;\n                        for(var j = 0; j < precision; j++){\n                            newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n                        }\n                    }\n                    return newVertices;\n                };\n                /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */ Vertices.clockwiseSort = function(vertices) {\n                    var centre = Vertices.mean(vertices);\n                    vertices.sort(function(vertexA, vertexB) {\n                        return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n                    });\n                    return vertices;\n                };\n                /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */ Vertices.isConvex = function(vertices) {\n                    // http://paulbourke.net/geometry/polygonmesh/\n                    // Copyright (c) Paul Bourke (use permitted)\n                    var flag = 0, n = vertices.length, i, j, k, z;\n                    if (n < 3) return null;\n                    for(i = 0; i < n; i++){\n                        j = (i + 1) % n;\n                        k = (i + 2) % n;\n                        z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n                        z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n                        if (z < 0) {\n                            flag |= 1;\n                        } else if (z > 0) {\n                            flag |= 2;\n                        }\n                        if (flag === 3) {\n                            return false;\n                        }\n                    }\n                    if (flag !== 0) {\n                        return true;\n                    } else {\n                        return null;\n                    }\n                };\n                /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */ Vertices.hull = function(vertices) {\n                    // http://geomalgorithms.com/a10-_hull-1.html\n                    var upper = [], lower = [], vertex, i;\n                    // sort vertices on x-axis (y-axis for ties)\n                    vertices = vertices.slice(0);\n                    vertices.sort(function(vertexA, vertexB) {\n                        var dx = vertexA.x - vertexB.x;\n                        return dx !== 0 ? dx : vertexA.y - vertexB.y;\n                    });\n                    // build lower hull\n                    for(i = 0; i < vertices.length; i += 1){\n                        vertex = vertices[i];\n                        while(lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0){\n                            lower.pop();\n                        }\n                        lower.push(vertex);\n                    }\n                    // build upper hull\n                    for(i = vertices.length - 1; i >= 0; i -= 1){\n                        vertex = vertices[i];\n                        while(upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0){\n                            upper.pop();\n                        }\n                        upper.push(vertex);\n                    }\n                    // concatenation of the lower and upper hulls gives the convex hull\n                    // omit last points because they are repeated at the beginning of the other list\n                    upper.pop();\n                    lower.pop();\n                    return upper.concat(lower);\n                };\n            })();\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_57367__) {\n            /**\n* The `Matter.Body` module contains methods for creating and manipulating rigid bodies.\n* For creating bodies with common configurations such as rectangles, circles and other polygons see the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/ var Body = {};\n            module1.exports = Body;\n            var Vertices = __nested_webpack_require_57367__(3);\n            var Vector = __nested_webpack_require_57367__(2);\n            var Sleeping = __nested_webpack_require_57367__(7);\n            var Common = __nested_webpack_require_57367__(0);\n            var Bounds = __nested_webpack_require_57367__(1);\n            var Axes = __nested_webpack_require_57367__(11);\n            (function() {\n                Body._timeCorrection = true;\n                Body._inertiaScale = 4;\n                Body._nextCollidingGroupId = 1;\n                Body._nextNonCollidingGroupId = -1;\n                Body._nextCategory = 0x0001;\n                Body._baseDelta = 1000 / 60;\n                /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */ Body.create = function(options) {\n                    var defaults = {\n                        id: Common.nextId(),\n                        type: \"body\",\n                        label: \"Body\",\n                        parts: [],\n                        plugin: {},\n                        angle: 0,\n                        vertices: Vertices.fromPath(\"L 0 0 L 40 0 L 40 40 L 0 40\"),\n                        position: {\n                            x: 0,\n                            y: 0\n                        },\n                        force: {\n                            x: 0,\n                            y: 0\n                        },\n                        torque: 0,\n                        positionImpulse: {\n                            x: 0,\n                            y: 0\n                        },\n                        constraintImpulse: {\n                            x: 0,\n                            y: 0,\n                            angle: 0\n                        },\n                        totalContacts: 0,\n                        speed: 0,\n                        angularSpeed: 0,\n                        velocity: {\n                            x: 0,\n                            y: 0\n                        },\n                        angularVelocity: 0,\n                        isSensor: false,\n                        isStatic: false,\n                        isSleeping: false,\n                        motion: 0,\n                        sleepThreshold: 60,\n                        density: 0.001,\n                        restitution: 0,\n                        friction: 0.1,\n                        frictionStatic: 0.5,\n                        frictionAir: 0.01,\n                        collisionFilter: {\n                            category: 0x0001,\n                            mask: 0xFFFFFFFF,\n                            group: 0\n                        },\n                        slop: 0.05,\n                        timeScale: 1,\n                        render: {\n                            visible: true,\n                            opacity: 1,\n                            strokeStyle: null,\n                            fillStyle: null,\n                            lineWidth: null,\n                            sprite: {\n                                xScale: 1,\n                                yScale: 1,\n                                xOffset: 0,\n                                yOffset: 0\n                            }\n                        },\n                        events: null,\n                        bounds: null,\n                        chamfer: null,\n                        circleRadius: 0,\n                        positionPrev: null,\n                        anglePrev: 0,\n                        parent: null,\n                        axes: null,\n                        area: 0,\n                        mass: 0,\n                        inertia: 0,\n                        deltaTime: 1000 / 60,\n                        _original: null\n                    };\n                    var body = Common.extend(defaults, options);\n                    _initProperties(body, options);\n                    return body;\n                };\n                /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */ Body.nextGroup = function(isNonColliding) {\n                    if (isNonColliding) return Body._nextNonCollidingGroupId--;\n                    return Body._nextCollidingGroupId++;\n                };\n                /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */ Body.nextCategory = function() {\n                    Body._nextCategory = Body._nextCategory << 1;\n                    return Body._nextCategory;\n                };\n                /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */ var _initProperties = function(body, options) {\n                    options = options || {};\n                    // init required properties (order is important)\n                    Body.set(body, {\n                        bounds: body.bounds || Bounds.create(body.vertices),\n                        positionPrev: body.positionPrev || Vector.clone(body.position),\n                        anglePrev: body.anglePrev || body.angle,\n                        vertices: body.vertices,\n                        parts: body.parts || [\n                            body\n                        ],\n                        isStatic: body.isStatic,\n                        isSleeping: body.isSleeping,\n                        parent: body.parent || body\n                    });\n                    Vertices.rotate(body.vertices, body.angle, body.position);\n                    Axes.rotate(body.axes, body.angle);\n                    Bounds.update(body.bounds, body.vertices, body.velocity);\n                    // allow options to override the automatically calculated properties\n                    Body.set(body, {\n                        axes: options.axes || body.axes,\n                        area: options.area || body.area,\n                        mass: options.mass || body.mass,\n                        inertia: options.inertia || body.inertia\n                    });\n                    // render properties\n                    var defaultFillStyle = body.isStatic ? \"#14151f\" : Common.choose([\n                        \"#f19648\",\n                        \"#f5d259\",\n                        \"#f55a3c\",\n                        \"#063e7b\",\n                        \"#ececd1\"\n                    ]), defaultStrokeStyle = body.isStatic ? \"#555\" : \"#ccc\", defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n                    body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n                    body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n                    body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n                    body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n                    body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n                };\n                /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */ Body.set = function(body, settings, value) {\n                    var property;\n                    if (typeof settings === \"string\") {\n                        property = settings;\n                        settings = {};\n                        settings[property] = value;\n                    }\n                    for(property in settings){\n                        if (!Object.prototype.hasOwnProperty.call(settings, property)) continue;\n                        value = settings[property];\n                        switch(property){\n                            case \"isStatic\":\n                                Body.setStatic(body, value);\n                                break;\n                            case \"isSleeping\":\n                                Sleeping.set(body, value);\n                                break;\n                            case \"mass\":\n                                Body.setMass(body, value);\n                                break;\n                            case \"density\":\n                                Body.setDensity(body, value);\n                                break;\n                            case \"inertia\":\n                                Body.setInertia(body, value);\n                                break;\n                            case \"vertices\":\n                                Body.setVertices(body, value);\n                                break;\n                            case \"position\":\n                                Body.setPosition(body, value);\n                                break;\n                            case \"angle\":\n                                Body.setAngle(body, value);\n                                break;\n                            case \"velocity\":\n                                Body.setVelocity(body, value);\n                                break;\n                            case \"angularVelocity\":\n                                Body.setAngularVelocity(body, value);\n                                break;\n                            case \"speed\":\n                                Body.setSpeed(body, value);\n                                break;\n                            case \"angularSpeed\":\n                                Body.setAngularSpeed(body, value);\n                                break;\n                            case \"parts\":\n                                Body.setParts(body, value);\n                                break;\n                            case \"centre\":\n                                Body.setCentre(body, value);\n                                break;\n                            default:\n                                body[property] = value;\n                        }\n                    }\n                };\n                /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */ Body.setStatic = function(body, isStatic) {\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        if (isStatic) {\n                            if (!part.isStatic) {\n                                part._original = {\n                                    restitution: part.restitution,\n                                    friction: part.friction,\n                                    mass: part.mass,\n                                    inertia: part.inertia,\n                                    density: part.density,\n                                    inverseMass: part.inverseMass,\n                                    inverseInertia: part.inverseInertia\n                                };\n                            }\n                            part.restitution = 0;\n                            part.friction = 1;\n                            part.mass = part.inertia = part.density = Infinity;\n                            part.inverseMass = part.inverseInertia = 0;\n                            part.positionPrev.x = part.position.x;\n                            part.positionPrev.y = part.position.y;\n                            part.anglePrev = part.angle;\n                            part.angularVelocity = 0;\n                            part.speed = 0;\n                            part.angularSpeed = 0;\n                            part.motion = 0;\n                        } else if (part._original) {\n                            part.restitution = part._original.restitution;\n                            part.friction = part._original.friction;\n                            part.mass = part._original.mass;\n                            part.inertia = part._original.inertia;\n                            part.density = part._original.density;\n                            part.inverseMass = part._original.inverseMass;\n                            part.inverseInertia = part._original.inverseInertia;\n                            part._original = null;\n                        }\n                        part.isStatic = isStatic;\n                    }\n                };\n                /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */ Body.setMass = function(body, mass) {\n                    var moment = body.inertia / (body.mass / 6);\n                    body.inertia = moment * (mass / 6);\n                    body.inverseInertia = 1 / body.inertia;\n                    body.mass = mass;\n                    body.inverseMass = 1 / body.mass;\n                    body.density = body.mass / body.area;\n                };\n                /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */ Body.setDensity = function(body, density) {\n                    Body.setMass(body, density * body.area);\n                    body.density = density;\n                };\n                /**\n     * Sets the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */ Body.setInertia = function(body, inertia) {\n                    body.inertia = inertia;\n                    body.inverseInertia = 1 / body.inertia;\n                };\n                /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull. Concave vertices must be decomposed into convex parts.\n     * \n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */ Body.setVertices = function(body, vertices) {\n                    // change vertices\n                    if (vertices[0].body === body) {\n                        body.vertices = vertices;\n                    } else {\n                        body.vertices = Vertices.create(vertices, body);\n                    }\n                    // update properties\n                    body.axes = Axes.fromVertices(body.vertices);\n                    body.area = Vertices.area(body.vertices);\n                    Body.setMass(body, body.density * body.area);\n                    // orient vertices around the centre of mass at origin (0, 0)\n                    var centre = Vertices.centre(body.vertices);\n                    Vertices.translate(body.vertices, centre, -1);\n                    // update inertia while vertices are at origin (0, 0)\n                    Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n                    // update geometry\n                    Vertices.translate(body.vertices, body.position);\n                    Bounds.update(body.bounds, body.vertices, body.velocity);\n                };\n                /**\n     * Sets the parts of the `body`. \n     * \n     * See `body.parts` for details and requirements on how parts are used.\n     * \n     * See Bodies.fromVertices for a related utility.\n     * \n     * This function updates `body` mass, inertia and centroid based on the parts geometry.  \n     * Sets each `part.parent` to be this `body`.  \n     * \n     * The convex hull is computed and set on this `body` (unless `autoHull` is `false`).  \n     * Automatically ensures that the first part in `body.parts` is the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param {body[]} parts\n     * @param {bool} [autoHull=true]\n     */ Body.setParts = function(body, parts, autoHull) {\n                    var i;\n                    // add all the parts, ensuring that the first part is always the parent body\n                    parts = parts.slice(0);\n                    body.parts.length = 0;\n                    body.parts.push(body);\n                    body.parent = body;\n                    for(i = 0; i < parts.length; i++){\n                        var part = parts[i];\n                        if (part !== body) {\n                            part.parent = body;\n                            body.parts.push(part);\n                        }\n                    }\n                    if (body.parts.length === 1) return;\n                    autoHull = typeof autoHull !== \"undefined\" ? autoHull : true;\n                    // find the convex hull of all parts to set on the parent body\n                    if (autoHull) {\n                        var vertices = [];\n                        for(i = 0; i < parts.length; i++){\n                            vertices = vertices.concat(parts[i].vertices);\n                        }\n                        Vertices.clockwiseSort(vertices);\n                        var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);\n                        Body.setVertices(body, hull);\n                        Vertices.translate(body.vertices, hullCentre);\n                    }\n                    // sum the properties of all compound parts of the parent body\n                    var total = Body._totalProperties(body);\n                    body.area = total.area;\n                    body.parent = body;\n                    body.position.x = total.centre.x;\n                    body.position.y = total.centre.y;\n                    body.positionPrev.x = total.centre.x;\n                    body.positionPrev.y = total.centre.y;\n                    Body.setMass(body, total.mass);\n                    Body.setInertia(body, total.inertia);\n                    Body.setPosition(body, total.centre);\n                };\n                /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */ Body.setCentre = function(body, centre, relative) {\n                    if (!relative) {\n                        body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n                        body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n                        body.position.x = centre.x;\n                        body.position.y = centre.y;\n                    } else {\n                        body.positionPrev.x += centre.x;\n                        body.positionPrev.y += centre.y;\n                        body.position.x += centre.x;\n                        body.position.y += centre.y;\n                    }\n                };\n                /**\n     * Sets the position of the body. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     * @param {boolean} [updateVelocity=false]\n     */ Body.setPosition = function(body, position, updateVelocity) {\n                    var delta = Vector.sub(position, body.position);\n                    if (updateVelocity) {\n                        body.positionPrev.x = body.position.x;\n                        body.positionPrev.y = body.position.y;\n                        body.velocity.x = delta.x;\n                        body.velocity.y = delta.y;\n                        body.speed = Vector.magnitude(delta);\n                    } else {\n                        body.positionPrev.x += delta.x;\n                        body.positionPrev.y += delta.y;\n                    }\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        part.position.x += delta.x;\n                        part.position.y += delta.y;\n                        Vertices.translate(part.vertices, delta);\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                };\n                /**\n     * Sets the angle of the body. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     * @param {boolean} [updateVelocity=false]\n     */ Body.setAngle = function(body, angle, updateVelocity) {\n                    var delta = angle - body.angle;\n                    if (updateVelocity) {\n                        body.anglePrev = body.angle;\n                        body.angularVelocity = delta;\n                        body.angularSpeed = Math.abs(delta);\n                    } else {\n                        body.anglePrev += delta;\n                    }\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        part.angle += delta;\n                        Vertices.rotate(part.vertices, delta, body.position);\n                        Axes.rotate(part.axes, delta);\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                        if (i > 0) {\n                            Vector.rotateAbout(part.position, delta, body.position, part.position);\n                        }\n                    }\n                };\n                /**\n     * Sets the current linear velocity of the body.  \n     * Affects body speed.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */ Body.setVelocity = function(body, velocity) {\n                    var timeScale = body.deltaTime / Body._baseDelta;\n                    body.positionPrev.x = body.position.x - velocity.x * timeScale;\n                    body.positionPrev.y = body.position.y - velocity.y * timeScale;\n                    body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;\n                    body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;\n                    body.speed = Vector.magnitude(body.velocity);\n                };\n                /**\n     * Gets the current linear velocity of the body.\n     * @method getVelocity\n     * @param {body} body\n     * @return {vector} velocity\n     */ Body.getVelocity = function(body) {\n                    var timeScale = Body._baseDelta / body.deltaTime;\n                    return {\n                        x: (body.position.x - body.positionPrev.x) * timeScale,\n                        y: (body.position.y - body.positionPrev.y) * timeScale\n                    };\n                };\n                /**\n     * Gets the current linear speed of the body.  \n     * Equivalent to the magnitude of its velocity.\n     * @method getSpeed\n     * @param {body} body\n     * @return {number} speed\n     */ Body.getSpeed = function(body) {\n                    return Vector.magnitude(Body.getVelocity(body));\n                };\n                /**\n     * Sets the current linear speed of the body.  \n     * Direction is maintained. Affects body velocity.\n     * @method setSpeed\n     * @param {body} body\n     * @param {number} speed\n     */ Body.setSpeed = function(body, speed) {\n                    Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));\n                };\n                /**\n     * Sets the current rotational velocity of the body.  \n     * Affects body angular speed.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */ Body.setAngularVelocity = function(body, velocity) {\n                    var timeScale = body.deltaTime / Body._baseDelta;\n                    body.anglePrev = body.angle - velocity * timeScale;\n                    body.angularVelocity = (body.angle - body.anglePrev) / timeScale;\n                    body.angularSpeed = Math.abs(body.angularVelocity);\n                };\n                /**\n     * Gets the current rotational velocity of the body.\n     * @method getAngularVelocity\n     * @param {body} body\n     * @return {number} angular velocity\n     */ Body.getAngularVelocity = function(body) {\n                    return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;\n                };\n                /**\n     * Gets the current rotational speed of the body.  \n     * Equivalent to the magnitude of its angular velocity.\n     * @method getAngularSpeed\n     * @param {body} body\n     * @return {number} angular speed\n     */ Body.getAngularSpeed = function(body) {\n                    return Math.abs(Body.getAngularVelocity(body));\n                };\n                /**\n     * Sets the current rotational speed of the body.  \n     * Direction is maintained. Affects body angular velocity.\n     * @method setAngularSpeed\n     * @param {body} body\n     * @param {number} speed\n     */ Body.setAngularSpeed = function(body, speed) {\n                    Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);\n                };\n                /**\n     * Moves a body by a given vector relative to its current position. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     * @param {boolean} [updateVelocity=false]\n     */ Body.translate = function(body, translation, updateVelocity) {\n                    Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);\n                };\n                /**\n     * Rotates a body by a given angle relative to its current angle. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     * @param {boolean} [updateVelocity=false]\n     */ Body.rotate = function(body, rotation, point, updateVelocity) {\n                    if (!point) {\n                        Body.setAngle(body, body.angle + rotation, updateVelocity);\n                    } else {\n                        var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + (dx * cos - dy * sin),\n                            y: point.y + (dx * sin + dy * cos)\n                        }, updateVelocity);\n                        Body.setAngle(body, body.angle + rotation, updateVelocity);\n                    }\n                };\n                /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */ Body.scale = function(body, scaleX, scaleY, point) {\n                    var totalArea = 0, totalInertia = 0;\n                    point = point || body.position;\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        // scale vertices\n                        Vertices.scale(part.vertices, scaleX, scaleY, point);\n                        // update properties\n                        part.axes = Axes.fromVertices(part.vertices);\n                        part.area = Vertices.area(part.vertices);\n                        Body.setMass(part, body.density * part.area);\n                        // update inertia (requires vertices to be at origin)\n                        Vertices.translate(part.vertices, {\n                            x: -part.position.x,\n                            y: -part.position.y\n                        });\n                        Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n                        Vertices.translate(part.vertices, {\n                            x: part.position.x,\n                            y: part.position.y\n                        });\n                        if (i > 0) {\n                            totalArea += part.area;\n                            totalInertia += part.inertia;\n                        }\n                        // scale position\n                        part.position.x = point.x + (part.position.x - point.x) * scaleX;\n                        part.position.y = point.y + (part.position.y - point.y) * scaleY;\n                        // update bounds\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                    // handle parent body\n                    if (body.parts.length > 1) {\n                        body.area = totalArea;\n                        if (!body.isStatic) {\n                            Body.setMass(body, body.density * totalArea);\n                            Body.setInertia(body, totalInertia);\n                        }\n                    }\n                    // handle circles\n                    if (body.circleRadius) {\n                        if (scaleX === scaleY) {\n                            body.circleRadius *= scaleX;\n                        } else {\n                            // body is no longer a circle\n                            body.circleRadius = null;\n                        }\n                    }\n                };\n                /**\n     * Performs an update by integrating the equations of motion on the `body`.\n     * This is applied every update by `Matter.Engine` automatically.\n     * @method update\n     * @param {body} body\n     * @param {number} [deltaTime=16.666]\n     */ Body.update = function(body, deltaTime) {\n                    deltaTime = (typeof deltaTime !== \"undefined\" ? deltaTime : 1000 / 60) * body.timeScale;\n                    var deltaTimeSquared = deltaTime * deltaTime, correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;\n                    // from the previous step\n                    var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta), velocityPrevX = (body.position.x - body.positionPrev.x) * correction, velocityPrevY = (body.position.y - body.positionPrev.y) * correction;\n                    // update velocity with Verlet integration\n                    body.velocity.x = velocityPrevX * frictionAir + body.force.x / body.mass * deltaTimeSquared;\n                    body.velocity.y = velocityPrevY * frictionAir + body.force.y / body.mass * deltaTimeSquared;\n                    body.positionPrev.x = body.position.x;\n                    body.positionPrev.y = body.position.y;\n                    body.position.x += body.velocity.x;\n                    body.position.y += body.velocity.y;\n                    body.deltaTime = deltaTime;\n                    // update angular velocity with Verlet integration\n                    body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;\n                    body.anglePrev = body.angle;\n                    body.angle += body.angularVelocity;\n                    // transform the body geometry\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        Vertices.translate(part.vertices, body.velocity);\n                        if (i > 0) {\n                            part.position.x += body.velocity.x;\n                            part.position.y += body.velocity.y;\n                        }\n                        if (body.angularVelocity !== 0) {\n                            Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                            Axes.rotate(part.axes, body.angularVelocity);\n                            if (i > 0) {\n                                Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                            }\n                        }\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                };\n                /**\n     * Updates properties `body.velocity`, `body.speed`, `body.angularVelocity` and `body.angularSpeed` which are normalised in relation to `Body._baseDelta`.\n     * @method updateVelocities\n     * @param {body} body\n     */ Body.updateVelocities = function(body) {\n                    var timeScale = Body._baseDelta / body.deltaTime, bodyVelocity = body.velocity;\n                    bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;\n                    bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;\n                    body.speed = Math.sqrt(bodyVelocity.x * bodyVelocity.x + bodyVelocity.y * bodyVelocity.y);\n                    body.angularVelocity = (body.angle - body.anglePrev) * timeScale;\n                    body.angularSpeed = Math.abs(body.angularVelocity);\n                };\n                /**\n     * Applies the `force` to the `body` from the force origin `position` in world-space, over a single timestep, including applying any resulting angular torque.\n     * \n     * Forces are useful for effects like gravity, wind or rocket thrust, but can be difficult in practice when precise control is needed. In these cases see `Body.setVelocity` and `Body.setPosition` as an alternative.\n     * \n     * The force from this function is only applied once for the duration of a single timestep, in other words the duration depends directly on the current engine update `delta` and the rate of calls to this function.\n     * \n     * Therefore to account for time, you should apply the force constantly over as many engine updates as equivalent to the intended duration.\n     * \n     * If all or part of the force duration is some fraction of a timestep, first multiply the force by `duration / timestep`.\n     * \n     * The force origin `position` in world-space must also be specified. Passing `body.position` will result in zero angular effect as the force origin would be at the centre of mass.\n     * \n     * The `body` will take time to accelerate under a force, the resulting effect depends on duration of the force, the body mass and other forces on the body including friction combined.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position The force origin in world-space. Pass `body.position` to avoid angular torque.\n     * @param {vector} force\n     */ Body.applyForce = function(body, position, force) {\n                    var offset = {\n                        x: position.x - body.position.x,\n                        y: position.y - body.position.y\n                    };\n                    body.force.x += force.x;\n                    body.force.y += force.y;\n                    body.torque += offset.x * force.y - offset.y * force.x;\n                };\n                /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */ Body._totalProperties = function(body) {\n                    // from equations at:\n                    // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n                    // http://output.to/sideway/default.asp?qno=121100087\n                    var properties = {\n                        mass: 0,\n                        area: 0,\n                        inertia: 0,\n                        centre: {\n                            x: 0,\n                            y: 0\n                        }\n                    };\n                    // sum the properties of all compound parts of the parent body\n                    for(var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++){\n                        var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;\n                        properties.mass += mass;\n                        properties.area += part.area;\n                        properties.inertia += part.inertia;\n                        properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n                    }\n                    properties.centre = Vector.div(properties.centre, properties.mass);\n                    return properties;\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * _Read only_. Set by `Body.create`.\n     * \n     * A `String` denoting the type of object.\n     *\n     * @readOnly\n     * @property type\n     * @type string\n     * @default \"body\"\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */ /**\n     * _Read only_. Use `Body.setParts` to set. \n     * \n     * See `Bodies.fromVertices` for a related utility.\n     * \n     * An array of bodies (the 'parts') that make up this body (the 'parent'). The first body in this array must always be a self-reference to this `body`.  \n     * \n     * The parts are fixed together and therefore perform as a single unified rigid body.\n     * \n     * Parts in relation to each other are allowed to overlap, as well as form gaps or holes, so can be used to create complex concave bodies unlike when using a single part. \n     * \n     * Use properties and functions on the parent `body` rather than on parts.\n     *   \n     * Outside of their geometry, most properties on parts are not considered or updated.  \n     * As such 'per-part' material properties among others are not currently considered.\n     * \n     * Parts should be created specifically for their parent body.  \n     * Parts should not be shared or reused between bodies, only one parent is supported.  \n     * Parts should not have their own parts, they are not handled recursively.  \n     * Parts should not be added to the world directly or any other composite.  \n     * Parts own vertices must be convex and in clockwise order.   \n     * \n     * A body with more than one part is sometimes referred to as a 'compound' body. \n     * \n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.  \n     *\n     * @readOnly\n     * @property parts\n     * @type body[]\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * _Read only_. Updated by `Body.setParts`.\n     * \n     * A reference to the body that this is a part of. See `body.parts`.\n     * This is a self reference if the body is not a part of another body.\n     *\n     * @readOnly\n     * @property parent\n     * @type body\n     */ /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setVertices` or `Body.setParts` to set. See also `Bodies.fromVertices`.\n     * \n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     * `[{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]`\n     * \n     * Vertices must always be convex, in clockwise order and must not contain any duplicate points.\n     * \n     * Concave vertices should be decomposed into convex `parts`, see `Bodies.fromVertices` and `Body.setParts`.\n     *\n     * When set the vertices are translated such that `body.position` is at the centre of mass.\n     * Many other body properties are automatically calculated from these vertices when set including `density`, `area` and `inertia`.\n     * \n     * The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @readOnly\n     * @property vertices\n     * @type vector[]\n     */ /**\n     * _Read only_. Use `Body.setPosition` to set. \n     * \n     * A `Vector` that specifies the current world-space position of the body.\n     * \n     * @readOnly\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that accumulates the total force applied to the body for a single update.\n     * Force is zeroed after every `Engine.update`, so constant forces should be applied for every update they are needed. See also `Body.applyForce`.\n     * \n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Number` that accumulates the total torque (turning force) applied to the body for a single update. See also `Body.applyForce`.\n     * Torque is zeroed after every `Engine.update`, so constant torques should be applied for every update they are needed.\n     *\n     * Torques result in angular acceleration on every update, which depends on body inertia and the engine update delta.\n     * \n     * @property torque\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setSpeed` to set. \n     * \n     * See `Body.getSpeed` for details.\n     * \n     * Equivalent to the magnitude of `body.velocity` (always positive).\n     * \n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setVelocity` to set. \n     * \n     * See `Body.getVelocity` for details.\n     * \n     * Equivalent to the magnitude of `body.angularVelocity` (always positive).\n     * \n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * _Read only_. Use `Body.setAngularSpeed` to set. \n     * \n     * See `Body.getAngularSpeed` for details.\n     * \n     * \n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setAngularVelocity` to set. \n     * \n     * See `Body.getAngularVelocity` for details.\n     * \n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setStatic` to set. \n     * \n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     *\n     * @readOnly\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */ /**\n     * _Read only_. Use `Sleeping.set` to set. \n     * \n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     *\n     * @readOnly\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */ /**\n     * _Read only_. Calculated during engine update only when sleeping is enabled.\n     * \n     * A `Number` that loosely measures the amount of movement a body currently has.\n     *\n     * Derived from `body.speed^2 + body.angularSpeed^2`. See `Sleeping.update`.\n     * \n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that defines the length of time during which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     * \n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */ /**\n     * _Read only_. Use `Body.setDensity` to set. \n     * \n     * A `Number` that defines the density of the body (mass per unit area).\n     * \n     * Mass will also be updated when set.\n     *\n     * @readOnly\n     * @property density\n     * @type number\n     * @default 0.001\n     */ /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the mass of the body.\n     * \n     * Density will also be updated when set.\n     * \n     * @readOnly\n     * @property mass\n     * @type number\n     */ /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     *\n     * @readOnly\n     * @property inverseMass\n     * @type number\n     */ /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or set through `Body.setInertia`.\n     * \n     * A `Number` that defines the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * \n     * Can be manually set to `Infinity` to prevent rotation of the body. See `Body.setInertia`.\n     * \n     * @readOnly\n     * @property inertia\n     * @type number\n     */ /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or calculated by `Body.setInertia`.\n     * \n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * \n     * @readOnly\n     * @property inverseInertia\n     * @type number\n     */ /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     * `Math.max(bodyA.restitution, bodyB.restitution)`\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     * `Math.min(bodyA.friction, bodyB.friction)`\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */ /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */ /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */ /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */ /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */ /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */ /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */ /**\n     * A `Number` that specifies a thin boundary around the body where it is allowed to slightly sink into other bodies.\n     * \n     * This is required for proper collision response, including friction and restitution effects.\n     * \n     * The default should generally suffice in most cases. You may need to decrease this value for very small bodies that are nearing the default value in scale.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */ /**\n     * A `Number` that specifies per-body time scaling.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */ /**\n     * _Read only_. Updated during engine update.\n     * \n     * A `Number` that records the last delta time value used to update this body.\n     * Used to calculate speed and velocity.\n     *\n     * @readOnly\n     * @property deltaTime\n     * @type number\n     * @default 1000 / 60\n     */ /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */ /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */ /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */ /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */ /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */ /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */ /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */ /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */ /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */ /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated when vertices are set.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @readOnly\n     * @property axes\n     * @type vector[]\n     */ /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * A `Number` that measures the area of the body's convex hull.\n     * \n     * @readOnly\n     * @property area\n     * @type string\n     * @default \n     */ /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated when vertices are set and constantly updated by `Body.update` during simulation.\n     * \n     * @property bounds\n     * @type bounds\n     */ /**\n     * Temporarily may hold parameters to be passed to `Vertices.chamfer` where supported by external functions.\n     * \n     * See `Vertices.chamfer` for possible parameters this object may hold.\n     * \n     * Currently only functions inside `Matter.Bodies` provide a utility using this property as a vertices pre-processing option.\n     * \n     * Alternatively consider using `Vertices.chamfer` directly on vertices before passing them to a body creation function.\n     * \n     * @property chamfer\n     * @type object|null|undefined\n     */ })();\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_115026__) {\n            /**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/ var Events = {};\n            module1.exports = Events;\n            var Common = __nested_webpack_require_115026__(0);\n            (function() {\n                /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */ Events.on = function(object, eventNames, callback) {\n                    var names = eventNames.split(\" \"), name;\n                    for(var i = 0; i < names.length; i++){\n                        name = names[i];\n                        object.events = object.events || {};\n                        object.events[name] = object.events[name] || [];\n                        object.events[name].push(callback);\n                    }\n                    return callback;\n                };\n                /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */ Events.off = function(object, eventNames, callback) {\n                    if (!eventNames) {\n                        object.events = {};\n                        return;\n                    }\n                    // handle Events.off(object, callback)\n                    if (typeof eventNames === \"function\") {\n                        callback = eventNames;\n                        eventNames = Common.keys(object.events).join(\" \");\n                    }\n                    var names = eventNames.split(\" \");\n                    for(var i = 0; i < names.length; i++){\n                        var callbacks = object.events[names[i]], newCallbacks = [];\n                        if (callback && callbacks) {\n                            for(var j = 0; j < callbacks.length; j++){\n                                if (callbacks[j] !== callback) newCallbacks.push(callbacks[j]);\n                            }\n                        }\n                        object.events[names[i]] = newCallbacks;\n                    }\n                };\n                /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */ Events.trigger = function(object, eventNames, event) {\n                    var names, name, callbacks, eventClone;\n                    var events = object.events;\n                    if (events && Common.keys(events).length > 0) {\n                        if (!event) event = {};\n                        names = eventNames.split(\" \");\n                        for(var i = 0; i < names.length; i++){\n                            name = names[i];\n                            callbacks = events[name];\n                            if (callbacks) {\n                                eventClone = Common.clone(event, false);\n                                eventClone.name = name;\n                                eventClone.source = object;\n                                for(var j = 0; j < callbacks.length; j++){\n                                    callbacks[j].apply(object, [\n                                        eventClone\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_118833__) {\n            /**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/ var Composite = {};\n            module1.exports = Composite;\n            var Events = __nested_webpack_require_118833__(5);\n            var Common = __nested_webpack_require_118833__(0);\n            var Bounds = __nested_webpack_require_118833__(1);\n            var Body = __nested_webpack_require_118833__(4);\n            (function() {\n                /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */ Composite.create = function(options) {\n                    return Common.extend({\n                        id: Common.nextId(),\n                        type: \"composite\",\n                        parent: null,\n                        isModified: false,\n                        bodies: [],\n                        constraints: [],\n                        composites: [],\n                        label: \"Composite\",\n                        plugin: {},\n                        cache: {\n                            allBodies: null,\n                            allConstraints: null,\n                            allComposites: null\n                        }\n                    }, options);\n                };\n                /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @private\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */ Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n                    composite.isModified = isModified;\n                    if (isModified && composite.cache) {\n                        composite.cache.allBodies = null;\n                        composite.cache.allConstraints = null;\n                        composite.cache.allComposites = null;\n                    }\n                    if (updateParents && composite.parent) {\n                        Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n                    }\n                    if (updateChildren) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            var childComposite = composite.composites[i];\n                            Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n                        }\n                    }\n                };\n                /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */ Composite.add = function(composite, object) {\n                    var objects = [].concat(object);\n                    Events.trigger(composite, \"beforeAdd\", {\n                        object: object\n                    });\n                    for(var i = 0; i < objects.length; i++){\n                        var obj = objects[i];\n                        switch(obj.type){\n                            case \"body\":\n                                // skip adding compound parts\n                                if (obj.parent !== obj) {\n                                    Common.warn(\"Composite.add: skipped adding a compound body part (you must add its parent instead)\");\n                                    break;\n                                }\n                                Composite.addBody(composite, obj);\n                                break;\n                            case \"constraint\":\n                                Composite.addConstraint(composite, obj);\n                                break;\n                            case \"composite\":\n                                Composite.addComposite(composite, obj);\n                                break;\n                            case \"mouseConstraint\":\n                                Composite.addConstraint(composite, obj.constraint);\n                                break;\n                        }\n                    }\n                    Events.trigger(composite, \"afterAdd\", {\n                        object: object\n                    });\n                    return composite;\n                };\n                /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */ Composite.remove = function(composite, object, deep) {\n                    var objects = [].concat(object);\n                    Events.trigger(composite, \"beforeRemove\", {\n                        object: object\n                    });\n                    for(var i = 0; i < objects.length; i++){\n                        var obj = objects[i];\n                        switch(obj.type){\n                            case \"body\":\n                                Composite.removeBody(composite, obj, deep);\n                                break;\n                            case \"constraint\":\n                                Composite.removeConstraint(composite, obj, deep);\n                                break;\n                            case \"composite\":\n                                Composite.removeComposite(composite, obj, deep);\n                                break;\n                            case \"mouseConstraint\":\n                                Composite.removeConstraint(composite, obj.constraint);\n                                break;\n                        }\n                    }\n                    Events.trigger(composite, \"afterRemove\", {\n                        object: object\n                    });\n                    return composite;\n                };\n                /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */ Composite.addComposite = function(compositeA, compositeB) {\n                    compositeA.composites.push(compositeB);\n                    compositeB.parent = compositeA;\n                    Composite.setModified(compositeA, true, true, false);\n                    return compositeA;\n                };\n                /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */ Composite.removeComposite = function(compositeA, compositeB, deep) {\n                    var position = Common.indexOf(compositeA.composites, compositeB);\n                    if (position !== -1) {\n                        var bodies = Composite.allBodies(compositeB);\n                        Composite.removeCompositeAt(compositeA, position);\n                        for(var i = 0; i < bodies.length; i++){\n                            bodies[i].sleepCounter = 0;\n                        }\n                    }\n                    if (deep) {\n                        for(var i = 0; i < compositeA.composites.length; i++){\n                            Composite.removeComposite(compositeA.composites[i], compositeB, true);\n                        }\n                    }\n                    return compositeA;\n                };\n                /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */ Composite.removeCompositeAt = function(composite, position) {\n                    composite.composites.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */ Composite.addBody = function(composite, body) {\n                    composite.bodies.push(body);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */ Composite.removeBody = function(composite, body, deep) {\n                    var position = Common.indexOf(composite.bodies, body);\n                    if (position !== -1) {\n                        Composite.removeBodyAt(composite, position);\n                        body.sleepCounter = 0;\n                    }\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.removeBody(composite.composites[i], body, true);\n                        }\n                    }\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */ Composite.removeBodyAt = function(composite, position) {\n                    composite.bodies.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */ Composite.addConstraint = function(composite, constraint) {\n                    composite.constraints.push(constraint);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */ Composite.removeConstraint = function(composite, constraint, deep) {\n                    var position = Common.indexOf(composite.constraints, constraint);\n                    if (position !== -1) {\n                        Composite.removeConstraintAt(composite, position);\n                    }\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.removeConstraint(composite.composites[i], constraint, true);\n                        }\n                    }\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */ Composite.removeConstraintAt = function(composite, position) {\n                    composite.constraints.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */ Composite.clear = function(composite, keepStatic, deep) {\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.clear(composite.composites[i], keepStatic, true);\n                        }\n                    }\n                    if (keepStatic) {\n                        composite.bodies = composite.bodies.filter(function(body) {\n                            return body.isStatic;\n                        });\n                    } else {\n                        composite.bodies.length = 0;\n                    }\n                    composite.constraints.length = 0;\n                    composite.composites.length = 0;\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */ Composite.allBodies = function(composite) {\n                    if (composite.cache && composite.cache.allBodies) {\n                        return composite.cache.allBodies;\n                    }\n                    var bodies = [].concat(composite.bodies);\n                    for(var i = 0; i < composite.composites.length; i++)bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allBodies = bodies;\n                    }\n                    return bodies;\n                };\n                /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */ Composite.allConstraints = function(composite) {\n                    if (composite.cache && composite.cache.allConstraints) {\n                        return composite.cache.allConstraints;\n                    }\n                    var constraints = [].concat(composite.constraints);\n                    for(var i = 0; i < composite.composites.length; i++)constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allConstraints = constraints;\n                    }\n                    return constraints;\n                };\n                /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */ Composite.allComposites = function(composite) {\n                    if (composite.cache && composite.cache.allComposites) {\n                        return composite.cache.allComposites;\n                    }\n                    var composites = [].concat(composite.composites);\n                    for(var i = 0; i < composite.composites.length; i++)composites = composites.concat(Composite.allComposites(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allComposites = composites;\n                    }\n                    return composites;\n                };\n                /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */ Composite.get = function(composite, id, type) {\n                    var objects, object;\n                    switch(type){\n                        case \"body\":\n                            objects = Composite.allBodies(composite);\n                            break;\n                        case \"constraint\":\n                            objects = Composite.allConstraints(composite);\n                            break;\n                        case \"composite\":\n                            objects = Composite.allComposites(composite).concat(composite);\n                            break;\n                    }\n                    if (!objects) return null;\n                    object = objects.filter(function(object) {\n                        return object.id.toString() === id.toString();\n                    });\n                    return object.length === 0 ? null : object[0];\n                };\n                /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */ Composite.move = function(compositeA, objects, compositeB) {\n                    Composite.remove(compositeA, objects);\n                    Composite.add(compositeB, objects);\n                    return compositeA;\n                };\n                /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */ Composite.rebase = function(composite) {\n                    var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));\n                    for(var i = 0; i < objects.length; i++){\n                        objects[i].id = Common.nextId();\n                    }\n                    return composite;\n                };\n                /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */ Composite.translate = function(composite, translation, recursive) {\n                    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        Body.translate(bodies[i], translation);\n                    }\n                    return composite;\n                };\n                /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */ Composite.rotate = function(composite, rotation, point, recursive) {\n                    var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + (dx * cos - dy * sin),\n                            y: point.y + (dx * sin + dy * cos)\n                        });\n                        Body.rotate(body, rotation);\n                    }\n                    return composite;\n                };\n                /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */ Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n                    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + dx * scaleX,\n                            y: point.y + dy * scaleY\n                        });\n                        Body.scale(body, scaleX, scaleY);\n                    }\n                    return composite;\n                };\n                /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */ Composite.bounds = function(composite) {\n                    var bodies = Composite.allBodies(composite), vertices = [];\n                    for(var i = 0; i < bodies.length; i += 1){\n                        var body = bodies[i];\n                        vertices.push(body.bounds.min, body.bounds.max);\n                    }\n                    return Bounds.create(vertices);\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */ /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * This is automatically managed when bodies, constraints or composites are added or removed.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */ /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */ /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */ /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */ /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * An object used for storing cached results for performance reasons.\n     * This is used internally only and is automatically managed.\n     *\n     * @private\n     * @property cache\n     * @type {}\n     */ })();\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_146011__) {\n            /**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/ var Sleeping = {};\n            module1.exports = Sleeping;\n            var Body = __nested_webpack_require_146011__(4);\n            var Events = __nested_webpack_require_146011__(5);\n            var Common = __nested_webpack_require_146011__(0);\n            (function() {\n                Sleeping._motionWakeThreshold = 0.18;\n                Sleeping._motionSleepThreshold = 0.08;\n                Sleeping._minBias = 0.9;\n                /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} delta\n     */ Sleeping.update = function(bodies, delta) {\n                    var timeScale = delta / Common._baseDelta, motionSleepThreshold = Sleeping._motionSleepThreshold;\n                    // update bodies sleeping status\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], speed = Body.getSpeed(body), angularSpeed = Body.getAngularSpeed(body), motion = speed * speed + angularSpeed * angularSpeed;\n                        // wake up bodies if they have a force applied\n                        if (body.force.x !== 0 || body.force.y !== 0) {\n                            Sleeping.set(body, false);\n                            continue;\n                        }\n                        var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);\n                        // biased average motion estimation between frames\n                        body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n                        if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {\n                            body.sleepCounter += 1;\n                            if (body.sleepCounter >= body.sleepThreshold / timeScale) {\n                                Sleeping.set(body, true);\n                            }\n                        } else if (body.sleepCounter > 0) {\n                            body.sleepCounter -= 1;\n                        }\n                    }\n                };\n                /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     */ Sleeping.afterCollisions = function(pairs) {\n                    var motionSleepThreshold = Sleeping._motionSleepThreshold;\n                    // wake up bodies involved in collisions\n                    for(var i = 0; i < pairs.length; i++){\n                        var pair = pairs[i];\n                        // don't wake inactive pairs\n                        if (!pair.isActive) continue;\n                        var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;\n                        // don't wake if at least one body is static\n                        if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;\n                        if (bodyA.isSleeping || bodyB.isSleeping) {\n                            var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n                            if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {\n                                Sleeping.set(sleepingBody, false);\n                            }\n                        }\n                    }\n                };\n                /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */ Sleeping.set = function(body, isSleeping) {\n                    var wasSleeping = body.isSleeping;\n                    if (isSleeping) {\n                        body.isSleeping = true;\n                        body.sleepCounter = body.sleepThreshold;\n                        body.positionImpulse.x = 0;\n                        body.positionImpulse.y = 0;\n                        body.positionPrev.x = body.position.x;\n                        body.positionPrev.y = body.position.y;\n                        body.anglePrev = body.angle;\n                        body.speed = 0;\n                        body.angularSpeed = 0;\n                        body.motion = 0;\n                        if (!wasSleeping) {\n                            Events.trigger(body, \"sleepStart\");\n                        }\n                    } else {\n                        body.isSleeping = false;\n                        body.sleepCounter = 0;\n                        if (wasSleeping) {\n                            Events.trigger(body, \"sleepEnd\");\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_150899__) {\n            /**\n* The `Matter.Collision` module contains methods for detecting collisions between a given pair of bodies.\n*\n* For efficient detection between a list of bodies, see `Matter.Detector` and `Matter.Query`.\n*\n* See `Matter.Engine` for collision events.\n*\n* @class Collision\n*/ var Collision = {};\n            module1.exports = Collision;\n            var Vertices = __nested_webpack_require_150899__(3);\n            var Pair = __nested_webpack_require_150899__(9);\n            (function() {\n                var _supports = [];\n                var _overlapAB = {\n                    overlap: 0,\n                    axis: null\n                };\n                var _overlapBA = {\n                    overlap: 0,\n                    axis: null\n                };\n                /**\n     * Creates a new collision record.\n     * @method create\n     * @param {body} bodyA The first body part represented by the collision record\n     * @param {body} bodyB The second body part represented by the collision record\n     * @return {collision} A new collision record\n     */ Collision.create = function(bodyA, bodyB) {\n                    return {\n                        pair: null,\n                        collided: false,\n                        bodyA: bodyA,\n                        bodyB: bodyB,\n                        parentA: bodyA.parent,\n                        parentB: bodyB.parent,\n                        depth: 0,\n                        normal: {\n                            x: 0,\n                            y: 0\n                        },\n                        tangent: {\n                            x: 0,\n                            y: 0\n                        },\n                        penetration: {\n                            x: 0,\n                            y: 0\n                        },\n                        supports: [\n                            null,\n                            null\n                        ],\n                        supportCount: 0\n                    };\n                };\n                /**\n     * Detect collision between two bodies.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {pairs} [pairs] Optionally reuse collision records from existing pairs.\n     * @return {collision|null} A collision record if detected, otherwise null\n     */ Collision.collides = function(bodyA, bodyB, pairs) {\n                    Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);\n                    if (_overlapAB.overlap <= 0) {\n                        return null;\n                    }\n                    Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);\n                    if (_overlapBA.overlap <= 0) {\n                        return null;\n                    }\n                    // reuse collision records for gc efficiency\n                    var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)], collision;\n                    if (!pair) {\n                        collision = Collision.create(bodyA, bodyB);\n                        collision.collided = true;\n                        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n                        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n                        collision.parentA = collision.bodyA.parent;\n                        collision.parentB = collision.bodyB.parent;\n                    } else {\n                        collision = pair.collision;\n                    }\n                    bodyA = collision.bodyA;\n                    bodyB = collision.bodyB;\n                    var minOverlap;\n                    if (_overlapAB.overlap < _overlapBA.overlap) {\n                        minOverlap = _overlapAB;\n                    } else {\n                        minOverlap = _overlapBA;\n                    }\n                    var normal = collision.normal, tangent = collision.tangent, penetration = collision.penetration, supports = collision.supports, depth = minOverlap.overlap, minAxis = minOverlap.axis, normalX = minAxis.x, normalY = minAxis.y, deltaX = bodyB.position.x - bodyA.position.x, deltaY = bodyB.position.y - bodyA.position.y;\n                    // ensure normal is facing away from bodyA\n                    if (normalX * deltaX + normalY * deltaY >= 0) {\n                        normalX = -normalX;\n                        normalY = -normalY;\n                    }\n                    normal.x = normalX;\n                    normal.y = normalY;\n                    tangent.x = -normalY;\n                    tangent.y = normalX;\n                    penetration.x = normalX * depth;\n                    penetration.y = normalY * depth;\n                    collision.depth = depth;\n                    // find support points, there is always either exactly one or two\n                    var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1), supportCount = 0;\n                    // find the supports from bodyB that are inside bodyA\n                    if (Vertices.contains(bodyA.vertices, supportsB[0])) {\n                        supports[supportCount++] = supportsB[0];\n                    }\n                    if (Vertices.contains(bodyA.vertices, supportsB[1])) {\n                        supports[supportCount++] = supportsB[1];\n                    }\n                    // find the supports from bodyA that are inside bodyB\n                    if (supportCount < 2) {\n                        var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);\n                        if (Vertices.contains(bodyB.vertices, supportsA[0])) {\n                            supports[supportCount++] = supportsA[0];\n                        }\n                        if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {\n                            supports[supportCount++] = supportsA[1];\n                        }\n                    }\n                    // account for the edge case of overlapping but no vertex containment\n                    if (supportCount === 0) {\n                        supports[supportCount++] = supportsB[0];\n                    }\n                    // update support count\n                    collision.supportCount = supportCount;\n                    return collision;\n                };\n                /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {object} result\n     * @param {vertices} verticesA\n     * @param {vertices} verticesB\n     * @param {axes} axes\n     */ Collision._overlapAxes = function(result, verticesA, verticesB, axes) {\n                    var verticesALength = verticesA.length, verticesBLength = verticesB.length, verticesAX = verticesA[0].x, verticesAY = verticesA[0].y, verticesBX = verticesB[0].x, verticesBY = verticesB[0].y, axesLength = axes.length, overlapMin = Number.MAX_VALUE, overlapAxisNumber = 0, overlap, overlapAB, overlapBA, dot, i, j;\n                    for(i = 0; i < axesLength; i++){\n                        var axis = axes[i], axisX = axis.x, axisY = axis.y, minA = verticesAX * axisX + verticesAY * axisY, minB = verticesBX * axisX + verticesBY * axisY, maxA = minA, maxB = minB;\n                        for(j = 1; j < verticesALength; j += 1){\n                            dot = verticesA[j].x * axisX + verticesA[j].y * axisY;\n                            if (dot > maxA) {\n                                maxA = dot;\n                            } else if (dot < minA) {\n                                minA = dot;\n                            }\n                        }\n                        for(j = 1; j < verticesBLength; j += 1){\n                            dot = verticesB[j].x * axisX + verticesB[j].y * axisY;\n                            if (dot > maxB) {\n                                maxB = dot;\n                            } else if (dot < minB) {\n                                minB = dot;\n                            }\n                        }\n                        overlapAB = maxA - minB;\n                        overlapBA = maxB - minA;\n                        overlap = overlapAB < overlapBA ? overlapAB : overlapBA;\n                        if (overlap < overlapMin) {\n                            overlapMin = overlap;\n                            overlapAxisNumber = i;\n                            if (overlap <= 0) {\n                                break;\n                            }\n                        }\n                    }\n                    result.axis = axes[overlapAxisNumber];\n                    result.overlap = overlapMin;\n                };\n                /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {vector} normal\n     * @param {number} direction\n     * @return [vector]\n     */ Collision._findSupports = function(bodyA, bodyB, normal, direction) {\n                    var vertices = bodyB.vertices, verticesLength = vertices.length, bodyAPositionX = bodyA.position.x, bodyAPositionY = bodyA.position.y, normalX = normal.x * direction, normalY = normal.y * direction, vertexA = vertices[0], vertexB = vertexA, nearestDistance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y), vertexC, distance, j;\n                    // find deepest vertex relative to the axis\n                    for(j = 1; j < verticesLength; j += 1){\n                        vertexB = vertices[j];\n                        distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);\n                        // convex hill-climbing\n                        if (distance < nearestDistance) {\n                            nearestDistance = distance;\n                            vertexA = vertexB;\n                        }\n                    }\n                    // measure next vertex\n                    vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];\n                    nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);\n                    // compare with previous vertex\n                    vertexB = vertices[(vertexA.index + 1) % verticesLength];\n                    if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {\n                        _supports[0] = vertexA;\n                        _supports[1] = vertexB;\n                        return _supports;\n                    }\n                    _supports[0] = vertexA;\n                    _supports[1] = vertexC;\n                    return _supports;\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A reference to the pair using this collision record, if there is one.\n     *\n     * @property pair\n     * @type {pair|null}\n     * @default null\n     */ /**\n     * A flag that indicates if the bodies were colliding when the collision was last updated.\n     * \n     * @property collided\n     * @type boolean\n     * @default false\n     */ /**\n     * The first body part represented by the collision (see also `collision.parentA`).\n     * \n     * @property bodyA\n     * @type body\n     */ /**\n     * The second body part represented by the collision (see also `collision.parentB`).\n     * \n     * @property bodyB\n     * @type body\n     */ /**\n     * The first body represented by the collision (i.e. `collision.bodyA.parent`).\n     * \n     * @property parentA\n     * @type body\n     */ /**\n     * The second body represented by the collision (i.e. `collision.bodyB.parent`).\n     * \n     * @property parentB\n     * @type body\n     */ /**\n     * A `Number` that represents the minimum separating distance between the bodies along the collision normal.\n     *\n     * @readOnly\n     * @property depth\n     * @type number\n     * @default 0\n     */ /**\n     * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance.\n     *\n     * @property normal\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A normalised `Vector` that is the tangent direction to the collision normal.\n     *\n     * @property tangent\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that represents the direction and depth of the collision.\n     *\n     * @property penetration\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * An array of body vertices that represent the support points in the collision.\n     * \n     * _Note:_ Only the first `collision.supportCount` items of `collision.supports` are active.\n     * Therefore use `collision.supportCount` instead of `collision.supports.length` when iterating the active supports.\n     * \n     * These are the deepest vertices (along the collision normal) of each body that are contained by the other body's vertices.\n     *\n     * @property supports\n     * @type vector[]\n     * @default []\n     */ /**\n     * The number of active supports for this collision found in `collision.supports`.\n     * \n     * _Note:_ Only the first `collision.supportCount` items of `collision.supports` are active.\n     * Therefore use `collision.supportCount` instead of `collision.supports.length` when iterating the active supports.\n     *\n     * @property supportCount\n     * @type number\n     * @default 0\n     */ })();\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __nested_webpack_require_164455__) {\n            /**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/ var Pair = {};\n            module1.exports = Pair;\n            var Contact = __nested_webpack_require_164455__(16);\n            (function() {\n                /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */ Pair.create = function(collision, timestamp) {\n                    var bodyA = collision.bodyA, bodyB = collision.bodyB;\n                    var pair = {\n                        id: Pair.id(bodyA, bodyB),\n                        bodyA: bodyA,\n                        bodyB: bodyB,\n                        collision: collision,\n                        contacts: [\n                            Contact.create(),\n                            Contact.create()\n                        ],\n                        contactCount: 0,\n                        separation: 0,\n                        isActive: true,\n                        isSensor: bodyA.isSensor || bodyB.isSensor,\n                        timeCreated: timestamp,\n                        timeUpdated: timestamp,\n                        inverseMass: 0,\n                        friction: 0,\n                        frictionStatic: 0,\n                        restitution: 0,\n                        slop: 0\n                    };\n                    Pair.update(pair, collision, timestamp);\n                    return pair;\n                };\n                /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */ Pair.update = function(pair, collision, timestamp) {\n                    var supports = collision.supports, supportCount = collision.supportCount, contacts = pair.contacts, parentA = collision.parentA, parentB = collision.parentB;\n                    pair.isActive = true;\n                    pair.timeUpdated = timestamp;\n                    pair.collision = collision;\n                    pair.separation = collision.depth;\n                    pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n                    pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;\n                    pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;\n                    pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;\n                    pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;\n                    pair.contactCount = supportCount;\n                    collision.pair = pair;\n                    var supportA = supports[0], contactA = contacts[0], supportB = supports[1], contactB = contacts[1];\n                    // match contacts to supports\n                    if (contactB.vertex === supportA || contactA.vertex === supportB) {\n                        contacts[1] = contactA;\n                        contacts[0] = contactA = contactB;\n                        contactB = contacts[1];\n                    }\n                    // update contacts\n                    contactA.vertex = supportA;\n                    contactB.vertex = supportB;\n                };\n                /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */ Pair.setActive = function(pair, isActive, timestamp) {\n                    if (isActive) {\n                        pair.isActive = true;\n                        pair.timeUpdated = timestamp;\n                    } else {\n                        pair.isActive = false;\n                        pair.contactCount = 0;\n                    }\n                };\n                /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */ Pair.id = function(bodyA, bodyB) {\n                    return bodyA.id < bodyB.id ? bodyA.id.toString(36) + \":\" + bodyB.id.toString(36) : bodyB.id.toString(36) + \":\" + bodyA.id.toString(36);\n                };\n            })();\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __nested_webpack_require_168859__) {\n            /**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/ var Constraint = {};\n            module1.exports = Constraint;\n            var Vertices = __nested_webpack_require_168859__(3);\n            var Vector = __nested_webpack_require_168859__(2);\n            var Sleeping = __nested_webpack_require_168859__(7);\n            var Bounds = __nested_webpack_require_168859__(1);\n            var Axes = __nested_webpack_require_168859__(11);\n            var Common = __nested_webpack_require_168859__(0);\n            (function() {\n                Constraint._warming = 0.4;\n                Constraint._torqueDampen = 1;\n                Constraint._minLength = 0.000001;\n                /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */ Constraint.create = function(options) {\n                    var constraint = options;\n                    // if bodies defined but no points, use body centre\n                    if (constraint.bodyA && !constraint.pointA) constraint.pointA = {\n                        x: 0,\n                        y: 0\n                    };\n                    if (constraint.bodyB && !constraint.pointB) constraint.pointB = {\n                        x: 0,\n                        y: 0\n                    };\n                    // calculate static length using initial world space points\n                    var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n                    constraint.length = typeof constraint.length !== \"undefined\" ? constraint.length : length;\n                    // option defaults\n                    constraint.id = constraint.id || Common.nextId();\n                    constraint.label = constraint.label || \"Constraint\";\n                    constraint.type = \"constraint\";\n                    constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n                    constraint.damping = constraint.damping || 0;\n                    constraint.angularStiffness = constraint.angularStiffness || 0;\n                    constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n                    constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n                    constraint.plugin = {};\n                    // render\n                    var render = {\n                        visible: true,\n                        lineWidth: 2,\n                        strokeStyle: \"#ffffff\",\n                        type: \"line\",\n                        anchors: true\n                    };\n                    if (constraint.length === 0 && constraint.stiffness > 0.1) {\n                        render.type = \"pin\";\n                        render.anchors = false;\n                    } else if (constraint.stiffness < 0.9) {\n                        render.type = \"spring\";\n                    }\n                    constraint.render = Common.extend(render, constraint.render);\n                    return constraint;\n                };\n                /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */ Constraint.preSolveAll = function(bodies) {\n                    for(var i = 0; i < bodies.length; i += 1){\n                        var body = bodies[i], impulse = body.constraintImpulse;\n                        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n                            continue;\n                        }\n                        body.position.x += impulse.x;\n                        body.position.y += impulse.y;\n                        body.angle += impulse.angle;\n                    }\n                };\n                /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} delta\n     */ Constraint.solveAll = function(constraints, delta) {\n                    var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);\n                    // Solve fixed constraints first.\n                    for(var i = 0; i < constraints.length; i += 1){\n                        var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n                        if (fixedA || fixedB) {\n                            Constraint.solve(constraints[i], timeScale);\n                        }\n                    }\n                    // Solve free constraints last.\n                    for(i = 0; i < constraints.length; i += 1){\n                        constraint = constraints[i];\n                        fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;\n                        fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n                        if (!fixedA && !fixedB) {\n                            Constraint.solve(constraints[i], timeScale);\n                        }\n                    }\n                };\n                /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */ Constraint.solve = function(constraint, timeScale) {\n                    var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;\n                    if (!bodyA && !bodyB) return;\n                    // update reference angle\n                    if (bodyA && !bodyA.isStatic) {\n                        Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n                        constraint.angleA = bodyA.angle;\n                    }\n                    // update reference angle\n                    if (bodyB && !bodyB.isStatic) {\n                        Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n                        constraint.angleB = bodyB.angle;\n                    }\n                    var pointAWorld = pointA, pointBWorld = pointB;\n                    if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n                    if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n                    if (!pointAWorld || !pointBWorld) return;\n                    var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);\n                    // prevent singularity\n                    if (currentLength < Constraint._minLength) {\n                        currentLength = Constraint._minLength;\n                    }\n                    // solve distance constraint with Gauss-Siedel method\n                    var difference = (currentLength - constraint.length) / currentLength, isRigid = constraint.stiffness >= 1 || constraint.length === 0, stiffness = isRigid ? constraint.stiffness * timeScale : constraint.stiffness * timeScale * timeScale, damping = constraint.damping * timeScale, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;\n                    if (damping > 0) {\n                        var zero = Vector.create();\n                        normal = Vector.div(delta, currentLength);\n                        relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);\n                        normalVelocity = Vector.dot(normal, relativeVelocity);\n                    }\n                    if (bodyA && !bodyA.isStatic) {\n                        share = bodyA.inverseMass / massTotal;\n                        // keep track of applied impulses for post solving\n                        bodyA.constraintImpulse.x -= force.x * share;\n                        bodyA.constraintImpulse.y -= force.y * share;\n                        // apply forces\n                        bodyA.position.x -= force.x * share;\n                        bodyA.position.y -= force.y * share;\n                        // apply damping\n                        if (damping > 0) {\n                            bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;\n                            bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;\n                        }\n                        // apply torque\n                        torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n                        bodyA.constraintImpulse.angle -= torque;\n                        bodyA.angle -= torque;\n                    }\n                    if (bodyB && !bodyB.isStatic) {\n                        share = bodyB.inverseMass / massTotal;\n                        // keep track of applied impulses for post solving\n                        bodyB.constraintImpulse.x += force.x * share;\n                        bodyB.constraintImpulse.y += force.y * share;\n                        // apply forces\n                        bodyB.position.x += force.x * share;\n                        bodyB.position.y += force.y * share;\n                        // apply damping\n                        if (damping > 0) {\n                            bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;\n                            bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;\n                        }\n                        // apply torque\n                        torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n                        bodyB.constraintImpulse.angle += torque;\n                        bodyB.angle += torque;\n                    }\n                };\n                /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */ Constraint.postSolveAll = function(bodies) {\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], impulse = body.constraintImpulse;\n                        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n                            continue;\n                        }\n                        Sleeping.set(body, false);\n                        // update geometry and reset\n                        for(var j = 0; j < body.parts.length; j++){\n                            var part = body.parts[j];\n                            Vertices.translate(part.vertices, impulse);\n                            if (j > 0) {\n                                part.position.x += impulse.x;\n                                part.position.y += impulse.y;\n                            }\n                            if (impulse.angle !== 0) {\n                                Vertices.rotate(part.vertices, impulse.angle, body.position);\n                                Axes.rotate(part.axes, impulse.angle);\n                                if (j > 0) {\n                                    Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                                }\n                            }\n                            Bounds.update(part.bounds, part.vertices, body.velocity);\n                        }\n                        // dampen the cached impulse for warming next step\n                        impulse.angle *= Constraint._warming;\n                        impulse.x *= Constraint._warming;\n                        impulse.y *= Constraint._warming;\n                    }\n                };\n                /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */ Constraint.pointAWorld = function(constraint) {\n                    return {\n                        x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0),\n                        y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0)\n                    };\n                };\n                /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */ Constraint.pointBWorld = function(constraint) {\n                    return {\n                        x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0),\n                        y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0)\n                    };\n                };\n                /**\n     * Returns the current length of the constraint. \n     * This is the distance between both of the constraint's end points.\n     * See `constraint.length` for the target rest length.\n     * @method currentLength\n     * @param {constraint} constraint\n     * @returns {number} the current length\n     */ Constraint.currentLength = function(constraint) {\n                    var pointAX = (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0);\n                    var pointAY = (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0);\n                    var pointBX = (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0);\n                    var pointBY = (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0);\n                    var deltaX = pointAX - pointBX;\n                    var deltaY = pointAY - pointBY;\n                    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */ /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */ /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */ /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */ /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */ /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */ /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */ /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */ /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ })();\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_188398__) {\n            /**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/ var Axes = {};\n            module1.exports = Axes;\n            var Vector = __nested_webpack_require_188398__(2);\n            var Common = __nested_webpack_require_188398__(0);\n            (function() {\n                /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */ Axes.fromVertices = function(vertices) {\n                    var axes = {};\n                    // find the unique axes, using edge normal gradients\n                    for(var i = 0; i < vertices.length; i++){\n                        var j = (i + 1) % vertices.length, normal = Vector.normalise({\n                            x: vertices[j].y - vertices[i].y,\n                            y: vertices[i].x - vertices[j].x\n                        }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;\n                        // limit precision\n                        gradient = gradient.toFixed(3).toString();\n                        axes[gradient] = normal;\n                    }\n                    return Common.values(axes);\n                };\n                /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */ Axes.rotate = function(axes, angle) {\n                    if (angle === 0) return;\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    for(var i = 0; i < axes.length; i++){\n                        var axis = axes[i], xx;\n                        xx = axis.x * cos - axis.y * sin;\n                        axis.y = axis.x * sin + axis.y * cos;\n                        axis.x = xx;\n                    }\n                };\n            })();\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_190378__) {\n            /**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/ // TODO: true circle bodies\n            var Bodies = {};\n            module1.exports = Bodies;\n            var Vertices = __nested_webpack_require_190378__(3);\n            var Common = __nested_webpack_require_190378__(0);\n            var Body = __nested_webpack_require_190378__(4);\n            var Bounds = __nested_webpack_require_190378__(1);\n            var Vector = __nested_webpack_require_190378__(2);\n            (function() {\n                /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */ Bodies.rectangle = function(x, y, width, height, options) {\n                    options = options || {};\n                    var rectangle = {\n                        label: \"Rectangle Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(\"L 0 0 L \" + width + \" 0 L \" + width + \" \" + height + \" L 0 \" + height)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, rectangle, options));\n                };\n                /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The `slope` is parameterised as a fraction of `width` and must be < 1 to form a valid trapezoid. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope Must be a number < 1.\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */ Bodies.trapezoid = function(x, y, width, height, slope, options) {\n                    options = options || {};\n                    if (slope >= 1) {\n                        Common.warn(\"Bodies.trapezoid: slope parameter must be < 1.\");\n                    }\n                    slope *= 0.5;\n                    var roof = (1 - slope * 2) * width;\n                    var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;\n                    if (slope < 0.5) {\n                        verticesPath = \"L 0 0 L \" + x1 + \" \" + -height + \" L \" + x2 + \" \" + -height + \" L \" + x3 + \" 0\";\n                    } else {\n                        verticesPath = \"L 0 0 L \" + x2 + \" \" + -height + \" L \" + x3 + \" 0\";\n                    }\n                    var trapezoid = {\n                        label: \"Trapezoid Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(verticesPath)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, trapezoid, options));\n                };\n                /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */ Bodies.circle = function(x, y, radius, options, maxSides) {\n                    options = options || {};\n                    var circle = {\n                        label: \"Circle Body\",\n                        circleRadius: radius\n                    };\n                    // approximate circles with polygons until true circles implemented in SAT\n                    maxSides = maxSides || 25;\n                    var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n                    // optimisation: always use even number of sides (half the number of unique axes)\n                    if (sides % 2 === 1) sides += 1;\n                    return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n                };\n                /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */ Bodies.polygon = function(x, y, sides, radius, options) {\n                    options = options || {};\n                    if (sides < 3) return Bodies.circle(x, y, radius, options);\n                    var theta = 2 * Math.PI / sides, path = \"\", offset = theta * 0.5;\n                    for(var i = 0; i < sides; i += 1){\n                        var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;\n                        path += \"L \" + xx.toFixed(3) + \" \" + yy.toFixed(3) + \" \";\n                    }\n                    var polygon = {\n                        label: \"Polygon Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(path)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, polygon, options));\n                };\n                /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */ Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n                    var decomp = Common.getDecomp(), canDecomp, body, parts, isConvex, isConcave, vertices, i, j, k, v, z;\n                    // check decomp is as expected\n                    canDecomp = Boolean(decomp && decomp.quickDecomp);\n                    options = options || {};\n                    parts = [];\n                    flagInternal = typeof flagInternal !== \"undefined\" ? flagInternal : false;\n                    removeCollinear = typeof removeCollinear !== \"undefined\" ? removeCollinear : 0.01;\n                    minimumArea = typeof minimumArea !== \"undefined\" ? minimumArea : 10;\n                    removeDuplicatePoints = typeof removeDuplicatePoints !== \"undefined\" ? removeDuplicatePoints : 0.01;\n                    // ensure vertexSets is an array of arrays\n                    if (!Common.isArray(vertexSets[0])) {\n                        vertexSets = [\n                            vertexSets\n                        ];\n                    }\n                    for(v = 0; v < vertexSets.length; v += 1){\n                        vertices = vertexSets[v];\n                        isConvex = Vertices.isConvex(vertices);\n                        isConcave = !isConvex;\n                        if (isConcave && !canDecomp) {\n                            Common.warnOnce(\"Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices.\");\n                        }\n                        if (isConvex || !canDecomp) {\n                            if (isConvex) {\n                                vertices = Vertices.clockwiseSort(vertices);\n                            } else {\n                                // fallback to convex hull when decomposition is not possible\n                                vertices = Vertices.hull(vertices);\n                            }\n                            parts.push({\n                                position: {\n                                    x: x,\n                                    y: y\n                                },\n                                vertices: vertices\n                            });\n                        } else {\n                            // initialise a decomposition\n                            var concave = vertices.map(function(vertex) {\n                                return [\n                                    vertex.x,\n                                    vertex.y\n                                ];\n                            });\n                            // vertices are concave and simple, we can decompose into parts\n                            decomp.makeCCW(concave);\n                            if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear);\n                            if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints) decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n                            // use the quick decomposition algorithm (Bayazit)\n                            var decomposed = decomp.quickDecomp(concave);\n                            // for each decomposed chunk\n                            for(i = 0; i < decomposed.length; i++){\n                                var chunk = decomposed[i];\n                                // convert vertices into the correct structure\n                                var chunkVertices = chunk.map(function(vertices) {\n                                    return {\n                                        x: vertices[0],\n                                        y: vertices[1]\n                                    };\n                                });\n                                // skip small chunks\n                                if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue;\n                                // create a compound part\n                                parts.push({\n                                    position: Vertices.centre(chunkVertices),\n                                    vertices: chunkVertices\n                                });\n                            }\n                        }\n                    }\n                    // create body parts\n                    for(i = 0; i < parts.length; i++){\n                        parts[i] = Body.create(Common.extend(parts[i], options));\n                    }\n                    // flag internal edges (coincident part edges)\n                    if (flagInternal) {\n                        var coincident_max_dist = 5;\n                        for(i = 0; i < parts.length; i++){\n                            var partA = parts[i];\n                            for(j = i + 1; j < parts.length; j++){\n                                var partB = parts[j];\n                                if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                                    var pav = partA.vertices, pbv = partB.vertices;\n                                    // iterate vertices of both parts\n                                    for(k = 0; k < partA.vertices.length; k++){\n                                        for(z = 0; z < partB.vertices.length; z++){\n                                            // find distances between the vertices\n                                            var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])), db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n                                            // if both vertices are very close, consider the edge concident (internal)\n                                            if (da < coincident_max_dist && db < coincident_max_dist) {\n                                                pav[k].isInternal = true;\n                                                pbv[z].isInternal = true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (parts.length > 1) {\n                        // create the parent body to be returned, that contains generated compound parts\n                        body = Body.create(Common.extend({\n                            parts: parts.slice(0)\n                        }, options));\n                        // offset such that body.position is at the centre off mass\n                        Body.setPosition(body, {\n                            x: x,\n                            y: y\n                        });\n                        return body;\n                    } else {\n                        return parts[0];\n                    }\n                };\n            })();\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_206880__) {\n            /**\n* The `Matter.Detector` module contains methods for efficiently detecting collisions between a list of bodies using a broadphase algorithm.\n*\n* @class Detector\n*/ var Detector = {};\n            module1.exports = Detector;\n            var Common = __nested_webpack_require_206880__(0);\n            var Collision = __nested_webpack_require_206880__(8);\n            (function() {\n                /**\n     * Creates a new collision detector.\n     * @method create\n     * @param {} options\n     * @return {detector} A new collision detector\n     */ Detector.create = function(options) {\n                    var defaults = {\n                        bodies: [],\n                        collisions: [],\n                        pairs: null\n                    };\n                    return Common.extend(defaults, options);\n                };\n                /**\n     * Sets the list of bodies in the detector.\n     * @method setBodies\n     * @param {detector} detector\n     * @param {body[]} bodies\n     */ Detector.setBodies = function(detector, bodies) {\n                    detector.bodies = bodies.slice(0);\n                };\n                /**\n     * Clears the detector including its list of bodies.\n     * @method clear\n     * @param {detector} detector\n     */ Detector.clear = function(detector) {\n                    detector.bodies = [];\n                    detector.collisions = [];\n                };\n                /**\n     * Efficiently finds all collisions among all the bodies in `detector.bodies` using a broadphase algorithm.\n     * \n     * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance reasons.\n     * If a specific ordering is required then apply a sort to the resulting array.\n     * @method collisions\n     * @param {detector} detector\n     * @return {collision[]} collisions\n     */ Detector.collisions = function(detector) {\n                    var pairs = detector.pairs, bodies = detector.bodies, bodiesLength = bodies.length, canCollide = Detector.canCollide, collides = Collision.collides, collisions = detector.collisions, collisionIndex = 0, i, j;\n                    bodies.sort(Detector._compareBoundsX);\n                    for(i = 0; i < bodiesLength; i++){\n                        var bodyA = bodies[i], boundsA = bodyA.bounds, boundXMax = bodyA.bounds.max.x, boundYMax = bodyA.bounds.max.y, boundYMin = bodyA.bounds.min.y, bodyAStatic = bodyA.isStatic || bodyA.isSleeping, partsALength = bodyA.parts.length, partsASingle = partsALength === 1;\n                        for(j = i + 1; j < bodiesLength; j++){\n                            var bodyB = bodies[j], boundsB = bodyB.bounds;\n                            if (boundsB.min.x > boundXMax) {\n                                break;\n                            }\n                            if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {\n                                continue;\n                            }\n                            if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {\n                                continue;\n                            }\n                            if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {\n                                continue;\n                            }\n                            var partsBLength = bodyB.parts.length;\n                            if (partsASingle && partsBLength === 1) {\n                                var collision = collides(bodyA, bodyB, pairs);\n                                if (collision) {\n                                    collisions[collisionIndex++] = collision;\n                                }\n                            } else {\n                                var partsAStart = partsALength > 1 ? 1 : 0, partsBStart = partsBLength > 1 ? 1 : 0;\n                                for(var k = partsAStart; k < partsALength; k++){\n                                    var partA = bodyA.parts[k], boundsA = partA.bounds;\n                                    for(var z = partsBStart; z < partsBLength; z++){\n                                        var partB = bodyB.parts[z], boundsB = partB.bounds;\n                                        if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {\n                                            continue;\n                                        }\n                                        var collision = collides(partA, partB, pairs);\n                                        if (collision) {\n                                            collisions[collisionIndex++] = collision;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (collisions.length !== collisionIndex) {\n                        collisions.length = collisionIndex;\n                    }\n                    return collisions;\n                };\n                /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */ Detector.canCollide = function(filterA, filterB) {\n                    if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;\n                    return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n                };\n                /**\n     * The comparison function used in the broadphase algorithm.\n     * Returns the signed delta of the bodies bounds on the x-axis.\n     * @private\n     * @method _sortCompare\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {number} The signed delta used for sorting\n     */ Detector._compareBoundsX = function(bodyA, bodyB) {\n                    return bodyA.bounds.min.x - bodyB.bounds.min.x;\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * The array of `Matter.Body` between which the detector finds collisions.\n     * \n     * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector.\n     * @property bodies\n     * @type body[]\n     * @default []\n     */ /**\n     * The array of `Matter.Collision` found in the last call to `Detector.collisions` on this detector.\n     * @property collisions\n     * @type collision[]\n     * @default []\n     */ /**\n     * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage.\n     * @property pairs\n     * @type {pairs|null}\n     * @default null\n     */ })();\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_213837__) {\n            /**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/ var Mouse = {};\n            module1.exports = Mouse;\n            var Common = __nested_webpack_require_213837__(0);\n            (function() {\n                /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */ Mouse.create = function(element) {\n                    var mouse = {};\n                    if (!element) {\n                        Common.log(\"Mouse.create: element was undefined, defaulting to document.body\", \"warn\");\n                    }\n                    mouse.element = element || document.body;\n                    mouse.absolute = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.position = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.mousedownPosition = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.mouseupPosition = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.offset = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.scale = {\n                        x: 1,\n                        y: 1\n                    };\n                    mouse.wheelDelta = 0;\n                    mouse.button = -1;\n                    mouse.pixelRatio = parseInt(mouse.element.getAttribute(\"data-pixel-ratio\"), 10) || 1;\n                    mouse.sourceEvents = {\n                        mousemove: null,\n                        mousedown: null,\n                        mouseup: null,\n                        mousewheel: null\n                    };\n                    mouse.mousemove = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            mouse.button = 0;\n                            event.preventDefault();\n                        }\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.sourceEvents.mousemove = event;\n                    };\n                    mouse.mousedown = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            mouse.button = 0;\n                            event.preventDefault();\n                        } else {\n                            mouse.button = event.button;\n                        }\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.mousedownPosition.x = mouse.position.x;\n                        mouse.mousedownPosition.y = mouse.position.y;\n                        mouse.sourceEvents.mousedown = event;\n                    };\n                    mouse.mouseup = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            event.preventDefault();\n                        }\n                        mouse.button = -1;\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.mouseupPosition.x = mouse.position.x;\n                        mouse.mouseupPosition.y = mouse.position.y;\n                        mouse.sourceEvents.mouseup = event;\n                    };\n                    mouse.mousewheel = function(event) {\n                        mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n                        event.preventDefault();\n                        mouse.sourceEvents.mousewheel = event;\n                    };\n                    Mouse.setElement(mouse, mouse.element);\n                    return mouse;\n                };\n                /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */ Mouse.setElement = function(mouse, element) {\n                    mouse.element = element;\n                    element.addEventListener(\"mousemove\", mouse.mousemove, {\n                        passive: true\n                    });\n                    element.addEventListener(\"mousedown\", mouse.mousedown, {\n                        passive: true\n                    });\n                    element.addEventListener(\"mouseup\", mouse.mouseup, {\n                        passive: true\n                    });\n                    element.addEventListener(\"wheel\", mouse.mousewheel, {\n                        passive: false\n                    });\n                    element.addEventListener(\"touchmove\", mouse.mousemove, {\n                        passive: false\n                    });\n                    element.addEventListener(\"touchstart\", mouse.mousedown, {\n                        passive: false\n                    });\n                    element.addEventListener(\"touchend\", mouse.mouseup, {\n                        passive: false\n                    });\n                };\n                /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */ Mouse.clearSourceEvents = function(mouse) {\n                    mouse.sourceEvents.mousemove = null;\n                    mouse.sourceEvents.mousedown = null;\n                    mouse.sourceEvents.mouseup = null;\n                    mouse.sourceEvents.mousewheel = null;\n                    mouse.wheelDelta = 0;\n                };\n                /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */ Mouse.setOffset = function(mouse, offset) {\n                    mouse.offset.x = offset.x;\n                    mouse.offset.y = offset.y;\n                    mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                    mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                };\n                /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */ Mouse.setScale = function(mouse, scale) {\n                    mouse.scale.x = scale.x;\n                    mouse.scale.y = scale.y;\n                    mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                    mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                };\n                /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */ Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n                    var elementBounds = element.getBoundingClientRect(), rootNode = document.documentElement || document.body.parentNode || document.body, scrollX = window.pageXOffset !== undefined ? window.pageXOffset : rootNode.scrollLeft, scrollY = window.pageYOffset !== undefined ? window.pageYOffset : rootNode.scrollTop, touches = event.changedTouches, x, y;\n                    if (touches) {\n                        x = touches[0].pageX - elementBounds.left - scrollX;\n                        y = touches[0].pageY - elementBounds.top - scrollY;\n                    } else {\n                        x = event.pageX - elementBounds.left - scrollX;\n                        y = event.pageY - elementBounds.top - scrollY;\n                    }\n                    return {\n                        x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n                        y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n                    };\n                };\n            })();\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_222877__) {\n            /**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/ var Plugin = {};\n            module1.exports = Plugin;\n            var Common = __nested_webpack_require_222877__(0);\n            (function() {\n                Plugin._registry = {};\n                /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */ Plugin.register = function(plugin) {\n                    if (!Plugin.isPlugin(plugin)) {\n                        Common.warn(\"Plugin.register:\", Plugin.toString(plugin), \"does not implement all required fields.\");\n                    }\n                    if (plugin.name in Plugin._registry) {\n                        var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;\n                        if (pluginVersion > registeredVersion) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(registered), \"was upgraded to\", Plugin.toString(plugin));\n                            Plugin._registry[plugin.name] = plugin;\n                        } else if (pluginVersion < registeredVersion) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(registered), \"can not be downgraded to\", Plugin.toString(plugin));\n                        } else if (plugin !== registered) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(plugin), \"is already registered to different plugin object\");\n                        }\n                    } else {\n                        Plugin._registry[plugin.name] = plugin;\n                    }\n                    return plugin;\n                };\n                /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */ Plugin.resolve = function(dependency) {\n                    return Plugin._registry[Plugin.dependencyParse(dependency).name];\n                };\n                /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */ Plugin.toString = function(plugin) {\n                    return typeof plugin === \"string\" ? plugin : (plugin.name || \"anonymous\") + \"@\" + (plugin.version || plugin.range || \"0.0.0\");\n                };\n                /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */ Plugin.isPlugin = function(obj) {\n                    return obj && obj.name && obj.version && obj.install;\n                };\n                /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */ Plugin.isUsed = function(module1, name) {\n                    return module1.used.indexOf(name) > -1;\n                };\n                /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */ Plugin.isFor = function(plugin, module1) {\n                    var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n                    return !plugin.for || module1.name === parsed.name && Plugin.versionSatisfies(module1.version, parsed.range);\n                };\n                /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick ✅ indicates a dependency was resolved and installed.\n     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross ❌ indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */ Plugin.use = function(module1, plugins) {\n                    module1.uses = (module1.uses || []).concat(plugins || []);\n                    if (module1.uses.length === 0) {\n                        Common.warn(\"Plugin.use:\", Plugin.toString(module1), \"does not specify any dependencies to install.\");\n                        return;\n                    }\n                    var dependencies = Plugin.dependencies(module1), sortedDependencies = Common.topologicalSort(dependencies), status = [];\n                    for(var i = 0; i < sortedDependencies.length; i += 1){\n                        if (sortedDependencies[i] === module1.name) {\n                            continue;\n                        }\n                        var plugin = Plugin.resolve(sortedDependencies[i]);\n                        if (!plugin) {\n                            status.push(\"❌ \" + sortedDependencies[i]);\n                            continue;\n                        }\n                        if (Plugin.isUsed(module1, plugin.name)) {\n                            continue;\n                        }\n                        if (!Plugin.isFor(plugin, module1)) {\n                            Common.warn(\"Plugin.use:\", Plugin.toString(plugin), \"is for\", plugin.for, \"but installed on\", Plugin.toString(module1) + \".\");\n                            plugin._warned = true;\n                        }\n                        if (plugin.install) {\n                            plugin.install(module1);\n                        } else {\n                            Common.warn(\"Plugin.use:\", Plugin.toString(plugin), \"does not specify an install function.\");\n                            plugin._warned = true;\n                        }\n                        if (plugin._warned) {\n                            status.push(\"\\uD83D\\uDD36 \" + Plugin.toString(plugin));\n                            delete plugin._warned;\n                        } else {\n                            status.push(\"✅ \" + Plugin.toString(plugin));\n                        }\n                        module1.used.push(plugin.name);\n                    }\n                    if (status.length > 0) {\n                        Common.info(status.join(\"  \"));\n                    }\n                };\n                /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */ Plugin.dependencies = function(module1, tracked) {\n                    var parsedBase = Plugin.dependencyParse(module1), name = parsedBase.name;\n                    tracked = tracked || {};\n                    if (name in tracked) {\n                        return;\n                    }\n                    module1 = Plugin.resolve(module1) || module1;\n                    tracked[name] = Common.map(module1.uses || [], function(dependency) {\n                        if (Plugin.isPlugin(dependency)) {\n                            Plugin.register(dependency);\n                        }\n                        var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);\n                        if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                            Common.warn(\"Plugin.dependencies:\", Plugin.toString(resolved), \"does not satisfy\", Plugin.toString(parsed), \"used by\", Plugin.toString(parsedBase) + \".\");\n                            resolved._warned = true;\n                            module1._warned = true;\n                        } else if (!resolved) {\n                            Common.warn(\"Plugin.dependencies:\", Plugin.toString(dependency), \"used by\", Plugin.toString(parsedBase), \"could not be resolved.\");\n                            module1._warned = true;\n                        }\n                        return parsed.name;\n                    });\n                    for(var i = 0; i < tracked[name].length; i += 1){\n                        Plugin.dependencies(tracked[name][i], tracked);\n                    }\n                    return tracked;\n                };\n                /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */ Plugin.dependencyParse = function(dependency) {\n                    if (Common.isString(dependency)) {\n                        var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-+]+)?))?$/;\n                        if (!pattern.test(dependency)) {\n                            Common.warn(\"Plugin.dependencyParse:\", dependency, \"is not a valid dependency string.\");\n                        }\n                        return {\n                            name: dependency.split(\"@\")[0],\n                            range: dependency.split(\"@\")[1] || \"*\"\n                        };\n                    }\n                    return {\n                        name: dependency.name,\n                        range: dependency.range || dependency.version\n                    };\n                };\n                /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */ Plugin.versionParse = function(range) {\n                    var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-+]+)?$/;\n                    if (!pattern.test(range)) {\n                        Common.warn(\"Plugin.versionParse:\", range, \"is not a valid version or range.\");\n                    }\n                    var parts = pattern.exec(range);\n                    var major = Number(parts[4]);\n                    var minor = Number(parts[5]);\n                    var patch = Number(parts[6]);\n                    return {\n                        isRange: Boolean(parts[1] || parts[2]),\n                        version: parts[3],\n                        range: range,\n                        operator: parts[1] || parts[2] || \"\",\n                        major: major,\n                        minor: minor,\n                        patch: patch,\n                        parts: [\n                            major,\n                            minor,\n                            patch\n                        ],\n                        prerelease: parts[7],\n                        number: major * 1e8 + minor * 1e4 + patch\n                    };\n                };\n                /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */ Plugin.versionSatisfies = function(version, range) {\n                    range = range || \"*\";\n                    var r = Plugin.versionParse(range), v = Plugin.versionParse(version);\n                    if (r.isRange) {\n                        if (r.operator === \"*\" || version === \"*\") {\n                            return true;\n                        }\n                        if (r.operator === \">\") {\n                            return v.number > r.number;\n                        }\n                        if (r.operator === \">=\") {\n                            return v.number >= r.number;\n                        }\n                        if (r.operator === \"~\") {\n                            return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n                        }\n                        if (r.operator === \"^\") {\n                            if (r.major > 0) {\n                                return v.major === r.major && v.number >= r.number;\n                            }\n                            if (r.minor > 0) {\n                                return v.minor === r.minor && v.patch >= r.patch;\n                            }\n                            return v.patch === r.patch;\n                        }\n                    }\n                    return version === range || version === \"*\";\n                };\n            })();\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/ var Contact = {};\n            module1.exports = Contact;\n            (function() {\n                /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} [vertex]\n     * @return {contact} A new contact\n     */ Contact.create = function(vertex) {\n                    return {\n                        vertex: vertex,\n                        normalImpulse: 0,\n                        tangentImpulse: 0\n                    };\n                };\n            })();\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_238860__) {\n            /**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/ var Engine = {};\n            module1.exports = Engine;\n            var Sleeping = __nested_webpack_require_238860__(7);\n            var Resolver = __nested_webpack_require_238860__(18);\n            var Detector = __nested_webpack_require_238860__(13);\n            var Pairs = __nested_webpack_require_238860__(19);\n            var Events = __nested_webpack_require_238860__(5);\n            var Composite = __nested_webpack_require_238860__(6);\n            var Constraint = __nested_webpack_require_238860__(10);\n            var Common = __nested_webpack_require_238860__(0);\n            var Body = __nested_webpack_require_238860__(4);\n            (function() {\n                Engine._deltaMax = 1000 / 60;\n                /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */ Engine.create = function(options) {\n                    options = options || {};\n                    var defaults = {\n                        positionIterations: 6,\n                        velocityIterations: 4,\n                        constraintIterations: 2,\n                        enableSleeping: false,\n                        events: [],\n                        plugin: {},\n                        gravity: {\n                            x: 0,\n                            y: 1,\n                            scale: 0.001\n                        },\n                        timing: {\n                            timestamp: 0,\n                            timeScale: 1,\n                            lastDelta: 0,\n                            lastElapsed: 0,\n                            lastUpdatesPerFrame: 0\n                        }\n                    };\n                    var engine = Common.extend(defaults, options);\n                    engine.world = options.world || Composite.create({\n                        label: \"World\"\n                    });\n                    engine.pairs = options.pairs || Pairs.create();\n                    engine.detector = options.detector || Detector.create();\n                    engine.detector.pairs = engine.pairs;\n                    // for temporary back compatibility only\n                    engine.grid = {\n                        buckets: []\n                    };\n                    engine.world.gravity = engine.gravity;\n                    engine.broadphase = engine.grid;\n                    engine.metrics = {};\n                    return engine;\n                };\n                /**\n     * Moves the simulation forward in time by `delta` milliseconds.\n     * Triggers `beforeUpdate`, `beforeSolve` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     */ Engine.update = function(engine, delta) {\n                    var startTime = Common.now();\n                    var world = engine.world, detector = engine.detector, pairs = engine.pairs, timing = engine.timing, timestamp = timing.timestamp, i;\n                    // warn if high delta\n                    if (delta > Engine._deltaMax) {\n                        Common.warnOnce(\"Matter.Engine.update: delta argument is recommended to be less than or equal to\", Engine._deltaMax.toFixed(3), \"ms.\");\n                    }\n                    delta = typeof delta !== \"undefined\" ? delta : Common._baseDelta;\n                    delta *= timing.timeScale;\n                    // increment timestamp\n                    timing.timestamp += delta;\n                    timing.lastDelta = delta;\n                    // create an event object\n                    var event = {\n                        timestamp: timing.timestamp,\n                        delta: delta\n                    };\n                    Events.trigger(engine, \"beforeUpdate\", event);\n                    // get all bodies and all constraints in the world\n                    var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);\n                    // if the world has changed\n                    if (world.isModified) {\n                        // update the detector bodies\n                        Detector.setBodies(detector, allBodies);\n                        // reset all composite modified flags\n                        Composite.setModified(world, false, false, true);\n                    }\n                    // update sleeping if enabled\n                    if (engine.enableSleeping) Sleeping.update(allBodies, delta);\n                    // apply gravity to all bodies\n                    Engine._bodiesApplyGravity(allBodies, engine.gravity);\n                    // update all body position and rotation by integration\n                    if (delta > 0) {\n                        Engine._bodiesUpdate(allBodies, delta);\n                    }\n                    Events.trigger(engine, \"beforeSolve\", event);\n                    // update all constraints (first pass)\n                    Constraint.preSolveAll(allBodies);\n                    for(i = 0; i < engine.constraintIterations; i++){\n                        Constraint.solveAll(allConstraints, delta);\n                    }\n                    Constraint.postSolveAll(allBodies);\n                    // find all collisions\n                    var collisions = Detector.collisions(detector);\n                    // update collision pairs\n                    Pairs.update(pairs, collisions, timestamp);\n                    // wake up bodies involved in collisions\n                    if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list);\n                    // trigger collision events\n                    if (pairs.collisionStart.length > 0) {\n                        Events.trigger(engine, \"collisionStart\", {\n                            pairs: pairs.collisionStart,\n                            timestamp: timing.timestamp,\n                            delta: delta\n                        });\n                    }\n                    // iteratively resolve position between collisions\n                    var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);\n                    Resolver.preSolvePosition(pairs.list);\n                    for(i = 0; i < engine.positionIterations; i++){\n                        Resolver.solvePosition(pairs.list, delta, positionDamping);\n                    }\n                    Resolver.postSolvePosition(allBodies);\n                    // update all constraints (second pass)\n                    Constraint.preSolveAll(allBodies);\n                    for(i = 0; i < engine.constraintIterations; i++){\n                        Constraint.solveAll(allConstraints, delta);\n                    }\n                    Constraint.postSolveAll(allBodies);\n                    // iteratively resolve velocity between collisions\n                    Resolver.preSolveVelocity(pairs.list);\n                    for(i = 0; i < engine.velocityIterations; i++){\n                        Resolver.solveVelocity(pairs.list, delta);\n                    }\n                    // update body speed and velocity properties\n                    Engine._bodiesUpdateVelocities(allBodies);\n                    // trigger collision events\n                    if (pairs.collisionActive.length > 0) {\n                        Events.trigger(engine, \"collisionActive\", {\n                            pairs: pairs.collisionActive,\n                            timestamp: timing.timestamp,\n                            delta: delta\n                        });\n                    }\n                    if (pairs.collisionEnd.length > 0) {\n                        Events.trigger(engine, \"collisionEnd\", {\n                            pairs: pairs.collisionEnd,\n                            timestamp: timing.timestamp,\n                            delta: delta\n                        });\n                    }\n                    // clear force buffers\n                    Engine._bodiesClearForces(allBodies);\n                    Events.trigger(engine, \"afterUpdate\", event);\n                    // log the time elapsed computing this update\n                    engine.timing.lastElapsed = Common.now() - startTime;\n                    return engine;\n                };\n                /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */ Engine.merge = function(engineA, engineB) {\n                    Common.extend(engineA, engineB);\n                    if (engineB.world) {\n                        engineA.world = engineB.world;\n                        Engine.clear(engineA);\n                        var bodies = Composite.allBodies(engineA.world);\n                        for(var i = 0; i < bodies.length; i++){\n                            var body = bodies[i];\n                            Sleeping.set(body, false);\n                            body.id = Common.nextId();\n                        }\n                    }\n                };\n                /**\n     * Clears the engine pairs and detector.\n     * @method clear\n     * @param {engine} engine\n     */ Engine.clear = function(engine) {\n                    Pairs.clear(engine.pairs);\n                    Detector.clear(engine.detector);\n                };\n                /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */ Engine._bodiesClearForces = function(bodies) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        // reset force buffers\n                        body.force.x = 0;\n                        body.force.y = 0;\n                        body.torque = 0;\n                    }\n                };\n                /**\n     * Applies gravitational acceleration to all `bodies`.\n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet.\n     * \n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */ Engine._bodiesApplyGravity = function(bodies, gravity) {\n                    var gravityScale = typeof gravity.scale !== \"undefined\" ? gravity.scale : 0.001, bodiesLength = bodies.length;\n                    if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {\n                        return;\n                    }\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        if (body.isStatic || body.isSleeping) continue;\n                        // add the resultant force of gravity\n                        body.force.y += body.mass * gravity.y * gravityScale;\n                        body.force.x += body.mass * gravity.x * gravityScale;\n                    }\n                };\n                /**\n     * Applies `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} delta The amount of time elapsed between updates\n     */ Engine._bodiesUpdate = function(bodies, delta) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        if (body.isStatic || body.isSleeping) continue;\n                        Body.update(body, delta);\n                    }\n                };\n                /**\n     * Applies `Body.updateVelocities` to all given `bodies`.\n     * @method _bodiesUpdateVelocities\n     * @private\n     * @param {body[]} bodies\n     */ Engine._bodiesUpdateVelocities = function(bodies) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        Body.updateVelocities(bodies[i]);\n                    }\n                };\n            /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */ /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after bodies updated based on their velocity and forces, but before any collision detection, constraints and resolving etc.\n    *\n    * @event beforeSolve\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */ /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */ /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */ /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */ /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */ /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     * \n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     * \n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     * \n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */ /**\n     * A `Matter.Detector` instance.\n     *\n     * @property detector\n     * @type detector\n     * @default a Matter.Detector instance\n     */ /**\n     * A `Matter.Grid` instance.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */ /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */ /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * An optional gravitational acceleration applied to all bodies in `engine.world` on every update.\n     * \n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet. For gravity in other contexts, disable this and apply forces as needed.\n     * \n     * To disable set the `scale` component to `0`.\n     * \n     * This is split into three components for ease of use:  \n     * a normalised direction (`x` and `y`) and magnitude (`scale`).\n     *\n     * @property gravity\n     * @type object\n     */ /**\n     * The gravitational direction normal `x` component, to be multiplied by `gravity.scale`.\n     * \n     * @property gravity.x\n     * @type object\n     * @default 0\n     */ /**\n     * The gravitational direction normal `y` component, to be multiplied by `gravity.scale`.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */ /**\n     * The magnitude of the gravitational acceleration.\n     * \n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */ })();\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_259572__) {\n            /**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/ var Resolver = {};\n            module1.exports = Resolver;\n            var Vertices = __nested_webpack_require_259572__(3);\n            var Common = __nested_webpack_require_259572__(0);\n            var Bounds = __nested_webpack_require_259572__(1);\n            (function() {\n                Resolver._restingThresh = 2;\n                Resolver._restingThreshTangent = Math.sqrt(6);\n                Resolver._positionDampen = 0.9;\n                Resolver._positionWarming = 0.8;\n                Resolver._frictionNormalMultiplier = 5;\n                Resolver._frictionMaxStatic = Number.MAX_VALUE;\n                /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */ Resolver.preSolvePosition = function(pairs) {\n                    var i, pair, contactCount, pairsLength = pairs.length;\n                    // find total contacts on each body\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        contactCount = pair.contactCount;\n                        pair.collision.parentA.totalContacts += contactCount;\n                        pair.collision.parentB.totalContacts += contactCount;\n                    }\n                };\n                /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} delta\n     * @param {number} [damping=1]\n     */ Resolver.solvePosition = function(pairs, delta, damping) {\n                    var i, pair, collision, bodyA, bodyB, normal, contactShare, positionImpulse, positionDampen = Resolver._positionDampen * (damping || 1), slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1), pairsLength = pairs.length;\n                    // find impulses required to resolve penetration\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        collision = pair.collision;\n                        bodyA = collision.parentA;\n                        bodyB = collision.parentB;\n                        normal = collision.normal;\n                        // get current separation between body edges involved in collision\n                        pair.separation = collision.depth + normal.x * (bodyB.positionImpulse.x - bodyA.positionImpulse.x) + normal.y * (bodyB.positionImpulse.y - bodyA.positionImpulse.y);\n                    }\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        collision = pair.collision;\n                        bodyA = collision.parentA;\n                        bodyB = collision.parentB;\n                        normal = collision.normal;\n                        positionImpulse = pair.separation - pair.slop * slopDampen;\n                        if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;\n                        if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                            contactShare = positionDampen / bodyA.totalContacts;\n                            bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                            bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n                        }\n                        if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                            contactShare = positionDampen / bodyB.totalContacts;\n                            bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                            bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n                        }\n                    }\n                };\n                /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */ Resolver.postSolvePosition = function(bodies) {\n                    var positionWarming = Resolver._positionWarming, bodiesLength = bodies.length, verticesTranslate = Vertices.translate, boundsUpdate = Bounds.update;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i], positionImpulse = body.positionImpulse, positionImpulseX = positionImpulse.x, positionImpulseY = positionImpulse.y, velocity = body.velocity;\n                        // reset contact count\n                        body.totalContacts = 0;\n                        if (positionImpulseX !== 0 || positionImpulseY !== 0) {\n                            // update body geometry\n                            for(var j = 0; j < body.parts.length; j++){\n                                var part = body.parts[j];\n                                verticesTranslate(part.vertices, positionImpulse);\n                                boundsUpdate(part.bounds, part.vertices, velocity);\n                                part.position.x += positionImpulseX;\n                                part.position.y += positionImpulseY;\n                            }\n                            // move the body without changing velocity\n                            body.positionPrev.x += positionImpulseX;\n                            body.positionPrev.y += positionImpulseY;\n                            if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {\n                                // reset cached impulse if the body has velocity along it\n                                positionImpulse.x = 0;\n                                positionImpulse.y = 0;\n                            } else {\n                                // warm the next iteration\n                                positionImpulse.x *= positionWarming;\n                                positionImpulse.y *= positionWarming;\n                            }\n                        }\n                    }\n                };\n                /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */ Resolver.preSolveVelocity = function(pairs) {\n                    var pairsLength = pairs.length, i, j;\n                    for(i = 0; i < pairsLength; i++){\n                        var pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        var contacts = pair.contacts, contactCount = pair.contactCount, collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent;\n                        // resolve each contact\n                        for(j = 0; j < contactCount; j++){\n                            var contact = contacts[j], contactVertex = contact.vertex, normalImpulse = contact.normalImpulse, tangentImpulse = contact.tangentImpulse;\n                            if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                                // total impulse from contact\n                                var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse, impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;\n                                // apply impulse from contact\n                                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                                    bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                                    bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                                    bodyA.anglePrev += bodyA.inverseInertia * ((contactVertex.x - bodyA.position.x) * impulseY - (contactVertex.y - bodyA.position.y) * impulseX);\n                                }\n                                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                                    bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                                    bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                                    bodyB.anglePrev -= bodyB.inverseInertia * ((contactVertex.x - bodyB.position.x) * impulseY - (contactVertex.y - bodyB.position.y) * impulseX);\n                                }\n                            }\n                        }\n                    }\n                };\n                /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} delta\n     */ Resolver.solveVelocity = function(pairs, delta) {\n                    var timeScale = delta / Common._baseDelta, timeScaleSquared = timeScale * timeScale, timeScaleCubed = timeScaleSquared * timeScale, restingThresh = -Resolver._restingThresh * timeScale, restingThreshTangent = Resolver._restingThreshTangent, frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale, frictionMaxStatic = Resolver._frictionMaxStatic, pairsLength = pairs.length, tangentImpulse, maxFriction, i, j;\n                    for(i = 0; i < pairsLength; i++){\n                        var pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normalX = collision.normal.x, normalY = collision.normal.y, tangentX = collision.tangent.x, tangentY = collision.tangent.y, inverseMassTotal = pair.inverseMass, friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier, contacts = pair.contacts, contactCount = pair.contactCount, contactShare = 1 / contactCount;\n                        // get body velocities\n                        var bodyAVelocityX = bodyA.position.x - bodyA.positionPrev.x, bodyAVelocityY = bodyA.position.y - bodyA.positionPrev.y, bodyAAngularVelocity = bodyA.angle - bodyA.anglePrev, bodyBVelocityX = bodyB.position.x - bodyB.positionPrev.x, bodyBVelocityY = bodyB.position.y - bodyB.positionPrev.y, bodyBAngularVelocity = bodyB.angle - bodyB.anglePrev;\n                        // resolve each contact\n                        for(j = 0; j < contactCount; j++){\n                            var contact = contacts[j], contactVertex = contact.vertex;\n                            var offsetAX = contactVertex.x - bodyA.position.x, offsetAY = contactVertex.y - bodyA.position.y, offsetBX = contactVertex.x - bodyB.position.x, offsetBY = contactVertex.y - bodyB.position.y;\n                            var velocityPointAX = bodyAVelocityX - offsetAY * bodyAAngularVelocity, velocityPointAY = bodyAVelocityY + offsetAX * bodyAAngularVelocity, velocityPointBX = bodyBVelocityX - offsetBY * bodyBAngularVelocity, velocityPointBY = bodyBVelocityY + offsetBX * bodyBAngularVelocity;\n                            var relativeVelocityX = velocityPointAX - velocityPointBX, relativeVelocityY = velocityPointAY - velocityPointBY;\n                            var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY, tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;\n                            // coulomb friction\n                            var normalOverlap = pair.separation + normalVelocity;\n                            var normalForce = Math.min(normalOverlap, 1);\n                            normalForce = normalOverlap < 0 ? 0 : normalForce;\n                            var frictionLimit = normalForce * friction;\n                            if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {\n                                maxFriction = tangentVelocity > 0 ? tangentVelocity : -tangentVelocity;\n                                tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;\n                                if (tangentImpulse < -maxFriction) {\n                                    tangentImpulse = -maxFriction;\n                                } else if (tangentImpulse > maxFriction) {\n                                    tangentImpulse = maxFriction;\n                                }\n                            } else {\n                                tangentImpulse = tangentVelocity;\n                                maxFriction = frictionMaxStatic;\n                            }\n                            // account for mass, inertia and contact offset\n                            var oAcN = offsetAX * normalY - offsetAY * normalX, oBcN = offsetBX * normalY - offsetBY * normalX, share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n                            // raw impulses\n                            var normalImpulse = (1 + pair.restitution) * normalVelocity * share;\n                            tangentImpulse *= share;\n                            // handle high velocity and resting collisions separately\n                            if (normalVelocity < restingThresh) {\n                                // high normal velocity so clear cached contact normal impulse\n                                contact.normalImpulse = 0;\n                            } else {\n                                // solve resting collision constraints using Erin Catto's method (GDC08)\n                                // impulse constraint tends to 0\n                                var contactNormalImpulse = contact.normalImpulse;\n                                contact.normalImpulse += normalImpulse;\n                                if (contact.normalImpulse > 0) contact.normalImpulse = 0;\n                                normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                            }\n                            // handle high velocity and resting collisions separately\n                            if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {\n                                // high tangent velocity so clear cached contact tangent impulse\n                                contact.tangentImpulse = 0;\n                            } else {\n                                // solve resting collision constraints using Erin Catto's method (GDC08)\n                                // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                                var contactTangentImpulse = contact.tangentImpulse;\n                                contact.tangentImpulse += tangentImpulse;\n                                if (contact.tangentImpulse < -maxFriction) contact.tangentImpulse = -maxFriction;\n                                if (contact.tangentImpulse > maxFriction) contact.tangentImpulse = maxFriction;\n                                tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                            }\n                            // total impulse from contact\n                            var impulseX = normalX * normalImpulse + tangentX * tangentImpulse, impulseY = normalY * normalImpulse + tangentY * tangentImpulse;\n                            // apply impulse from contact\n                            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                                bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                                bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                                bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;\n                            }\n                            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                                bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                                bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                                bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;\n                            }\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_275616__) {\n            /**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/ var Pairs = {};\n            module1.exports = Pairs;\n            var Pair = __nested_webpack_require_275616__(9);\n            var Common = __nested_webpack_require_275616__(0);\n            (function() {\n                /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */ Pairs.create = function(options) {\n                    return Common.extend({\n                        table: {},\n                        list: [],\n                        collisionStart: [],\n                        collisionActive: [],\n                        collisionEnd: []\n                    }, options);\n                };\n                /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */ Pairs.update = function(pairs, collisions, timestamp) {\n                    var pairUpdate = Pair.update, pairCreate = Pair.create, pairSetActive = Pair.setActive, pairsTable = pairs.table, pairsList = pairs.list, pairsListLength = pairsList.length, pairsListIndex = pairsListLength, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collisionsLength = collisions.length, collisionStartIndex = 0, collisionEndIndex = 0, collisionActiveIndex = 0, collision, pair, i;\n                    for(i = 0; i < collisionsLength; i++){\n                        collision = collisions[i];\n                        pair = collision.pair;\n                        if (pair) {\n                            // pair already exists (but may or may not be active)\n                            if (pair.isActive) {\n                                // pair exists and is active\n                                collisionActive[collisionActiveIndex++] = pair;\n                            }\n                            // update the pair\n                            pairUpdate(pair, collision, timestamp);\n                        } else {\n                            // pair did not exist, create a new pair\n                            pair = pairCreate(collision, timestamp);\n                            pairsTable[pair.id] = pair;\n                            // add the new pair\n                            collisionStart[collisionStartIndex++] = pair;\n                            pairsList[pairsListIndex++] = pair;\n                        }\n                    }\n                    // find pairs that are no longer active\n                    pairsListIndex = 0;\n                    pairsListLength = pairsList.length;\n                    for(i = 0; i < pairsListLength; i++){\n                        pair = pairsList[i];\n                        // pair is active if updated this timestep\n                        if (pair.timeUpdated >= timestamp) {\n                            // keep active pairs\n                            pairsList[pairsListIndex++] = pair;\n                        } else {\n                            pairSetActive(pair, false, timestamp);\n                            // keep inactive pairs if both bodies may be sleeping\n                            if (pair.collision.bodyA.sleepCounter > 0 && pair.collision.bodyB.sleepCounter > 0) {\n                                pairsList[pairsListIndex++] = pair;\n                            } else {\n                                // remove inactive pairs if either body awake\n                                collisionEnd[collisionEndIndex++] = pair;\n                                delete pairsTable[pair.id];\n                            }\n                        }\n                    }\n                    // update array lengths if changed\n                    if (pairsList.length !== pairsListIndex) {\n                        pairsList.length = pairsListIndex;\n                    }\n                    if (collisionStart.length !== collisionStartIndex) {\n                        collisionStart.length = collisionStartIndex;\n                    }\n                    if (collisionEnd.length !== collisionEndIndex) {\n                        collisionEnd.length = collisionEndIndex;\n                    }\n                    if (collisionActive.length !== collisionActiveIndex) {\n                        collisionActive.length = collisionActiveIndex;\n                    }\n                };\n                /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */ Pairs.clear = function(pairs) {\n                    pairs.table = {};\n                    pairs.list.length = 0;\n                    pairs.collisionStart.length = 0;\n                    pairs.collisionActive.length = 0;\n                    pairs.collisionEnd.length = 0;\n                    return pairs;\n                };\n            })();\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_280695__) {\n            var Matter = module1.exports = __nested_webpack_require_280695__(21);\n            Matter.Axes = __nested_webpack_require_280695__(11);\n            Matter.Bodies = __nested_webpack_require_280695__(12);\n            Matter.Body = __nested_webpack_require_280695__(4);\n            Matter.Bounds = __nested_webpack_require_280695__(1);\n            Matter.Collision = __nested_webpack_require_280695__(8);\n            Matter.Common = __nested_webpack_require_280695__(0);\n            Matter.Composite = __nested_webpack_require_280695__(6);\n            Matter.Composites = __nested_webpack_require_280695__(22);\n            Matter.Constraint = __nested_webpack_require_280695__(10);\n            Matter.Contact = __nested_webpack_require_280695__(16);\n            Matter.Detector = __nested_webpack_require_280695__(13);\n            Matter.Engine = __nested_webpack_require_280695__(17);\n            Matter.Events = __nested_webpack_require_280695__(5);\n            Matter.Grid = __nested_webpack_require_280695__(23);\n            Matter.Mouse = __nested_webpack_require_280695__(14);\n            Matter.MouseConstraint = __nested_webpack_require_280695__(24);\n            Matter.Pair = __nested_webpack_require_280695__(9);\n            Matter.Pairs = __nested_webpack_require_280695__(19);\n            Matter.Plugin = __nested_webpack_require_280695__(15);\n            Matter.Query = __nested_webpack_require_280695__(25);\n            Matter.Render = __nested_webpack_require_280695__(26);\n            Matter.Resolver = __nested_webpack_require_280695__(18);\n            Matter.Runner = __nested_webpack_require_280695__(27);\n            Matter.SAT = __nested_webpack_require_280695__(28);\n            Matter.Sleeping = __nested_webpack_require_280695__(7);\n            Matter.Svg = __nested_webpack_require_280695__(29);\n            Matter.Vector = __nested_webpack_require_280695__(2);\n            Matter.Vertices = __nested_webpack_require_280695__(3);\n            Matter.World = __nested_webpack_require_280695__(30);\n            // temporary back compatibility\n            Matter.Engine.run = Matter.Runner.run;\n            Matter.Common.deprecated(Matter.Engine, \"run\", \"Engine.run ➤ use Matter.Runner.run(engine) instead\");\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __nested_webpack_require_282604__) {\n            /**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/ var Matter = {};\n            module1.exports = Matter;\n            var Plugin = __nested_webpack_require_282604__(15);\n            var Common = __nested_webpack_require_282604__(0);\n            (function() {\n                /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */ Matter.name = \"matter-js\";\n                /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */ Matter.version =  true ? \"0.20.0\" : 0;\n                /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */ Matter.uses = [];\n                /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */ Matter.used = [];\n                /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */ Matter.use = function() {\n                    Plugin.use(Matter, Array.prototype.slice.call(arguments));\n                };\n                /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */ Matter.before = function(path, func) {\n                    path = path.replace(/^Matter./, \"\");\n                    return Common.chainPathBefore(Matter, path, func);\n                };\n                /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */ Matter.after = function(path, func) {\n                    path = path.replace(/^Matter./, \"\");\n                    return Common.chainPathAfter(Matter, path, func);\n                };\n            })();\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_285696__) {\n            /**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/ var Composites = {};\n            module1.exports = Composites;\n            var Composite = __nested_webpack_require_285696__(6);\n            var Constraint = __nested_webpack_require_285696__(10);\n            var Common = __nested_webpack_require_285696__(0);\n            var Body = __nested_webpack_require_285696__(4);\n            var Bodies = __nested_webpack_require_285696__(12);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */ Composites.stack = function(x, y, columns, rows, columnGap, rowGap, callback) {\n                    var stack = Composite.create({\n                        label: \"Stack\"\n                    }), currentX = x, currentY = y, lastBody, i = 0;\n                    for(var row = 0; row < rows; row++){\n                        var maxHeight = 0;\n                        for(var column = 0; column < columns; column++){\n                            var body = callback(currentX, currentY, column, row, lastBody, i);\n                            if (body) {\n                                var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;\n                                if (bodyHeight > maxHeight) maxHeight = bodyHeight;\n                                Body.translate(body, {\n                                    x: bodyWidth * 0.5,\n                                    y: bodyHeight * 0.5\n                                });\n                                currentX = body.bounds.max.x + columnGap;\n                                Composite.addBody(stack, body);\n                                lastBody = body;\n                                i += 1;\n                            } else {\n                                currentX += columnGap;\n                            }\n                        }\n                        currentY += maxHeight + rowGap;\n                        currentX = x;\n                    }\n                    return stack;\n                };\n                /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */ Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n                    var bodies = composite.bodies;\n                    for(var i = 1; i < bodies.length; i++){\n                        var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n                        var defaults = {\n                            bodyA: bodyA,\n                            pointA: {\n                                x: bodyAWidth * xOffsetA,\n                                y: bodyAHeight * yOffsetA\n                            },\n                            bodyB: bodyB,\n                            pointB: {\n                                x: bodyBWidth * xOffsetB,\n                                y: bodyBHeight * yOffsetB\n                            }\n                        };\n                        var constraint = Common.extend(defaults, options);\n                        Composite.addConstraint(composite, Constraint.create(constraint));\n                    }\n                    composite.label += \" Chain\";\n                    return composite;\n                };\n                /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */ Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n                    var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;\n                    for(row = 0; row < rows; row++){\n                        for(col = 1; col < columns; col++){\n                            bodyA = bodies[col - 1 + row * columns];\n                            bodyB = bodies[col + row * columns];\n                            Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                bodyA: bodyA,\n                                bodyB: bodyB\n                            }, options)));\n                        }\n                        if (row > 0) {\n                            for(col = 0; col < columns; col++){\n                                bodyA = bodies[col + (row - 1) * columns];\n                                bodyB = bodies[col + row * columns];\n                                Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                    bodyA: bodyA,\n                                    bodyB: bodyB\n                                }, options)));\n                                if (crossBrace && col > 0) {\n                                    bodyC = bodies[col - 1 + (row - 1) * columns];\n                                    Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                        bodyA: bodyC,\n                                        bodyB: bodyB\n                                    }, options)));\n                                }\n                                if (crossBrace && col < columns - 1) {\n                                    bodyC = bodies[col + 1 + (row - 1) * columns];\n                                    Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                        bodyA: bodyC,\n                                        bodyB: bodyB\n                                    }, options)));\n                                }\n                            }\n                        }\n                    }\n                    composite.label += \" Mesh\";\n                    return composite;\n                };\n                /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */ Composites.pyramid = function(x, y, columns, rows, columnGap, rowGap, callback) {\n                    return Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY, column, row, lastBody, i) {\n                        var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n                        if (row > actualRows) return;\n                        // reverse row order\n                        row = actualRows - row;\n                        var start = row, end = columns - 1 - row;\n                        if (column < start || column > end) return;\n                        // retroactively fix the first body's position, since width was unknown\n                        if (i === 1) {\n                            Body.translate(lastBody, {\n                                x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,\n                                y: 0\n                            });\n                        }\n                        var xOffset = lastBody ? column * lastBodyWidth : 0;\n                        return callback(x + xOffset + column * columnGap, stackY, column, row, lastBody, i);\n                    });\n                };\n                /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */ Composites.newtonsCradle = function(x, y, number, size, length) {\n                    var newtonsCradle = Composite.create({\n                        label: \"Newtons Cradle\"\n                    });\n                    for(var i = 0; i < number; i++){\n                        var separation = 1.9, circle = Bodies.circle(x + i * (size * separation), y + length, size, {\n                            inertia: Infinity,\n                            restitution: 1,\n                            friction: 0,\n                            frictionAir: 0.0001,\n                            slop: 1\n                        }), constraint = Constraint.create({\n                            pointA: {\n                                x: x + i * (size * separation),\n                                y: y\n                            },\n                            bodyB: circle\n                        });\n                        Composite.addBody(newtonsCradle, circle);\n                        Composite.addConstraint(newtonsCradle, constraint);\n                    }\n                    return newtonsCradle;\n                };\n                deprecated(Composites, \"newtonsCradle\", \"Composites.newtonsCradle ➤ moved to newtonsCradle example\");\n                /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */ Composites.car = function(x, y, width, height, wheelSize) {\n                    var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;\n                    var car = Composite.create({\n                        label: \"Car\"\n                    }), body = Bodies.rectangle(x, y, width, height, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        chamfer: {\n                            radius: height * 0.5\n                        },\n                        density: 0.0002\n                    });\n                    var wheelA = Bodies.circle(x + wheelAOffset, y + wheelYOffset, wheelSize, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        friction: 0.8\n                    });\n                    var wheelB = Bodies.circle(x + wheelBOffset, y + wheelYOffset, wheelSize, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        friction: 0.8\n                    });\n                    var axelA = Constraint.create({\n                        bodyB: body,\n                        pointB: {\n                            x: wheelAOffset,\n                            y: wheelYOffset\n                        },\n                        bodyA: wheelA,\n                        stiffness: 1,\n                        length: 0\n                    });\n                    var axelB = Constraint.create({\n                        bodyB: body,\n                        pointB: {\n                            x: wheelBOffset,\n                            y: wheelYOffset\n                        },\n                        bodyA: wheelB,\n                        stiffness: 1,\n                        length: 0\n                    });\n                    Composite.addBody(car, body);\n                    Composite.addBody(car, wheelA);\n                    Composite.addBody(car, wheelB);\n                    Composite.addConstraint(car, axelA);\n                    Composite.addConstraint(car, axelB);\n                    return car;\n                };\n                deprecated(Composites, \"car\", \"Composites.car ➤ moved to car example\");\n                /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} x Starting position in X.\n     * @param {number} y Starting position in Y.\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */ Composites.softBody = function(x, y, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n                    particleOptions = Common.extend({\n                        inertia: Infinity\n                    }, particleOptions);\n                    constraintOptions = Common.extend({\n                        stiffness: 0.2,\n                        render: {\n                            type: \"line\",\n                            anchors: false\n                        }\n                    }, constraintOptions);\n                    var softBody = Composites.stack(x, y, columns, rows, columnGap, rowGap, function(stackX, stackY) {\n                        return Bodies.circle(stackX, stackY, particleRadius, particleOptions);\n                    });\n                    Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n                    softBody.label = \"Soft Body\";\n                    return softBody;\n                };\n                deprecated(Composites, \"softBody\", \"Composites.softBody ➤ moved to softBody and cloth examples\");\n            })();\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_301274__) {\n            /**\n* This module has now been replaced by `Matter.Detector`.\n*\n* All usage should be migrated to `Matter.Detector` or another alternative.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n* @deprecated\n*/ var Grid = {};\n            module1.exports = Grid;\n            var Pair = __nested_webpack_require_301274__(9);\n            var Common = __nested_webpack_require_301274__(0);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Creates a new grid.\n     * @deprecated replaced by Matter.Detector\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */ Grid.create = function(options) {\n                    var defaults = {\n                        buckets: {},\n                        pairs: {},\n                        pairsList: [],\n                        bucketWidth: 48,\n                        bucketHeight: 48\n                    };\n                    return Common.extend(defaults, options);\n                };\n                /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */ /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */ /**\n     * Updates the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */ Grid.update = function(grid, bodies, engine, forceUpdate) {\n                    var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;\n                    for(i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (body.isSleeping && !forceUpdate) continue;\n                        // temporary back compatibility bounds check\n                        if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)) continue;\n                        var newRegion = Grid._getRegion(grid, body);\n                        // if the body has changed grid region\n                        if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n                            if (!body.region || forceUpdate) body.region = newRegion;\n                            var union = Grid._regionUnion(newRegion, body.region);\n                            // update grid buckets affected by region change\n                            // iterate over the union of both regions\n                            for(col = union.startCol; col <= union.endCol; col++){\n                                for(row = union.startRow; row <= union.endRow; row++){\n                                    bucketId = Grid._getBucketId(col, row);\n                                    bucket = buckets[bucketId];\n                                    var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;\n                                    var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;\n                                    // remove from old region buckets\n                                    if (!isInsideNewRegion && isInsideOldRegion) {\n                                        if (isInsideOldRegion) {\n                                            if (bucket) Grid._bucketRemoveBody(grid, bucket, body);\n                                        }\n                                    }\n                                    // add to new region buckets\n                                    if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {\n                                        if (!bucket) bucket = Grid._createBucket(buckets, bucketId);\n                                        Grid._bucketAddBody(grid, bucket, body);\n                                    }\n                                }\n                            }\n                            // set the new region\n                            body.region = newRegion;\n                            // flag changes so we can update pairs\n                            gridChanged = true;\n                        }\n                    }\n                    // update pairs list only if pairs changed (i.e. a body changed region)\n                    if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);\n                };\n                deprecated(Grid, \"update\", \"Grid.update ➤ replaced by Matter.Detector\");\n                /**\n     * Clears the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method clear\n     * @param {grid} grid\n     */ Grid.clear = function(grid) {\n                    grid.buckets = {};\n                    grid.pairs = {};\n                    grid.pairsList = [];\n                };\n                deprecated(Grid, \"clear\", \"Grid.clear ➤ replaced by Matter.Detector\");\n                /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */ Grid._regionUnion = function(regionA, regionB) {\n                    var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);\n                    return Grid._createRegion(startCol, endCol, startRow, endRow);\n                };\n                /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */ Grid._getRegion = function(grid, body) {\n                    var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n                    return Grid._createRegion(startCol, endCol, startRow, endRow);\n                };\n                /**\n     * Creates a region.\n     * @method _createRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */ Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n                    return {\n                        id: startCol + \",\" + endCol + \",\" + startRow + \",\" + endRow,\n                        startCol: startCol,\n                        endCol: endCol,\n                        startRow: startRow,\n                        endRow: endRow\n                    };\n                };\n                /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */ Grid._getBucketId = function(column, row) {\n                    return \"C\" + column + \"R\" + row;\n                };\n                /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */ Grid._createBucket = function(buckets, bucketId) {\n                    var bucket = buckets[bucketId] = [];\n                    return bucket;\n                };\n                /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */ Grid._bucketAddBody = function(grid, bucket, body) {\n                    var gridPairs = grid.pairs, pairId = Pair.id, bucketLength = bucket.length, i;\n                    // add new pairs\n                    for(i = 0; i < bucketLength; i++){\n                        var bodyB = bucket[i];\n                        if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue;\n                        // keep track of the number of buckets the pair exists in\n                        // important for Grid.update to work\n                        var id = pairId(body, bodyB), pair = gridPairs[id];\n                        if (pair) {\n                            pair[2] += 1;\n                        } else {\n                            gridPairs[id] = [\n                                body,\n                                bodyB,\n                                1\n                            ];\n                        }\n                    }\n                    // add to bodies (after pairs, otherwise pairs with self)\n                    bucket.push(body);\n                };\n                /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */ Grid._bucketRemoveBody = function(grid, bucket, body) {\n                    var gridPairs = grid.pairs, pairId = Pair.id, i;\n                    // remove from bucket\n                    bucket.splice(Common.indexOf(bucket, body), 1);\n                    var bucketLength = bucket.length;\n                    // update pair counts\n                    for(i = 0; i < bucketLength; i++){\n                        // keep track of the number of buckets the pair exists in\n                        // important for _createActivePairsList to work\n                        var pair = gridPairs[pairId(body, bucket[i])];\n                        if (pair) pair[2] -= 1;\n                    }\n                };\n                /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */ Grid._createActivePairsList = function(grid) {\n                    var pair, gridPairs = grid.pairs, pairKeys = Common.keys(gridPairs), pairKeysLength = pairKeys.length, pairs = [], k;\n                    // iterate over grid.pairs\n                    for(k = 0; k < pairKeysLength; k++){\n                        pair = gridPairs[pairKeys[k]];\n                        // if pair exists in at least one bucket\n                        // it is a pair that needs further collision testing so push it\n                        if (pair[2] > 0) {\n                            pairs.push(pair);\n                        } else {\n                            delete gridPairs[pairKeys[k]];\n                        }\n                    }\n                    return pairs;\n                };\n            })();\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_312689__) {\n            /**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/ var MouseConstraint = {};\n            module1.exports = MouseConstraint;\n            var Vertices = __nested_webpack_require_312689__(3);\n            var Sleeping = __nested_webpack_require_312689__(7);\n            var Mouse = __nested_webpack_require_312689__(14);\n            var Events = __nested_webpack_require_312689__(5);\n            var Detector = __nested_webpack_require_312689__(13);\n            var Constraint = __nested_webpack_require_312689__(10);\n            var Composite = __nested_webpack_require_312689__(6);\n            var Common = __nested_webpack_require_312689__(0);\n            var Bounds = __nested_webpack_require_312689__(1);\n            (function() {\n                /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */ MouseConstraint.create = function(engine, options) {\n                    var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n                    if (!mouse) {\n                        if (engine && engine.render && engine.render.canvas) {\n                            mouse = Mouse.create(engine.render.canvas);\n                        } else if (options && options.element) {\n                            mouse = Mouse.create(options.element);\n                        } else {\n                            mouse = Mouse.create();\n                            Common.warn(\"MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected\");\n                        }\n                    }\n                    var constraint = Constraint.create({\n                        label: \"Mouse Constraint\",\n                        pointA: mouse.position,\n                        pointB: {\n                            x: 0,\n                            y: 0\n                        },\n                        length: 0.01,\n                        stiffness: 0.1,\n                        angularStiffness: 1,\n                        render: {\n                            strokeStyle: \"#90EE90\",\n                            lineWidth: 3\n                        }\n                    });\n                    var defaults = {\n                        type: \"mouseConstraint\",\n                        mouse: mouse,\n                        element: null,\n                        body: null,\n                        constraint: constraint,\n                        collisionFilter: {\n                            category: 0x0001,\n                            mask: 0xFFFFFFFF,\n                            group: 0\n                        }\n                    };\n                    var mouseConstraint = Common.extend(defaults, options);\n                    Events.on(engine, \"beforeUpdate\", function() {\n                        var allBodies = Composite.allBodies(engine.world);\n                        MouseConstraint.update(mouseConstraint, allBodies);\n                        MouseConstraint._triggerEvents(mouseConstraint);\n                    });\n                    return mouseConstraint;\n                };\n                /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */ MouseConstraint.update = function(mouseConstraint, bodies) {\n                    var mouse = mouseConstraint.mouse, constraint = mouseConstraint.constraint, body = mouseConstraint.body;\n                    if (mouse.button === 0) {\n                        if (!constraint.bodyB) {\n                            for(var i = 0; i < bodies.length; i++){\n                                body = bodies[i];\n                                if (Bounds.contains(body.bounds, mouse.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                                    for(var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++){\n                                        var part = body.parts[j];\n                                        if (Vertices.contains(part.vertices, mouse.position)) {\n                                            constraint.pointA = mouse.position;\n                                            constraint.bodyB = mouseConstraint.body = body;\n                                            constraint.pointB = {\n                                                x: mouse.position.x - body.position.x,\n                                                y: mouse.position.y - body.position.y\n                                            };\n                                            constraint.angleB = body.angle;\n                                            Sleeping.set(body, false);\n                                            Events.trigger(mouseConstraint, \"startdrag\", {\n                                                mouse: mouse,\n                                                body: body\n                                            });\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            Sleeping.set(constraint.bodyB, false);\n                            constraint.pointA = mouse.position;\n                        }\n                    } else {\n                        constraint.bodyB = mouseConstraint.body = null;\n                        constraint.pointB = null;\n                        if (body) Events.trigger(mouseConstraint, \"enddrag\", {\n                            mouse: mouse,\n                            body: body\n                        });\n                    }\n                };\n                /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */ MouseConstraint._triggerEvents = function(mouseConstraint) {\n                    var mouse = mouseConstraint.mouse, mouseEvents = mouse.sourceEvents;\n                    if (mouseEvents.mousemove) Events.trigger(mouseConstraint, \"mousemove\", {\n                        mouse: mouse\n                    });\n                    if (mouseEvents.mousedown) Events.trigger(mouseConstraint, \"mousedown\", {\n                        mouse: mouse\n                    });\n                    if (mouseEvents.mouseup) Events.trigger(mouseConstraint, \"mouseup\", {\n                        mouse: mouse\n                    });\n                    // reset the mouse state ready for the next step\n                    Mouse.clearSourceEvents(mouse);\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */ /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */ /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */ /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */ /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */ })();\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_322705__) {\n            /**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/ var Query = {};\n            module1.exports = Query;\n            var Vector = __nested_webpack_require_322705__(2);\n            var Collision = __nested_webpack_require_322705__(8);\n            var Bounds = __nested_webpack_require_322705__(1);\n            var Bodies = __nested_webpack_require_322705__(12);\n            var Vertices = __nested_webpack_require_322705__(3);\n            (function() {\n                /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {collision[]} Collisions\n     */ Query.collides = function(body, bodies) {\n                    var collisions = [], bodiesLength = bodies.length, bounds = body.bounds, collides = Collision.collides, overlaps = Bounds.overlaps;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var bodyA = bodies[i], partsALength = bodyA.parts.length, partsAStart = partsALength === 1 ? 0 : 1;\n                        if (overlaps(bodyA.bounds, bounds)) {\n                            for(var j = partsAStart; j < partsALength; j++){\n                                var part = bodyA.parts[j];\n                                if (overlaps(part.bounds, bounds)) {\n                                    var collision = collides(part, body);\n                                    if (collision) {\n                                        collisions.push(collision);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return collisions;\n                };\n                /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {collision[]} Collisions\n     */ Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n                    rayWidth = rayWidth || 1e-100;\n                    var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {\n                        angle: rayAngle\n                    }), collisions = Query.collides(ray, bodies);\n                    for(var i = 0; i < collisions.length; i += 1){\n                        var collision = collisions[i];\n                        collision.body = collision.bodyB = collision.bodyA;\n                    }\n                    return collisions;\n                };\n                /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */ Query.region = function(bodies, bounds, outside) {\n                    var result = [];\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);\n                        if (overlaps && !outside || !overlaps && outside) result.push(body);\n                    }\n                    return result;\n                };\n                /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */ Query.point = function(bodies, point) {\n                    var result = [];\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (Bounds.contains(body.bounds, point)) {\n                            for(var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++){\n                                var part = body.parts[j];\n                                if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {\n                                    result.push(body);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return result;\n                };\n            })();\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_327583__) {\n            /**\n* The `Matter.Render` module is a lightweight, optional utility which provides a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/ var Render = {};\n            module1.exports = Render;\n            var Body = __nested_webpack_require_327583__(4);\n            var Common = __nested_webpack_require_327583__(0);\n            var Composite = __nested_webpack_require_327583__(6);\n            var Bounds = __nested_webpack_require_327583__(1);\n            var Events = __nested_webpack_require_327583__(5);\n            var Vector = __nested_webpack_require_327583__(2);\n            var Mouse = __nested_webpack_require_327583__(14);\n            (function() {\n                var _requestAnimationFrame, _cancelAnimationFrame;\n                if (true) {\n                    _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n                        window.setTimeout(function() {\n                            callback(Common.now());\n                        }, 1000 / 60);\n                    };\n                    _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n                }\n                Render._goodFps = 30;\n                Render._goodDelta = 1000 / 60;\n                /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */ Render.create = function(options) {\n                    var defaults = {\n                        engine: null,\n                        element: null,\n                        canvas: null,\n                        mouse: null,\n                        frameRequestId: null,\n                        timing: {\n                            historySize: 60,\n                            delta: 0,\n                            deltaHistory: [],\n                            lastTime: 0,\n                            lastTimestamp: 0,\n                            lastElapsed: 0,\n                            timestampElapsed: 0,\n                            timestampElapsedHistory: [],\n                            engineDeltaHistory: [],\n                            engineElapsedHistory: [],\n                            engineUpdatesHistory: [],\n                            elapsedHistory: []\n                        },\n                        options: {\n                            width: 800,\n                            height: 600,\n                            pixelRatio: 1,\n                            background: \"#14151f\",\n                            wireframeBackground: \"#14151f\",\n                            wireframeStrokeStyle: \"#bbb\",\n                            hasBounds: !!options.bounds,\n                            enabled: true,\n                            wireframes: true,\n                            showSleeping: true,\n                            showDebug: false,\n                            showStats: false,\n                            showPerformance: false,\n                            showBounds: false,\n                            showVelocity: false,\n                            showCollisions: false,\n                            showSeparations: false,\n                            showAxes: false,\n                            showPositions: false,\n                            showAngleIndicator: false,\n                            showIds: false,\n                            showVertexNumbers: false,\n                            showConvexHulls: false,\n                            showInternalEdges: false,\n                            showMousePosition: false\n                        }\n                    };\n                    var render = Common.extend(defaults, options);\n                    if (render.canvas) {\n                        render.canvas.width = render.options.width || render.canvas.width;\n                        render.canvas.height = render.options.height || render.canvas.height;\n                    }\n                    render.mouse = options.mouse;\n                    render.engine = options.engine;\n                    render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n                    render.context = render.canvas.getContext(\"2d\");\n                    render.textures = {};\n                    render.bounds = render.bounds || {\n                        min: {\n                            x: 0,\n                            y: 0\n                        },\n                        max: {\n                            x: render.canvas.width,\n                            y: render.canvas.height\n                        }\n                    };\n                    // for temporary back compatibility only\n                    render.controller = Render;\n                    render.options.showBroadphase = false;\n                    if (render.options.pixelRatio !== 1) {\n                        Render.setPixelRatio(render, render.options.pixelRatio);\n                    }\n                    if (Common.isElement(render.element)) {\n                        render.element.appendChild(render.canvas);\n                    }\n                    return render;\n                };\n                /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */ Render.run = function(render) {\n                    (function loop(time) {\n                        render.frameRequestId = _requestAnimationFrame(loop);\n                        _updateTiming(render, time);\n                        Render.world(render, time);\n                        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n                        if (render.options.showStats || render.options.showDebug) {\n                            Render.stats(render, render.context, time);\n                        }\n                        if (render.options.showPerformance || render.options.showDebug) {\n                            Render.performance(render, render.context, time);\n                        }\n                        render.context.setTransform(1, 0, 0, 1, 0, 0);\n                    })();\n                };\n                /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */ Render.stop = function(render) {\n                    _cancelAnimationFrame(render.frameRequestId);\n                };\n                /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */ Render.setPixelRatio = function(render, pixelRatio) {\n                    var options = render.options, canvas = render.canvas;\n                    if (pixelRatio === \"auto\") {\n                        pixelRatio = _getPixelRatio(canvas);\n                    }\n                    options.pixelRatio = pixelRatio;\n                    canvas.setAttribute(\"data-pixel-ratio\", pixelRatio);\n                    canvas.width = options.width * pixelRatio;\n                    canvas.height = options.height * pixelRatio;\n                    canvas.style.width = options.width + \"px\";\n                    canvas.style.height = options.height + \"px\";\n                };\n                /**\n     * Sets the render `width` and `height`.\n     * \n     * Updates the canvas accounting for `render.options.pixelRatio`.  \n     * \n     * Updates the bottom right render bound `render.bounds.max` relative to the provided `width` and `height`.\n     * The top left render bound `render.bounds.min` isn't changed.\n     * \n     * Follow this call with `Render.lookAt` if you need to change the render bounds.\n     * \n     * See also `Render.setPixelRatio`.\n     * @method setSize\n     * @param {render} render\n     * @param {number} width The width (in CSS pixels)\n     * @param {number} height The height (in CSS pixels)\n     */ Render.setSize = function(render, width, height) {\n                    render.options.width = width;\n                    render.options.height = height;\n                    render.bounds.max.x = render.bounds.min.x + width;\n                    render.bounds.max.y = render.bounds.min.y + height;\n                    if (render.options.pixelRatio !== 1) {\n                        Render.setPixelRatio(render, render.options.pixelRatio);\n                    } else {\n                        render.canvas.width = width;\n                        render.canvas.height = height;\n                    }\n                };\n                /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */ Render.lookAt = function(render, objects, padding, center) {\n                    center = typeof center !== \"undefined\" ? center : true;\n                    objects = Common.isArray(objects) ? objects : [\n                        objects\n                    ];\n                    padding = padding || {\n                        x: 0,\n                        y: 0\n                    };\n                    // find bounds of all objects\n                    var bounds = {\n                        min: {\n                            x: Infinity,\n                            y: Infinity\n                        },\n                        max: {\n                            x: -Infinity,\n                            y: -Infinity\n                        }\n                    };\n                    for(var i = 0; i < objects.length; i += 1){\n                        var object = objects[i], min = object.bounds ? object.bounds.min : object.min || object.position || object, max = object.bounds ? object.bounds.max : object.max || object.position || object;\n                        if (min && max) {\n                            if (min.x < bounds.min.x) bounds.min.x = min.x;\n                            if (max.x > bounds.max.x) bounds.max.x = max.x;\n                            if (min.y < bounds.min.y) bounds.min.y = min.y;\n                            if (max.y > bounds.max.y) bounds.max.y = max.y;\n                        }\n                    }\n                    // find ratios\n                    var width = bounds.max.x - bounds.min.x + 2 * padding.x, height = bounds.max.y - bounds.min.y + 2 * padding.y, viewHeight = render.canvas.height, viewWidth = render.canvas.width, outerRatio = viewWidth / viewHeight, innerRatio = width / height, scaleX = 1, scaleY = 1;\n                    // find scale factor\n                    if (innerRatio > outerRatio) {\n                        scaleY = innerRatio / outerRatio;\n                    } else {\n                        scaleX = outerRatio / innerRatio;\n                    }\n                    // enable bounds\n                    render.options.hasBounds = true;\n                    // position and size\n                    render.bounds.min.x = bounds.min.x;\n                    render.bounds.max.x = bounds.min.x + width * scaleX;\n                    render.bounds.min.y = bounds.min.y;\n                    render.bounds.max.y = bounds.min.y + height * scaleY;\n                    // center\n                    if (center) {\n                        render.bounds.min.x += width * 0.5 - width * scaleX * 0.5;\n                        render.bounds.max.x += width * 0.5 - width * scaleX * 0.5;\n                        render.bounds.min.y += height * 0.5 - height * scaleY * 0.5;\n                        render.bounds.max.y += height * 0.5 - height * scaleY * 0.5;\n                    }\n                    // padding\n                    render.bounds.min.x -= padding.x;\n                    render.bounds.max.x -= padding.x;\n                    render.bounds.min.y -= padding.y;\n                    render.bounds.max.y -= padding.y;\n                    // update mouse\n                    if (render.mouse) {\n                        Mouse.setScale(render.mouse, {\n                            x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                            y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n                        });\n                        Mouse.setOffset(render.mouse, render.bounds.min);\n                    }\n                };\n                /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */ Render.startViewTransform = function(render) {\n                    var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;\n                    render.context.setTransform(render.options.pixelRatio / boundsScaleX, 0, 0, render.options.pixelRatio / boundsScaleY, 0, 0);\n                    render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n                };\n                /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */ Render.endViewTransform = function(render) {\n                    render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n                };\n                /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */ Render.world = function(render, time) {\n                    var startTime = Common.now(), engine = render.engine, world = engine.world, canvas = render.canvas, context = render.context, options = render.options, timing = render.timing;\n                    var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world), background = options.wireframes ? options.wireframeBackground : options.background, bodies = [], constraints = [], i;\n                    var event = {\n                        timestamp: engine.timing.timestamp\n                    };\n                    Events.trigger(render, \"beforeRender\", event);\n                    // apply background if it has changed\n                    if (render.currentBackground !== background) _applyBackground(render, background);\n                    // clear the canvas with a transparent fill, to allow the canvas background to show\n                    context.globalCompositeOperation = \"source-in\";\n                    context.fillStyle = \"transparent\";\n                    context.fillRect(0, 0, canvas.width, canvas.height);\n                    context.globalCompositeOperation = \"source-over\";\n                    // handle bounds\n                    if (options.hasBounds) {\n                        // filter out bodies that are not in view\n                        for(i = 0; i < allBodies.length; i++){\n                            var body = allBodies[i];\n                            if (Bounds.overlaps(body.bounds, render.bounds)) bodies.push(body);\n                        }\n                        // filter out constraints that are not in view\n                        for(i = 0; i < allConstraints.length; i++){\n                            var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;\n                            if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                            if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n                            if (!pointAWorld || !pointBWorld) continue;\n                            if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) constraints.push(constraint);\n                        }\n                        // transform the view\n                        Render.startViewTransform(render);\n                        // update mouse\n                        if (render.mouse) {\n                            Mouse.setScale(render.mouse, {\n                                x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                                y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                            });\n                            Mouse.setOffset(render.mouse, render.bounds.min);\n                        }\n                    } else {\n                        constraints = allConstraints;\n                        bodies = allBodies;\n                        if (render.options.pixelRatio !== 1) {\n                            render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n                        }\n                    }\n                    if (!options.wireframes || engine.enableSleeping && options.showSleeping) {\n                        // fully featured rendering of bodies\n                        Render.bodies(render, bodies, context);\n                    } else {\n                        if (options.showConvexHulls) Render.bodyConvexHulls(render, bodies, context);\n                        // optimised method for wireframes only\n                        Render.bodyWireframes(render, bodies, context);\n                    }\n                    if (options.showBounds) Render.bodyBounds(render, bodies, context);\n                    if (options.showAxes || options.showAngleIndicator) Render.bodyAxes(render, bodies, context);\n                    if (options.showPositions) Render.bodyPositions(render, bodies, context);\n                    if (options.showVelocity) Render.bodyVelocity(render, bodies, context);\n                    if (options.showIds) Render.bodyIds(render, bodies, context);\n                    if (options.showSeparations) Render.separations(render, engine.pairs.list, context);\n                    if (options.showCollisions) Render.collisions(render, engine.pairs.list, context);\n                    if (options.showVertexNumbers) Render.vertexNumbers(render, bodies, context);\n                    if (options.showMousePosition) Render.mousePosition(render, render.mouse, context);\n                    Render.constraints(constraints, context);\n                    if (options.hasBounds) {\n                        // revert view transforms\n                        Render.endViewTransform(render);\n                    }\n                    Events.trigger(render, \"afterRender\", event);\n                    // log the time elapsed computing this update\n                    timing.lastElapsed = Common.now() - startTime;\n                };\n                /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */ Render.stats = function(render, context, time) {\n                    var engine = render.engine, world = engine.world, bodies = Composite.allBodies(world), parts = 0, width = 55, height = 44, x = 0, y = 0;\n                    // count parts\n                    for(var i = 0; i < bodies.length; i += 1){\n                        parts += bodies[i].parts.length;\n                    }\n                    // sections\n                    var sections = {\n                        \"Part\": parts,\n                        \"Body\": bodies.length,\n                        \"Cons\": Composite.allConstraints(world).length,\n                        \"Comp\": Composite.allComposites(world).length,\n                        \"Pair\": engine.pairs.list.length\n                    };\n                    // background\n                    context.fillStyle = \"#0e0f19\";\n                    context.fillRect(x, y, width * 5.5, height);\n                    context.font = \"12px Arial\";\n                    context.textBaseline = \"top\";\n                    context.textAlign = \"right\";\n                    // sections\n                    for(var key in sections){\n                        var section = sections[key];\n                        // label\n                        context.fillStyle = \"#aaa\";\n                        context.fillText(key, x + width, y + 8);\n                        // value\n                        context.fillStyle = \"#eee\";\n                        context.fillText(section, x + width, y + 26);\n                        x += width;\n                    }\n                };\n                /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */ Render.performance = function(render, context) {\n                    var engine = render.engine, timing = render.timing, deltaHistory = timing.deltaHistory, elapsedHistory = timing.elapsedHistory, timestampElapsedHistory = timing.timestampElapsedHistory, engineDeltaHistory = timing.engineDeltaHistory, engineUpdatesHistory = timing.engineUpdatesHistory, engineElapsedHistory = timing.engineElapsedHistory, lastEngineUpdatesPerFrame = engine.timing.lastUpdatesPerFrame, lastEngineDelta = engine.timing.lastDelta;\n                    var deltaMean = _mean(deltaHistory), elapsedMean = _mean(elapsedHistory), engineDeltaMean = _mean(engineDeltaHistory), engineUpdatesMean = _mean(engineUpdatesHistory), engineElapsedMean = _mean(engineElapsedHistory), timestampElapsedMean = _mean(timestampElapsedHistory), rateMean = timestampElapsedMean / deltaMean || 0, neededUpdatesPerFrame = Math.round(deltaMean / lastEngineDelta), fps = 1000 / deltaMean || 0;\n                    var graphHeight = 4, gap = 12, width = 60, height = 34, x = 10, y = 69;\n                    // background\n                    context.fillStyle = \"#0e0f19\";\n                    context.fillRect(0, 50, gap * 5 + width * 6 + 22, height);\n                    // show FPS\n                    Render.status(context, x, y, width, graphHeight, deltaHistory.length, Math.round(fps) + \" fps\", fps / Render._goodFps, function(i) {\n                        return deltaHistory[i] / deltaMean - 1;\n                    });\n                    // show engine delta\n                    Render.status(context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length, lastEngineDelta.toFixed(2) + \" dt\", Render._goodDelta / lastEngineDelta, function(i) {\n                        return engineDeltaHistory[i] / engineDeltaMean - 1;\n                    });\n                    // show engine updates per frame\n                    Render.status(context, x + (gap + width) * 2, y, width, graphHeight, engineUpdatesHistory.length, lastEngineUpdatesPerFrame + \" upf\", Math.pow(Common.clamp(engineUpdatesMean / neededUpdatesPerFrame || 1, 0, 1), 4), function(i) {\n                        return engineUpdatesHistory[i] / engineUpdatesMean - 1;\n                    });\n                    // show engine update time\n                    Render.status(context, x + (gap + width) * 3, y, width, graphHeight, engineElapsedHistory.length, engineElapsedMean.toFixed(2) + \" ut\", 1 - lastEngineUpdatesPerFrame * engineElapsedMean / Render._goodFps, function(i) {\n                        return engineElapsedHistory[i] / engineElapsedMean - 1;\n                    });\n                    // show render time\n                    Render.status(context, x + (gap + width) * 4, y, width, graphHeight, elapsedHistory.length, elapsedMean.toFixed(2) + \" rt\", 1 - elapsedMean / Render._goodFps, function(i) {\n                        return elapsedHistory[i] / elapsedMean - 1;\n                    });\n                    // show effective speed\n                    Render.status(context, x + (gap + width) * 5, y, width, graphHeight, timestampElapsedHistory.length, rateMean.toFixed(2) + \" x\", rateMean * rateMean * rateMean, function(i) {\n                        return (timestampElapsedHistory[i] / deltaHistory[i] / rateMean || 0) - 1;\n                    });\n                };\n                /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */ Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n                    // background\n                    context.strokeStyle = \"#888\";\n                    context.fillStyle = \"#444\";\n                    context.lineWidth = 1;\n                    context.fillRect(x, y + 7, width, 1);\n                    // chart\n                    context.beginPath();\n                    context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n                    for(var i = 0; i < width; i += 1){\n                        context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n                    }\n                    context.stroke();\n                    // indicator\n                    context.fillStyle = \"hsl(\" + Common.clamp(25 + 95 * indicator, 0, 120) + \",100%,60%)\";\n                    context.fillRect(x, y - 7, 4, 4);\n                    // label\n                    context.font = \"12px Arial\";\n                    context.textBaseline = \"middle\";\n                    context.textAlign = \"right\";\n                    context.fillStyle = \"#eee\";\n                    context.fillText(label, x + width, y - 5);\n                };\n                /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */ Render.constraints = function(constraints, context) {\n                    var c = context;\n                    for(var i = 0; i < constraints.length; i++){\n                        var constraint = constraints[i];\n                        if (!constraint.render.visible || !constraint.pointA || !constraint.pointB) continue;\n                        var bodyA = constraint.bodyA, bodyB = constraint.bodyB, start, end;\n                        if (bodyA) {\n                            start = Vector.add(bodyA.position, constraint.pointA);\n                        } else {\n                            start = constraint.pointA;\n                        }\n                        if (constraint.render.type === \"pin\") {\n                            c.beginPath();\n                            c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                            c.closePath();\n                        } else {\n                            if (bodyB) {\n                                end = Vector.add(bodyB.position, constraint.pointB);\n                            } else {\n                                end = constraint.pointB;\n                            }\n                            c.beginPath();\n                            c.moveTo(start.x, start.y);\n                            if (constraint.render.type === \"spring\") {\n                                var delta = Vector.sub(end, start), normal = Vector.perp(Vector.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), offset;\n                                for(var j = 1; j < coils; j += 1){\n                                    offset = j % 2 === 0 ? 1 : -1;\n                                    c.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);\n                                }\n                            }\n                            c.lineTo(end.x, end.y);\n                        }\n                        if (constraint.render.lineWidth) {\n                            c.lineWidth = constraint.render.lineWidth;\n                            c.strokeStyle = constraint.render.strokeStyle;\n                            c.stroke();\n                        }\n                        if (constraint.render.anchors) {\n                            c.fillStyle = constraint.render.strokeStyle;\n                            c.beginPath();\n                            c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                            c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                            c.closePath();\n                            c.fill();\n                        }\n                    }\n                };\n                /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodies = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, showInternalEdges = options.showInternalEdges || !options.wireframes, body, part, i, k;\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            if (!part.render.visible) continue;\n                            if (options.showSleeping && body.isSleeping) {\n                                c.globalAlpha = 0.5 * part.render.opacity;\n                            } else if (part.render.opacity !== 1) {\n                                c.globalAlpha = part.render.opacity;\n                            }\n                            if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                                // part sprite\n                                var sprite = part.render.sprite, texture = _getTexture(render, sprite.texture);\n                                c.translate(part.position.x, part.position.y);\n                                c.rotate(part.angle);\n                                c.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);\n                                // revert translation, hopefully faster than save / restore\n                                c.rotate(-part.angle);\n                                c.translate(-part.position.x, -part.position.y);\n                            } else {\n                                // part polygon\n                                if (part.circleRadius) {\n                                    c.beginPath();\n                                    c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                                } else {\n                                    c.beginPath();\n                                    c.moveTo(part.vertices[0].x, part.vertices[0].y);\n                                    for(var j = 1; j < part.vertices.length; j++){\n                                        if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                            c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                                        } else {\n                                            c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                                        }\n                                        if (part.vertices[j].isInternal && !showInternalEdges) {\n                                            c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                                        }\n                                    }\n                                    c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                                    c.closePath();\n                                }\n                                if (!options.wireframes) {\n                                    c.fillStyle = part.render.fillStyle;\n                                    if (part.render.lineWidth) {\n                                        c.lineWidth = part.render.lineWidth;\n                                        c.strokeStyle = part.render.strokeStyle;\n                                        c.stroke();\n                                    }\n                                    c.fill();\n                                } else {\n                                    c.lineWidth = 1;\n                                    c.strokeStyle = render.options.wireframeStrokeStyle;\n                                    c.stroke();\n                                }\n                            }\n                            c.globalAlpha = 1;\n                        }\n                    }\n                };\n                /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyWireframes = function(render, bodies, context) {\n                    var c = context, showInternalEdges = render.options.showInternalEdges, body, part, i, j, k;\n                    c.beginPath();\n                    // render all bodies\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            c.moveTo(part.vertices[0].x, part.vertices[0].y);\n                            for(j = 1; j < part.vertices.length; j++){\n                                if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                    c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                                } else {\n                                    c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                                }\n                                if (part.vertices[j].isInternal && !showInternalEdges) {\n                                    c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                                }\n                            }\n                            c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        }\n                    }\n                    c.lineWidth = 1;\n                    c.strokeStyle = render.options.wireframeStrokeStyle;\n                    c.stroke();\n                };\n                /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyConvexHulls = function(render, bodies, context) {\n                    var c = context, body, part, i, j, k;\n                    c.beginPath();\n                    // render convex hulls\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible || body.parts.length === 1) continue;\n                        c.moveTo(body.vertices[0].x, body.vertices[0].y);\n                        for(j = 1; j < body.vertices.length; j++){\n                            c.lineTo(body.vertices[j].x, body.vertices[j].y);\n                        }\n                        c.lineTo(body.vertices[0].x, body.vertices[0].y);\n                    }\n                    c.lineWidth = 1;\n                    c.strokeStyle = \"rgba(255,255,255,0.2)\";\n                    c.stroke();\n                };\n                /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.vertexNumbers = function(render, bodies, context) {\n                    var c = context, i, j, k;\n                    for(i = 0; i < bodies.length; i++){\n                        var parts = bodies[i].parts;\n                        for(k = parts.length > 1 ? 1 : 0; k < parts.length; k++){\n                            var part = parts[k];\n                            for(j = 0; j < part.vertices.length; j++){\n                                c.fillStyle = \"rgba(255,255,255,0.2)\";\n                                c.fillText(i + \"_\" + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                            }\n                        }\n                    }\n                };\n                /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */ Render.mousePosition = function(render, mouse, context) {\n                    var c = context;\n                    c.fillStyle = \"rgba(255,255,255,0.8)\";\n                    c.fillText(mouse.position.x + \"  \" + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n                };\n                /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyBounds = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options;\n                    c.beginPath();\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (body.render.visible) {\n                            var parts = bodies[i].parts;\n                            for(var j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                var part = parts[j];\n                                c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                            }\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,255,255,0.08)\";\n                    } else {\n                        c.strokeStyle = \"rgba(0,0,0,0.1)\";\n                    }\n                    c.lineWidth = 1;\n                    c.stroke();\n                };\n                /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyAxes = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, part, i, j, k;\n                    c.beginPath();\n                    for(i = 0; i < bodies.length; i++){\n                        var body = bodies[i], parts = body.parts;\n                        if (!body.render.visible) continue;\n                        if (options.showAxes) {\n                            // render all axes\n                            for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                part = parts[j];\n                                for(k = 0; k < part.axes.length; k++){\n                                    var axis = part.axes[k];\n                                    c.moveTo(part.position.x, part.position.y);\n                                    c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                                }\n                            }\n                        } else {\n                            for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                part = parts[j];\n                                for(k = 0; k < part.axes.length; k++){\n                                    // render a single axis indicator\n                                    c.moveTo(part.position.x, part.position.y);\n                                    c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);\n                                }\n                            }\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"indianred\";\n                        c.lineWidth = 1;\n                    } else {\n                        c.strokeStyle = \"rgba(255, 255, 255, 0.4)\";\n                        c.globalCompositeOperation = \"overlay\";\n                        c.lineWidth = 2;\n                    }\n                    c.stroke();\n                    c.globalCompositeOperation = \"source-over\";\n                };\n                /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyPositions = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, body, part, i, k;\n                    c.beginPath();\n                    // render current positions\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                            c.closePath();\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.fillStyle = \"indianred\";\n                    } else {\n                        c.fillStyle = \"rgba(0,0,0,0.5)\";\n                    }\n                    c.fill();\n                    c.beginPath();\n                    // render previous positions\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (body.render.visible) {\n                            c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                            c.closePath();\n                        }\n                    }\n                    c.fillStyle = \"rgba(255,165,0,0.8)\";\n                    c.fill();\n                };\n                /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyVelocity = function(render, bodies, context) {\n                    var c = context;\n                    c.beginPath();\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (!body.render.visible) continue;\n                        var velocity = Body.getVelocity(body);\n                        c.moveTo(body.position.x, body.position.y);\n                        c.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);\n                    }\n                    c.lineWidth = 3;\n                    c.strokeStyle = \"cornflowerblue\";\n                    c.stroke();\n                };\n                /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyIds = function(render, bodies, context) {\n                    var c = context, i, j;\n                    for(i = 0; i < bodies.length; i++){\n                        if (!bodies[i].render.visible) continue;\n                        var parts = bodies[i].parts;\n                        for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                            var part = parts[j];\n                            c.font = \"12px Arial\";\n                            c.fillStyle = \"rgba(255,255,255,0.5)\";\n                            c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n                        }\n                    }\n                };\n                /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */ Render.collisions = function(render, pairs, context) {\n                    var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;\n                    c.beginPath();\n                    // render collision positions\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        for(j = 0; j < pair.contactCount; j++){\n                            var contact = pair.contacts[j], vertex = contact.vertex;\n                            c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.fillStyle = \"rgba(255,255,255,0.7)\";\n                    } else {\n                        c.fillStyle = \"orange\";\n                    }\n                    c.fill();\n                    c.beginPath();\n                    // render collision normals\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        if (pair.contactCount > 0) {\n                            var normalPosX = pair.contacts[0].vertex.x, normalPosY = pair.contacts[0].vertex.y;\n                            if (pair.contactCount === 2) {\n                                normalPosX = (pair.contacts[0].vertex.x + pair.contacts[1].vertex.x) / 2;\n                                normalPosY = (pair.contacts[0].vertex.y + pair.contacts[1].vertex.y) / 2;\n                            }\n                            if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                                c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                            } else {\n                                c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                            }\n                            c.lineTo(normalPosX, normalPosY);\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,165,0,0.7)\";\n                    } else {\n                        c.strokeStyle = \"orange\";\n                    }\n                    c.lineWidth = 1;\n                    c.stroke();\n                };\n                /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */ Render.separations = function(render, pairs, context) {\n                    var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;\n                    c.beginPath();\n                    // render separations\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        bodyA = collision.bodyA;\n                        bodyB = collision.bodyB;\n                        var k = 1;\n                        if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n                        if (bodyB.isStatic) k = 0;\n                        c.moveTo(bodyB.position.x, bodyB.position.y);\n                        c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n                        k = 1;\n                        if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n                        if (bodyA.isStatic) k = 0;\n                        c.moveTo(bodyA.position.x, bodyA.position.y);\n                        c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,165,0,0.5)\";\n                    } else {\n                        c.strokeStyle = \"orange\";\n                    }\n                    c.stroke();\n                };\n                /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */ Render.inspector = function(inspector, context) {\n                    var engine = inspector.engine, selected = inspector.selected, render = inspector.render, options = render.options, bounds;\n                    if (options.hasBounds) {\n                        var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;\n                        context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n                        context.translate(-render.bounds.min.x, -render.bounds.min.y);\n                    }\n                    for(var i = 0; i < selected.length; i++){\n                        var item = selected[i].data;\n                        context.translate(0.5, 0.5);\n                        context.lineWidth = 1;\n                        context.strokeStyle = \"rgba(255,165,0,0.9)\";\n                        context.setLineDash([\n                            1,\n                            2\n                        ]);\n                        switch(item.type){\n                            case \"body\":\n                                // render body selections\n                                bounds = item.bounds;\n                                context.beginPath();\n                                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                                context.closePath();\n                                context.stroke();\n                                break;\n                            case \"constraint\":\n                                // render constraint selections\n                                var point = item.pointA;\n                                if (item.bodyA) point = item.pointB;\n                                context.beginPath();\n                                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                                context.closePath();\n                                context.stroke();\n                                break;\n                        }\n                        context.setLineDash([]);\n                        context.translate(-0.5, -0.5);\n                    }\n                    // render selection region\n                    if (inspector.selectStart !== null) {\n                        context.translate(0.5, 0.5);\n                        context.lineWidth = 1;\n                        context.strokeStyle = \"rgba(255,165,0,0.6)\";\n                        context.fillStyle = \"rgba(255,165,0,0.1)\";\n                        bounds = inspector.selectBounds;\n                        context.beginPath();\n                        context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n                        context.closePath();\n                        context.stroke();\n                        context.fill();\n                        context.translate(-0.5, -0.5);\n                    }\n                    if (options.hasBounds) context.setTransform(1, 0, 0, 1, 0, 0);\n                };\n                /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */ var _updateTiming = function(render, time) {\n                    var engine = render.engine, timing = render.timing, historySize = timing.historySize, timestamp = engine.timing.timestamp;\n                    timing.delta = time - timing.lastTime || Render._goodDelta;\n                    timing.lastTime = time;\n                    timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n                    timing.lastTimestamp = timestamp;\n                    timing.deltaHistory.unshift(timing.delta);\n                    timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n                    timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n                    timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n                    timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n                    timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n                    timing.engineUpdatesHistory.unshift(engine.timing.lastUpdatesPerFrame);\n                    timing.engineUpdatesHistory.length = Math.min(timing.engineUpdatesHistory.length, historySize);\n                    timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n                    timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n                    timing.elapsedHistory.unshift(timing.lastElapsed);\n                    timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n                };\n                /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */ var _mean = function(values) {\n                    var result = 0;\n                    for(var i = 0; i < values.length; i += 1){\n                        result += values[i];\n                    }\n                    return result / values.length || 0;\n                };\n                /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */ var _createCanvas = function(width, height) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.width = width;\n                    canvas.height = height;\n                    canvas.oncontextmenu = function() {\n                        return false;\n                    };\n                    canvas.onselectstart = function() {\n                        return false;\n                    };\n                    return canvas;\n                };\n                /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */ var _getPixelRatio = function(canvas) {\n                    var context = canvas.getContext(\"2d\"), devicePixelRatio = window.devicePixelRatio || 1, backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n                    return devicePixelRatio / backingStorePixelRatio;\n                };\n                /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */ var _getTexture = function(render, imagePath) {\n                    var image = render.textures[imagePath];\n                    if (image) return image;\n                    image = render.textures[imagePath] = new Image();\n                    image.src = imagePath;\n                    return image;\n                };\n                /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */ var _applyBackground = function(render, background) {\n                    var cssBackground = background;\n                    if (/(jpg|gif|png)$/.test(background)) cssBackground = \"url(\" + background + \")\";\n                    render.canvas.style.background = cssBackground;\n                    render.canvas.style.backgroundSize = \"contain\";\n                    render.currentBackground = background;\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @deprecated\n     * @property controller\n     * @type render\n     */ /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */ /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */ /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */ /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */ /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */ /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */ /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */ /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */ /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */ /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */ /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */ /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */ /**\n     * A CSS color string to use for background when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */ /**\n     * A CSS color string to use for stroke when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeStrokeStyle\n     * @type string\n     * @default '#bbb'\n     */ /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average updates per frame (e.g. 1)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */ /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */ /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @deprecated no longer implemented\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */ })();\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_394213__) {\n            /**\n* The `Matter.Runner` module is an optional utility that provides a game loop for running a `Matter.Engine` inside a browser environment.\n* A runner will continuously update a `Matter.Engine` whilst synchronising engine updates with the browser frame rate.\n* This runner favours a smoother user experience over perfect time keeping.\n* This runner is optional and is used for development and debugging but could be useful as a starting point for implementing some games and experiences.\n* Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation as may be needed inside other environments.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/ var Runner = {};\n            module1.exports = Runner;\n            var Events = __nested_webpack_require_394213__(5);\n            var Engine = __nested_webpack_require_394213__(17);\n            var Common = __nested_webpack_require_394213__(0);\n            (function() {\n                Runner._maxFrameDelta = 1000 / 15;\n                Runner._frameDeltaFallback = 1000 / 60;\n                Runner._timeBufferMargin = 1.5;\n                Runner._elapsedNextEstimate = 1;\n                Runner._smoothingLowerBound = 0.1;\n                Runner._smoothingUpperBound = 0.9;\n                /**\n     * Creates a new Runner. \n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     */ Runner.create = function(options) {\n                    var defaults = {\n                        delta: 1000 / 60,\n                        frameDelta: null,\n                        frameDeltaSmoothing: true,\n                        frameDeltaSnapping: true,\n                        frameDeltaHistory: [],\n                        frameDeltaHistorySize: 100,\n                        frameRequestId: null,\n                        timeBuffer: 0,\n                        timeLastTick: null,\n                        maxUpdates: null,\n                        maxFrameTime: 1000 / 30,\n                        lastUpdatesDeferred: 0,\n                        enabled: true\n                    };\n                    var runner = Common.extend(defaults, options);\n                    // for temporary back compatibility only\n                    runner.fps = 0;\n                    return runner;\n                };\n                /**\n     * Runs a `Matter.Engine` whilst synchronising engine updates with the browser frame rate. \n     * See module and properties descriptions for more information on this runner.\n     * Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation.\n     * @method run\n     * @param {runner} runner\n     * @param {engine} [engine]\n     * @return {runner} runner\n     */ Runner.run = function(runner, engine) {\n                    // initial time buffer for the first frame\n                    runner.timeBuffer = Runner._frameDeltaFallback;\n                    (function onFrame(time) {\n                        runner.frameRequestId = Runner._onNextFrame(runner, onFrame);\n                        if (time && runner.enabled) {\n                            Runner.tick(runner, engine, time);\n                        }\n                    })();\n                    return runner;\n                };\n                /**\n     * Performs a single runner tick as used inside `Runner.run`.\n     * See module and properties descriptions for more information on this runner.\n     * Alternatively see `Engine.update` to step the engine directly inside your own game loop implementation.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */ Runner.tick = function(runner, engine, time) {\n                    var tickStartTime = Common.now(), engineDelta = runner.delta, updateCount = 0;\n                    // find frame delta time since last call\n                    var frameDelta = time - runner.timeLastTick;\n                    // fallback for unusable frame delta values (e.g. 0, NaN, on first frame or long pauses)\n                    if (!frameDelta || !runner.timeLastTick || frameDelta > Math.max(Runner._maxFrameDelta, runner.maxFrameTime)) {\n                        // reuse last accepted frame delta else fallback\n                        frameDelta = runner.frameDelta || Runner._frameDeltaFallback;\n                    }\n                    if (runner.frameDeltaSmoothing) {\n                        // record frame delta over a number of frames\n                        runner.frameDeltaHistory.push(frameDelta);\n                        runner.frameDeltaHistory = runner.frameDeltaHistory.slice(-runner.frameDeltaHistorySize);\n                        // sort frame delta history\n                        var deltaHistorySorted = runner.frameDeltaHistory.slice(0).sort();\n                        // sample a central window to limit outliers\n                        var deltaHistoryWindow = runner.frameDeltaHistory.slice(deltaHistorySorted.length * Runner._smoothingLowerBound, deltaHistorySorted.length * Runner._smoothingUpperBound);\n                        // take the mean of the central window\n                        var frameDeltaSmoothed = _mean(deltaHistoryWindow);\n                        frameDelta = frameDeltaSmoothed || frameDelta;\n                    }\n                    if (runner.frameDeltaSnapping) {\n                        // snap frame delta to the nearest 1 Hz\n                        frameDelta = 1000 / Math.round(1000 / frameDelta);\n                    }\n                    // update runner values for next call\n                    runner.frameDelta = frameDelta;\n                    runner.timeLastTick = time;\n                    // accumulate elapsed time\n                    runner.timeBuffer += runner.frameDelta;\n                    // limit time buffer size to a single frame of updates\n                    runner.timeBuffer = Common.clamp(runner.timeBuffer, 0, runner.frameDelta + engineDelta * Runner._timeBufferMargin);\n                    // reset count of over budget updates\n                    runner.lastUpdatesDeferred = 0;\n                    // get max updates per frame\n                    var maxUpdates = runner.maxUpdates || Math.ceil(runner.maxFrameTime / engineDelta);\n                    // create event object\n                    var event = {\n                        timestamp: engine.timing.timestamp\n                    };\n                    // tick events before update\n                    Events.trigger(runner, \"beforeTick\", event);\n                    Events.trigger(runner, \"tick\", event);\n                    var updateStartTime = Common.now();\n                    // simulate time elapsed between calls\n                    while(engineDelta > 0 && runner.timeBuffer >= engineDelta * Runner._timeBufferMargin){\n                        // update the engine\n                        Events.trigger(runner, \"beforeUpdate\", event);\n                        Engine.update(engine, engineDelta);\n                        Events.trigger(runner, \"afterUpdate\", event);\n                        // consume time simulated from buffer\n                        runner.timeBuffer -= engineDelta;\n                        updateCount += 1;\n                        // find elapsed time during this tick\n                        var elapsedTimeTotal = Common.now() - tickStartTime, elapsedTimeUpdates = Common.now() - updateStartTime, elapsedNextEstimate = elapsedTimeTotal + Runner._elapsedNextEstimate * elapsedTimeUpdates / updateCount;\n                        // defer updates if over performance budgets for this frame\n                        if (updateCount >= maxUpdates || elapsedNextEstimate > runner.maxFrameTime) {\n                            runner.lastUpdatesDeferred = Math.round(Math.max(0, runner.timeBuffer / engineDelta - Runner._timeBufferMargin));\n                            break;\n                        }\n                    }\n                    // track timing metrics\n                    engine.timing.lastUpdatesPerFrame = updateCount;\n                    // tick events after update\n                    Events.trigger(runner, \"afterTick\", event);\n                    // show useful warnings if needed\n                    if (runner.frameDeltaHistory.length >= 100) {\n                        if (runner.lastUpdatesDeferred && Math.round(runner.frameDelta / engineDelta) > maxUpdates) {\n                            Common.warnOnce(\"Matter.Runner: runner reached runner.maxUpdates, see docs.\");\n                        } else if (runner.lastUpdatesDeferred) {\n                            Common.warnOnce(\"Matter.Runner: runner reached runner.maxFrameTime, see docs.\");\n                        }\n                        if (typeof runner.isFixed !== \"undefined\") {\n                            Common.warnOnce(\"Matter.Runner: runner.isFixed is now redundant, see docs.\");\n                        }\n                        if (runner.deltaMin || runner.deltaMax) {\n                            Common.warnOnce(\"Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs.\");\n                        }\n                        if (runner.fps !== 0) {\n                            Common.warnOnce(\"Matter.Runner: runner.fps was replaced by runner.delta, see docs.\");\n                        }\n                    }\n                };\n                /**\n     * Ends execution of `Runner.run` on the given `runner` by canceling the frame loop.\n     * Alternatively to temporarily pause the runner, see `runner.enabled`.\n     * @method stop\n     * @param {runner} runner\n     */ Runner.stop = function(runner) {\n                    Runner._cancelNextFrame(runner);\n                };\n                /**\n     * Schedules the `callback` on this `runner` for the next animation frame.\n     * @private\n     * @method _onNextFrame\n     * @param {runner} runner\n     * @param {function} callback\n     * @return {number} frameRequestId\n     */ Runner._onNextFrame = function(runner, callback) {\n                    if ( true && window.requestAnimationFrame) {\n                        runner.frameRequestId = window.requestAnimationFrame(callback);\n                    } else {\n                        throw new Error(\"Matter.Runner: missing required global window.requestAnimationFrame.\");\n                    }\n                    return runner.frameRequestId;\n                };\n                /**\n     * Cancels the last callback scheduled by `Runner._onNextFrame` on this `runner`.\n     * @private\n     * @method _cancelNextFrame\n     * @param {runner} runner\n     */ Runner._cancelNextFrame = function(runner) {\n                    if ( true && window.cancelAnimationFrame) {\n                        window.cancelAnimationFrame(runner.frameRequestId);\n                    } else {\n                        throw new Error(\"Matter.Runner: missing required global window.cancelAnimationFrame.\");\n                    }\n                };\n                /**\n     * Returns the mean of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values.\n     */ var _mean = function(values) {\n                    var result = 0, valuesLength = values.length;\n                    for(var i = 0; i < valuesLength; i += 1){\n                        result += values[i];\n                    }\n                    return result / valuesLength || 0;\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired once at the start of the browser frame, before any engine updates.\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired once at the start of the browser frame, after `beforeTick`.\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired once at the end of the browser frame, after `beforeTick`, `tick` and after any engine updates.\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired before each and every engine update in this browser frame (if any). \n    * There may be multiple engine update calls per browser frame (or none) depending on framerate and timestep delta.\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired after each and every engine update in this browser frame (if any). \n    * There may be multiple engine update calls per browser frame (or none) depending on framerate and timestep delta.\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * The fixed timestep size used for `Engine.update` calls in milliseconds, known as `delta`.\n     * \n     * This value is recommended to be `1000 / 60` ms or smaller (i.e. equivalent to at least 60hz).\n     * \n     * Smaller `delta` values provide higher quality results at the cost of performance.\n     * \n     * You should usually avoid changing `delta` during running, otherwise quality may be affected. \n     * \n     * For smoother frame pacing choose a `delta` that is an even multiple of each display FPS you target, i.e. `1000 / (n * fps)` as this helps distribute an equal number of updates over each display frame.\n     * \n     * For example with a 60 Hz `delta` i.e. `1000 / 60` the runner will on average perform one update per frame on displays running 60 FPS and one update every two frames on displays running 120 FPS, etc.\n     * \n     * Where as e.g. using a 240 Hz `delta` i.e. `1000 / 240` the runner will on average perform four updates per frame on displays running 60 FPS and two updates per frame on displays running 120 FPS, etc.\n     * \n     * Therefore `Runner.run` will call multiple engine updates (or none) as needed to simulate the time elapsed between browser frames. \n     * \n     * In practice the number of updates in any particular frame may be restricted to respect the runner's performance budgets. These are specified by `runner.maxFrameTime` and `runner.maxUpdates`, see those properties for details.\n     * \n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */ /**\n     * A flag that can be toggled to enable or disable tick calls on this runner, therefore pausing engine updates and events while the runner loop remains running.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */ /**\n     * The accumulated time elapsed that has yet to be simulated in milliseconds.\n     * This value is clamped within certain limits (see `Runner.tick` code).\n     *\n     * @private\n     * @property timeBuffer\n     * @type number\n     * @default 0\n     */ /**\n     * The measured time elapsed between the last two browser frames measured in milliseconds.\n     * This is useful e.g. to estimate the current browser FPS using `1000 / runner.frameDelta`.\n     *\n     * @readonly\n     * @property frameDelta\n     * @type number\n     */ /**\n     * Enables averaging to smooth frame rate measurements and therefore stabilise play rate.\n     *\n     * @property frameDeltaSmoothing\n     * @type boolean\n     * @default true\n     */ /**\n     * Rounds measured browser frame delta to the nearest 1 Hz.\n     * This option can help smooth frame rate measurements and simplify handling hardware timing differences e.g. 59.94Hz and 60Hz displays.\n     * For best results you should also round your `runner.delta` equivalent to the nearest 1 Hz.\n     *\n     * @property frameDeltaSnapping\n     * @type boolean\n     * @default true\n     */ /**\n     * A performance budget that limits execution time allowed for this runner per browser frame in milliseconds.\n     * \n     * To calculate the effective browser FPS at which this throttle is applied use `1000 / runner.maxFrameTime`.\n     * \n     * This performance budget is intended to help maintain browser interactivity and help improve framerate recovery during temporary high CPU usage.\n     * \n     * This budget only covers the measured time elapsed executing the functions called in the scope of the runner tick, including `Engine.update` and its related user event callbacks.\n     * \n     * You may also reduce this budget to allow for any significant additional processing you perform on the same thread outside the scope of this runner tick, e.g. rendering time.\n     * \n     * See also `runner.maxUpdates`.\n     *\n     * @property maxFrameTime\n     * @type number\n     * @default 1000 / 30\n     */ /**\n     * An optional limit for maximum engine update count allowed per frame tick in addition to `runner.maxFrameTime`.\n     * \n     * Unless you set a value it is automatically chosen based on `runner.delta` and `runner.maxFrameTime`.\n     * \n     * See also `runner.maxFrameTime`.\n     * \n     * @property maxUpdates\n     * @type number\n     * @default null\n     */ /**\n     * The timestamp of the last call to `Runner.tick` used to measure `frameDelta`.\n     *\n     * @private\n     * @property timeLastTick\n     * @type number\n     * @default 0\n     */ /**\n     * The id of the last call to `Runner._onNextFrame`.\n     *\n     * @private\n     * @property frameRequestId\n     * @type number\n     * @default null\n     */ })();\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_412547__) {\n            /**\n* This module has now been replaced by `Matter.Collision`.\n*\n* All usage should be migrated to `Matter.Collision`.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n* @deprecated\n*/ var SAT = {};\n            module1.exports = SAT;\n            var Collision = __nested_webpack_require_412547__(8);\n            var Common = __nested_webpack_require_412547__(0);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @deprecated replaced by Collision.collides\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {collision} collision\n     */ SAT.collides = function(bodyA, bodyB) {\n                    return Collision.collides(bodyA, bodyB);\n                };\n                deprecated(SAT, \"collides\", \"SAT.collides ➤ replaced by Collision.collides\");\n            })();\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __nested_webpack_require_413752__) {\n            /**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/ var Svg = {};\n            module1.exports = Svg;\n            var Bounds = __nested_webpack_require_413752__(1);\n            var Common = __nested_webpack_require_413752__(0);\n            (function() {\n                /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */ Svg.pathToVertices = function(path, sampleLength) {\n                    if ( true && !(\"SVGPathSeg\" in window)) {\n                        Common.warn(\"Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.\");\n                    }\n                    // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n                    var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;\n                    sampleLength = sampleLength || 15;\n                    var addPoint = function(px, py, pathSegType) {\n                        // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n                        var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n                        // when the last point doesn't equal the current point add the current point\n                        if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                            if (lastPoint && isRelative) {\n                                lx = lastPoint.x;\n                                ly = lastPoint.y;\n                            } else {\n                                lx = 0;\n                                ly = 0;\n                            }\n                            var point = {\n                                x: lx + px,\n                                y: ly + py\n                            };\n                            // set last point\n                            if (isRelative || !lastPoint) {\n                                lastPoint = point;\n                            }\n                            points.push(point);\n                            x = lx + px;\n                            y = ly + py;\n                        }\n                    };\n                    var addSegmentPoint = function(segment) {\n                        var segType = segment.pathSegTypeAsLetter.toUpperCase();\n                        // skip path ends\n                        if (segType === \"Z\") return;\n                        // map segment to x and y\n                        switch(segType){\n                            case \"M\":\n                            case \"L\":\n                            case \"T\":\n                            case \"C\":\n                            case \"S\":\n                            case \"Q\":\n                                x = segment.x;\n                                y = segment.y;\n                                break;\n                            case \"H\":\n                                x = segment.x;\n                                break;\n                            case \"V\":\n                                y = segment.y;\n                                break;\n                        }\n                        addPoint(x, y, segment.pathSegType);\n                    };\n                    // ensure path is absolute\n                    Svg._svgPathToAbsolute(path);\n                    // get total length\n                    total = path.getTotalLength();\n                    // queue segments\n                    segments = [];\n                    for(i = 0; i < path.pathSegList.numberOfItems; i += 1)segments.push(path.pathSegList.getItem(i));\n                    segmentsQueue = segments.concat();\n                    // sample through path\n                    while(length < total){\n                        // get segment at position\n                        segmentIndex = path.getPathSegAtLength(length);\n                        segment = segments[segmentIndex];\n                        // new segment\n                        if (segment != lastSegment) {\n                            while(segmentsQueue.length && segmentsQueue[0] != segment)addSegmentPoint(segmentsQueue.shift());\n                            lastSegment = segment;\n                        }\n                        // add points in between when curving\n                        // TODO: adaptive sampling\n                        switch(segment.pathSegTypeAsLetter.toUpperCase()){\n                            case \"C\":\n                            case \"T\":\n                            case \"S\":\n                            case \"Q\":\n                            case \"A\":\n                                point = path.getPointAtLength(length);\n                                addPoint(point.x, point.y, 0);\n                                break;\n                        }\n                        // increment by sample value\n                        length += sampleLength;\n                    }\n                    // add remaining segments not passed by sampling\n                    for(i = 0, il = segmentsQueue.length; i < il; ++i)addSegmentPoint(segmentsQueue[i]);\n                    return points;\n                };\n                Svg._svgPathToAbsolute = function(path) {\n                    // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n                    // Copyright (c) Gavin Kistner\n                    // http://phrogz.net/js/_ReuseLicense.txt\n                    // Modifications: tidy formatting and naming\n                    var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;\n                    for(var i = 0; i < len; ++i){\n                        var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;\n                        if (/[MLHVCSQTA]/.test(segType)) {\n                            if (\"x\" in seg) x = seg.x;\n                            if (\"y\" in seg) y = seg.y;\n                        } else {\n                            if (\"x1\" in seg) x1 = x + seg.x1;\n                            if (\"x2\" in seg) x2 = x + seg.x2;\n                            if (\"y1\" in seg) y1 = y + seg.y1;\n                            if (\"y2\" in seg) y2 = y + seg.y2;\n                            if (\"x\" in seg) x += seg.x;\n                            if (\"y\" in seg) y += seg.y;\n                            switch(segType){\n                                case \"m\":\n                                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                                    break;\n                                case \"l\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                                    break;\n                                case \"h\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                                    break;\n                                case \"v\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                                    break;\n                                case \"c\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                                    break;\n                                case \"s\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                                    break;\n                                case \"q\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                                    break;\n                                case \"t\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                                    break;\n                                case \"a\":\n                                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                                    break;\n                                case \"z\":\n                                case \"Z\":\n                                    x = x0;\n                                    y = y0;\n                                    break;\n                            }\n                        }\n                        if (segType == \"M\" || segType == \"m\") {\n                            x0 = x;\n                            y0 = y;\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 30 */ /***/ function(module1, exports1, __nested_webpack_require_423153__) {\n            /**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/ var World = {};\n            module1.exports = World;\n            var Composite = __nested_webpack_require_423153__(6);\n            var Common = __nested_webpack_require_423153__(0);\n            (function() {\n                /**\n     * See above, aliases for back compatibility only\n     */ World.create = Composite.create;\n                World.add = Composite.add;\n                World.remove = Composite.remove;\n                World.clear = Composite.clear;\n                World.addComposite = Composite.addComposite;\n                World.addBody = Composite.addBody;\n                World.addConstraint = Composite.addConstraint;\n            })();\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXR0ZXItanMvYnVpbGQvbWF0dGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FDQSxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdEO1NBQ2IsRUFLdUJBO0FBQzdCLEdBQUcsUUFBTTtJQUNULE9BQWdCLE1BQUgsR0FBSSxTQUFTSyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQywrQkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDUCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNJLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVQsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtJLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNULFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFTSwrQkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS0wsUUFBT1EsQ0FBQyxHQUFHO1lBQ3RCLE1B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R0FBRyxHQUFJLFNBQVNwSixPQUFNLEVBQUVELFFBQU8sRUFBRU0saUNBQW1CO1lBRXBEOzs7Ozs7Ozs7Ozs7QUFZQSxHQUVBLElBQUkyd0IsUUFBUSxDQUFDO1lBRWJoeEIsUUFBT0QsT0FBTyxHQUFHaXhCO1lBRWpCLElBQUk3WixZQUFZOVcsaUNBQW1CQSxDQUFDO1lBQ3BDLElBQUltQyxTQUFTbkMsaUNBQW1CQSxDQUFDO1lBRWhDO2dCQUVHOztLQUVDLEdBQ0Qyd0IsTUFBTXB2QixNQUFNLEdBQUd1VixVQUFVdlYsTUFBTTtnQkFDL0JvdkIsTUFBTTNsQixHQUFHLEdBQUc4TCxVQUFVOUwsR0FBRztnQkFDekIybEIsTUFBTTFZLE1BQU0sR0FBR25CLFVBQVVtQixNQUFNO2dCQUMvQjBZLE1BQU0vWCxLQUFLLEdBQUc5QixVQUFVOEIsS0FBSztnQkFDN0IrWCxNQUFNNVksWUFBWSxHQUFHakIsVUFBVWlCLFlBQVk7Z0JBQzNDNFksTUFBTTlZLE9BQU8sR0FBR2YsVUFBVWUsT0FBTztnQkFDakM4WSxNQUFNN1ksYUFBYSxHQUFHaEIsVUFBVWdCLGFBQWE7WUFFakQ7UUFHQSxHQUFHLEdBQUc7S0FDSTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXR0ZXItanMvYnVpbGQvbWF0dGVyLmpzPzg0NGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtYXR0ZXItanMgMC4yMC4wIGJ5IEBsaWFicnVcbiAqIGh0dHA6Ly9icm0uaW8vbWF0dGVyLWpzL1xuICogTGljZW5zZSBNSVRcbiAqIFxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgTGlhbSBCcnVtbWl0dCBhbmQgY29udHJpYnV0b3JzLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiTWF0dGVyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIk1hdHRlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJNYXR0ZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkNvbW1vbmAgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgYXJlIGNvbW1vbiB0byBhbGwgbW9kdWxlcy5cbipcbiogQGNsYXNzIENvbW1vblxuKi9cblxudmFyIENvbW1vbiA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1vbjtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgQ29tbW9uLl9iYXNlRGVsdGEgPSAxMDAwIC8gNjA7XG4gICAgQ29tbW9uLl9uZXh0SWQgPSAwO1xuICAgIENvbW1vbi5fc2VlZCA9IDA7XG4gICAgQ29tbW9uLl9ub3dTdGFydFRpbWUgPSArKG5ldyBEYXRlKCkpO1xuICAgIENvbW1vbi5fd2FybmVkT25jZSA9IHt9O1xuICAgIENvbW1vbi5fZGVjb21wID0gbnVsbDtcbiAgICBcbiAgICAvKipcbiAgICAgKiBFeHRlbmRzIHRoZSBvYmplY3QgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IHVzaW5nIHRoZSBvYmplY3QgaW4gdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXBcbiAgICAgKiBAcmV0dXJuIHt9IG9iaiBleHRlbmRlZFxuICAgICAqL1xuICAgIENvbW1vbi5leHRlbmQgPSBmdW5jdGlvbihvYmosIGRlZXApIHtcbiAgICAgICAgdmFyIGFyZ3NTdGFydCxcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBkZWVwQ2xvbmU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWVwID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGFyZ3NTdGFydCA9IDI7XG4gICAgICAgICAgICBkZWVwQ2xvbmUgPSBkZWVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnc1N0YXJ0ID0gMTtcbiAgICAgICAgICAgIGRlZXBDbG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gYXJnc1N0YXJ0OyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXBDbG9uZSAmJiBzb3VyY2VbcHJvcF0gJiYgc291cmNlW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2JqW3Byb3BdIHx8IG9ialtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gb2JqW3Byb3BdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi5leHRlbmQob2JqW3Byb3BdLCBkZWVwQ2xvbmUsIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbG9uZSBvZiB0aGUgb2JqZWN0LCBpZiBkZWVwIGlzIHRydWUgcmVmZXJlbmNlcyB3aWxsIGFsc28gYmUgY2xvbmVkLlxuICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgKiBAcGFyYW0ge30gb2JqXG4gICAgICogQHBhcmFtIHtib29sfSBkZWVwXG4gICAgICogQHJldHVybiB7fSBvYmogY2xvbmVkXG4gICAgICovXG4gICAgQ29tbW9uLmNsb25lID0gZnVuY3Rpb24ob2JqLCBkZWVwKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHt9LCBkZWVwLCBvYmopO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgZm9yIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBrZXlzXG4gICAgICogQHBhcmFtIHt9IG9ialxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBrZXlzXG4gICAgICovXG4gICAgQ29tbW9uLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICAgICAgLy8gYXZvaWQgaGFzT3duUHJvcGVydHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopXG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgdmFsdWVzXG4gICAgICogQHBhcmFtIHt9IG9ialxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB0aGUgb2JqZWN0cyBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKi9cbiAgICBDb21tb24udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGF2b2lkIGhhc093blByb3BlcnR5IGZvciBwZXJmb3JtYW5jZVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2gob2JqW2tleV0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdmFsdWUgZnJvbSBgYmFzZWAgcmVsYXRpdmUgdG8gdGhlIGBwYXRoYCBzdHJpbmcuXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0ge30gb2JqIFRoZSBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYCwgZS5nLiAnRm9vLkJhci5iYXonXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbl0gUGF0aCBzbGljZSBiZWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSBQYXRoIHNsaWNlIGVuZFxuICAgICAqIEByZXR1cm4ge30gVGhlIG9iamVjdCBhdCB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqL1xuICAgIENvbW1vbi5nZXQgPSBmdW5jdGlvbihvYmosIHBhdGgsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKS5zbGljZShiZWdpbiwgZW5kKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBvbiBgYmFzZWAgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIGBwYXRoYCBzdHJpbmcuXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge30gb2JqIFRoZSBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYCwgZS5nLiAnRm9vLkJhci5iYXonXG4gICAgICogQHBhcmFtIHt9IHZhbCBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbl0gUGF0aCBzbGljZSBiZWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSBQYXRoIHNsaWNlIGVuZFxuICAgICAqIEByZXR1cm4ge30gUGFzcyB0aHJvdWdoIGB2YWxgIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIENvbW1vbi5zZXQgPSBmdW5jdGlvbihvYmosIHBhdGgsIHZhbCwgYmVnaW4sIGVuZCkge1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgICAgIENvbW1vbi5nZXQob2JqLCBwYXRoLCAwLCAtMSlbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaHVmZmxlcyB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2UuXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cbiAgICAgKiBAbWV0aG9kIHNodWZmbGVcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBzaHVmZmxlZCByYW5kb21seVxuICAgICAqL1xuICAgIENvbW1vbi5zaHVmZmxlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihDb21tb24ucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XG4gICAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICAgICAgYXJyYXlbal0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmFuZG9tbHkgY2hvb3NlcyBhIHZhbHVlIGZyb20gYSBsaXN0IHdpdGggZXF1YWwgcHJvYmFiaWxpdHkuXG4gICAgICogVGhlIGZ1bmN0aW9uIHVzZXMgYSBzZWVkZWQgcmFuZG9tIGdlbmVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGNob29zZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGNob2ljZXNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmFuZG9tIGNob2ljZSBvYmplY3QgZnJvbSB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBDb21tb24uY2hvb3NlID0gZnVuY3Rpb24oY2hvaWNlcykge1xuICAgICAgICByZXR1cm4gY2hvaWNlc1tNYXRoLmZsb29yKENvbW1vbi5yYW5kb20oKSAqIGNob2ljZXMubGVuZ3RoKV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKiBAbWV0aG9kIGlzRWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQ29tbW9uLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgJiYgb2JqLm5vZGVOYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXkuXG4gICAgICogQG1ldGhvZCBpc0FycmF5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQ29tbW9uLmlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqIEBtZXRob2QgaXNGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQ29tbW9uLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBwbGFpbiBvYmplY3QuXG4gICAgICogQG1ldGhvZCBpc1BsYWluT2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHBsYWluIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQ29tbW9uLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHN0cmluZy5cbiAgICAgKiBAbWV0aG9kIGlzU3RyaW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQ29tbW9uLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgY2xhbXBlZCBiZXR3ZWVuIGEgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAbWV0aG9kIGNsYW1wXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBjbGFtcGVkIGJldHdlZW4gbWluIGFuZCBtYXggaW5jbHVzaXZlXG4gICAgICovXG4gICAgQ29tbW9uLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbilcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heClcbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBtZXRob2Qgc2lnblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLTEgaWYgbmVnYXRpdmUsICsxIGlmIDAgb3IgcG9zaXRpdmVcbiAgICAgKi9cbiAgICBDb21tb24uc2lnbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWVzdGFtcCBzaW5jZSB0aGUgdGltZSBvcmlnaW4gKGUuZy4gZnJvbSBwYWdlIGxvYWQpLlxuICAgICAqIFRoZSByZXN1bHQgaXMgaW4gbWlsbGlzZWNvbmRzIGFuZCB3aWxsIHVzZSBoaWdoLXJlc29sdXRpb24gdGltaW5nIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIG5vd1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIENvbW1vbi5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cucGVyZm9ybWFuY2Uud2Via2l0Tm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS53ZWJraXROb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChEYXRlLm5vdykge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCkpIC0gQ29tbW9uLl9ub3dTdGFydFRpbWU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIHZhbHVlIGJldHdlZW4gYSBtaW5pbXVtIGFuZCBhIG1heGltdW0gdmFsdWUgaW5jbHVzaXZlLlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXG4gICAgICogQG1ldGhvZCByYW5kb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXggaW5jbHVzaXZlXG4gICAgICovXG4gICAgQ29tbW9uLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICAgIG1pbiA9ICh0eXBlb2YgbWluICE9PSBcInVuZGVmaW5lZFwiKSA/IG1pbiA6IDA7XG4gICAgICAgIG1heCA9ICh0eXBlb2YgbWF4ICE9PSBcInVuZGVmaW5lZFwiKSA/IG1heCA6IDE7XG4gICAgICAgIHJldHVybiBtaW4gKyBfc2VlZGVkUmFuZG9tKCkgKiAobWF4IC0gbWluKTtcbiAgICB9O1xuXG4gICAgdmFyIF9zZWVkZWRSYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2NvbmdydWVudGlhbF9nZW5lcmF0b3JcbiAgICAgICAgQ29tbW9uLl9zZWVkID0gKENvbW1vbi5fc2VlZCAqIDkzMDEgKyA0OTI5NykgJSAyMzMyODA7XG4gICAgICAgIHJldHVybiBDb21tb24uX3NlZWQgLyAyMzMyODA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQ1NTIGhleCBjb2xvdXIgc3RyaW5nIGludG8gYW4gaW50ZWdlci5cbiAgICAgKiBAbWV0aG9kIGNvbG9yVG9OdW1iZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBDU1MgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIENvbW1vbi5jb2xvclRvTnVtYmVyID0gZnVuY3Rpb24oY29sb3JTdHJpbmcpIHtcbiAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5yZXBsYWNlKCcjJywnJyk7XG5cbiAgICAgICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLmNoYXJBdCgwKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvclN0cmluZy5jaGFyQXQoMSkgKyBjb2xvclN0cmluZy5jaGFyQXQoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDIpICsgY29sb3JTdHJpbmcuY2hhckF0KDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zb2xlIGxvZ2dpbmcgbGV2ZWwgdG8gdXNlLCB3aGVyZSBlYWNoIGxldmVsIGluY2x1ZGVzIGFsbCBsZXZlbHMgYWJvdmUgYW5kIGV4Y2x1ZGVzIHRoZSBsZXZlbHMgYmVsb3cuXG4gICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgaXMgJ2RlYnVnJyB3aGljaCBzaG93cyBhbGwgY29uc29sZSBtZXNzYWdlcy4gIFxuICAgICAqXG4gICAgICogUG9zc2libGUgbGV2ZWwgdmFsdWVzIGFyZTpcbiAgICAgKiAtIDAgPSBOb25lXG4gICAgICogLSAxID0gRGVidWdcbiAgICAgKiAtIDIgPSBJbmZvXG4gICAgICogLSAzID0gV2FyblxuICAgICAqIC0gNCA9IEVycm9yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcm9wZXJ0eSBsb2dMZXZlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIENvbW1vbi5sb2dMZXZlbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmxvZ2AgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxuICAgICAqIEBtZXRob2QgbG9nXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIGBjb25zb2xlLmluZm9gIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cbiAgICAgKiBAbWV0aG9kIGluZm9cbiAgICAgKiBAcGFyYW0gLi4ub2JqcyB7fSBUaGUgb2JqZWN0cyB0byBsb2cuXG4gICAgICovXG4gICAgQ29tbW9uLmluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgJiYgQ29tbW9uLmxvZ0xldmVsID4gMCAmJiBDb21tb24ubG9nTGV2ZWwgPD0gMikge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBgY29uc29sZS53YXJuYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXG4gICAgICogQG1ldGhvZCB3YXJuXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi53YXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZXMgYENvbW1vbi53YXJuYCB0byBsb2cgdGhlIGdpdmVuIG1lc3NhZ2Ugb25lIHRpbWUgb25seS5cbiAgICAgKiBAbWV0aG9kIHdhcm5PbmNlXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi53YXJuT25jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpO1xuXG4gICAgICAgIGlmICghQ29tbW9uLl93YXJuZWRPbmNlW21lc3NhZ2VdKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIENvbW1vbi5fd2FybmVkT25jZVttZXNzYWdlXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBkZXByZWNhdGVkIGNvbnNvbGUgd2FybmluZyB3aGVuIHRoZSBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGNhbGxlZC5cbiAgICAgKiBUaGUgdGFyZ2V0IGZ1bmN0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIG5ldyBmdW5jdGlvbiB0aGF0IGZpcnN0IHNob3dzIHRoZSB3YXJuaW5nXG4gICAgICogYW5kIHRoZW4gY2FsbHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICAgICAqIEBtZXRob2QgZGVwcmVjYXRlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBtb2R1bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgZnVuY3Rpb24gb24gb2JqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhcm5pbmcgVGhlIG9uZS10aW1lIG1lc3NhZ2UgdG8gc2hvdyBpZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgICovXG4gICAgQ29tbW9uLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihvYmosIHByb3AsIHdhcm5pbmcpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gQ29tbW9uLmNoYWluKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm5PbmNlKCfwn5SFIGRlcHJlY2F0ZWQg8J+UhScsIHdhcm5pbmcpO1xuICAgICAgICB9LCBvYmpbcHJvcF0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBzZXF1ZW50aWFsIElELlxuICAgICAqIEBtZXRob2QgbmV4dElkXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBVbmlxdWUgc2VxdWVudGlhbCBJRFxuICAgICAqL1xuICAgIENvbW1vbi5uZXh0SWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIENvbW1vbi5fbmV4dElkKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgY3Jvc3MgYnJvd3NlciBjb21wYXRpYmxlIGluZGV4T2YgaW1wbGVtZW50YXRpb24uXG4gICAgICogQG1ldGhvZCBpbmRleE9mXG4gICAgICogQHBhcmFtIHthcnJheX0gaGF5c3RhY2tcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmVlZGxlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgbmVlZGxlIGluIGhheXN0YWNrLCBvdGhlcndpc2UgLTEuXG4gICAgICovXG4gICAgQ29tbW9uLmluZGV4T2YgPSBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgICAgIGlmIChoYXlzdGFjay5pbmRleE9mKVxuICAgICAgICAgICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGF5c3RhY2tbaV0gPT09IG5lZWRsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBjcm9zcyBicm93c2VyIGNvbXBhdGlibGUgYXJyYXkgbWFwIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBtZXRob2QgbWFwXG4gICAgICogQHBhcmFtIHthcnJheX0gbGlzdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gVmFsdWVzIGZyb20gbGlzdCB0cmFuc2Zvcm1lZCBieSBmdW5jLlxuICAgICAqL1xuICAgIENvbW1vbi5tYXAgPSBmdW5jdGlvbihsaXN0LCBmdW5jKSB7XG4gICAgICAgIGlmIChsaXN0Lm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QubWFwKGZ1bmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbWFwcGVkLnB1c2goZnVuYyhsaXN0W2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGRpcmVjdGVkIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBwYXJ0aWFsbHkgb3JkZXJlZCBzZXQgb2YgdmVydGljZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXG4gICAgICogQ2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFyZSBhbGxvd2VkLlxuICAgICAqIEBtZXRob2QgdG9wb2xvZ2ljYWxTb3J0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gICAgICogQHJldHVybiB7YXJyYXl9IFBhcnRpYWxseSBvcmRlcmVkIHNldCBvZiB2ZXJ0aWNlcyBpbiB0b3BvbG9naWNhbCBvcmRlci5cbiAgICAgKi9cbiAgICBDb21tb24udG9wb2xvZ2ljYWxTb3J0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21nZWNoZXYvamF2YXNjcmlwdC1hbGdvcml0aG1zXG4gICAgICAgIC8vIENvcHlyaWdodCAoYykgTWlua28gR2VjaGV2IChNSVQgbGljZW5zZSlcbiAgICAgICAgLy8gTW9kaWZpY2F0aW9uczogdGlkeSBmb3JtYXR0aW5nIGFuZCBuYW1pbmdcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdmlzaXRlZCA9IFtdLFxuICAgICAgICAgICAgdGVtcCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGUgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtub2RlXSAmJiAhdGVtcFtub2RlXSkge1xuICAgICAgICAgICAgICAgIENvbW1vbi5fdG9wb2xvZ2ljYWxTb3J0KG5vZGUsIHZpc2l0ZWQsIHRlbXAsIGdyYXBoLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29tbW9uLl90b3BvbG9naWNhbFNvcnQgPSBmdW5jdGlvbihub2RlLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaFtub2RlXSB8fCBbXTtcbiAgICAgICAgdGVtcFtub2RlXSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKHRlbXBbbmVpZ2hib3JdKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW25laWdoYm9yXSkge1xuICAgICAgICAgICAgICAgIENvbW1vbi5fdG9wb2xvZ2ljYWxTb3J0KG5laWdoYm9yLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBbbm9kZV0gPSBmYWxzZTtcbiAgICAgICAgdmlzaXRlZFtub2RlXSA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIF9uXyBmdW5jdGlvbnMgYXMgYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlbSBpbiBvcmRlci5cbiAgICAgKiBUaGUgYXJndW1lbnRzIGFwcGxpZWQgd2hlbiBjYWxsaW5nIHRoZSBuZXcgZnVuY3Rpb24gd2lsbCBhbHNvIGJlIGFwcGxpZWQgdG8gZXZlcnkgZnVuY3Rpb24gcGFzc2VkLlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcmVmZXJzIHRvIHRoZSBsYXN0IHZhbHVlIHJldHVybmVkIGluIHRoZSBjaGFpbiB0aGF0IHdhcyBub3QgYHVuZGVmaW5lZGAuXG4gICAgICogVGhlcmVmb3JlIGlmIGEgcGFzc2VkIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLCB0aGUgcHJldmlvdXNseSByZXR1cm5lZCB2YWx1ZSBpcyBtYWludGFpbmVkLlxuICAgICAqIEFmdGVyIGFsbCBwYXNzZWQgZnVuY3Rpb25zIGhhdmUgYmVlbiBjYWxsZWQgdGhlIG5ldyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXN0IHJldHVybmVkIHZhbHVlIChpZiBhbnkpLlxuICAgICAqIElmIGFueSBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9ucyBhcmUgYSBjaGFpbiwgdGhlbiB0aGUgY2hhaW4gd2lsbCBiZSBmbGF0dGVuZWQuXG4gICAgICogQG1ldGhvZCBjaGFpblxuICAgICAqIEBwYXJhbSAuLi5mdW5jcyB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbnMgdG8gY2hhaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHBhc3NlZCBmdW5jdGlvbnMgaW4gb3JkZXIuXG4gICAgICovXG4gICAgQ29tbW9uLmNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmdW5jcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKGZ1bmMuX2NoYWluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBmbGF0dGVuIGFscmVhZHkgY2hhaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBmdW5jcy5wdXNoLmFwcGx5KGZ1bmNzLCBmdW5jLl9jaGFpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnVuY3MucHVzaChmdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9kZXZ0b29scy1kb2NzL2lzc3Vlcy81MyNpc3N1ZWNvbW1lbnQtNTE5NDEzNThcbiAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0LFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jc1tpXS5hcHBseShsYXN0UmVzdWx0LCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2hhaW4uX2NoYWluZWQgPSBmdW5jcztcblxuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBiZWZvcmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYGJhc2VgLlxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxuICAgICAqIEBtZXRob2QgY2hhaW5QYXRoQmVmb3JlXG4gICAgICogQHBhcmFtIHt9IGJhc2UgVGhlIGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYmVmb3JlIHRoZSBvcmlnaW5hbFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxuICAgICAqL1xuICAgIENvbW1vbi5jaGFpblBhdGhCZWZvcmUgPSBmdW5jdGlvbihiYXNlLCBwYXRoLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uc2V0KGJhc2UsIHBhdGgsIENvbW1vbi5jaGFpbihcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICBDb21tb24uZ2V0KGJhc2UsIHBhdGgpXG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYWZ0ZXIgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYGJhc2VgLlxuICAgICAqIFNlZSBhbHNvIGRvY3MgZm9yIGBDb21tb24uY2hhaW5gLlxuICAgICAqIEBtZXRob2QgY2hhaW5QYXRoQWZ0ZXJcbiAgICAgKiBAcGFyYW0ge30gYmFzZSBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBhZnRlciB0aGUgb3JpZ2luYWxcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcbiAgICAgKi9cbiAgICBDb21tb24uY2hhaW5QYXRoQWZ0ZXIgPSBmdW5jdGlvbihiYXNlLCBwYXRoLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uc2V0KGJhc2UsIHBhdGgsIENvbW1vbi5jaGFpbihcbiAgICAgICAgICAgIENvbW1vbi5nZXQoYmFzZSwgcGF0aCksXG4gICAgICAgICAgICBmdW5jXG4gICAgICAgICkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIHRoZSBbcG9seS1kZWNvbXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wb2x5LWRlY29tcC5qcykgbGlicmFyeSBtb2R1bGUgdG8gZW5hYmxlXG4gICAgICogY29uY2F2ZSB2ZXJ0ZXggZGVjb21wb3NpdGlvbiBzdXBwb3J0IHdoZW4gdXNpbmcgYEJvZGllcy5mcm9tVmVydGljZXNgIGUuZy4gYENvbW1vbi5zZXREZWNvbXAocmVxdWlyZSgncG9seS1kZWNvbXAnKSlgLlxuICAgICAqIEBtZXRob2Qgc2V0RGVjb21wXG4gICAgICogQHBhcmFtIHt9IGRlY29tcCBUaGUgW3BvbHktZGVjb21wXShodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcG9seS1kZWNvbXAuanMpIGxpYnJhcnkgbW9kdWxlLlxuICAgICAqL1xuICAgIENvbW1vbi5zZXREZWNvbXAgPSBmdW5jdGlvbihkZWNvbXApIHtcbiAgICAgICAgQ29tbW9uLl9kZWNvbXAgPSBkZWNvbXA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFtwb2x5LWRlY29tcF0oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBsaWJyYXJ5IG1vZHVsZSBwcm92aWRlZCB0aHJvdWdoIGBDb21tb24uc2V0RGVjb21wYCxcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyB0aGUgZ2xvYmFsIGBkZWNvbXBgIGlmIHNldC5cbiAgICAgKiBAbWV0aG9kIGdldERlY29tcFxuICAgICAqIEByZXR1cm4ge30gVGhlIFtwb2x5LWRlY29tcF0oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBsaWJyYXJ5IG1vZHVsZSBpZiBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBDb21tb24uZ2V0RGVjb21wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGdldCB1c2VyIHByb3ZpZGVkIGRlY29tcCBpZiBzZXRcbiAgICAgICAgdmFyIGRlY29tcCA9IENvbW1vbi5fZGVjb21wO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZnJvbSB3aW5kb3cgZ2xvYmFsXG4gICAgICAgICAgICBpZiAoIWRlY29tcCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRlY29tcCA9IHdpbmRvdy5kZWNvbXA7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZnJvbSBub2RlIGdsb2JhbFxuICAgICAgICAgICAgaWYgKCFkZWNvbXAgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXAgPSBnbG9iYWwuZGVjb21wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBkZWNvbXAgbm90IGF2YWlsYWJsZVxuICAgICAgICAgICAgZGVjb21wID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWNvbXA7XG4gICAgfTtcbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Cb3VuZHNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyAoQUFCQikuXG4qXG4qIEBjbGFzcyBCb3VuZHNcbiovXG5cbnZhciBCb3VuZHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHM7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgZm9yIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7Ym91bmRzfSBBIG5ldyBib3VuZHMgb2JqZWN0XG4gICAgICovXG4gICAgQm91bmRzLmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBib3VuZHMgPSB7IFxuICAgICAgICAgICAgbWluOiB7IHg6IDAsIHk6IDAgfSwgXG4gICAgICAgICAgICBtYXg6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZlcnRpY2VzKVxuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShib3VuZHMsIHZlcnRpY2VzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYm91bmRzIHVzaW5nIHRoZSBnaXZlbiB2ZXJ0aWNlcyBhbmQgZXh0ZW5kcyB0aGUgYm91bmRzIGdpdmVuIGEgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb3VuZHMudXBkYXRlID0gZnVuY3Rpb24oYm91bmRzLCB2ZXJ0aWNlcywgdmVsb2NpdHkpIHtcbiAgICAgICAgYm91bmRzLm1pbi54ID0gSW5maW5pdHk7XG4gICAgICAgIGJvdW5kcy5tYXgueCA9IC1JbmZpbml0eTtcbiAgICAgICAgYm91bmRzLm1pbi55ID0gSW5maW5pdHk7XG4gICAgICAgIGJvdW5kcy5tYXgueSA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPiBib3VuZHMubWF4LngpIGJvdW5kcy5tYXgueCA9IHZlcnRleC54O1xuICAgICAgICAgICAgaWYgKHZlcnRleC54IDwgYm91bmRzLm1pbi54KSBib3VuZHMubWluLnggPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueSA+IGJvdW5kcy5tYXgueSkgYm91bmRzLm1heC55ID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPCBib3VuZHMubWluLnkpIGJvdW5kcy5taW4ueSA9IHZlcnRleC55O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodmVsb2NpdHkpIHtcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eS54ID4gMCkge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueCArPSB2ZWxvY2l0eS54O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLnggKz0gdmVsb2NpdHkueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLm1heC55ICs9IHZlbG9jaXR5Lnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueSArPSB2ZWxvY2l0eS55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRzIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJvdW5kcyBjb250YWluIHRoZSBwb2ludCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQm91bmRzLmNvbnRhaW5zID0gZnVuY3Rpb24oYm91bmRzLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBib3VuZHMubWluLnggJiYgcG9pbnQueCA8PSBib3VuZHMubWF4LnggXG4gICAgICAgICAgICAgICAmJiBwb2ludC55ID49IGJvdW5kcy5taW4ueSAmJiBwb2ludC55IDw9IGJvdW5kcy5tYXgueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYm91bmRzIGludGVyc2VjdC5cbiAgICAgKiBAbWV0aG9kIG92ZXJsYXBzXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc0FcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzQlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJvdW5kcyBvdmVybGFwLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgKi9cbiAgICBCb3VuZHMub3ZlcmxhcHMgPSBmdW5jdGlvbihib3VuZHNBLCBib3VuZHNCKSB7XG4gICAgICAgIHJldHVybiAoYm91bmRzQS5taW4ueCA8PSBib3VuZHNCLm1heC54ICYmIGJvdW5kc0EubWF4LnggPj0gYm91bmRzQi5taW4ueFxuICAgICAgICAgICAgICAgICYmIGJvdW5kc0EubWF4LnkgPj0gYm91bmRzQi5taW4ueSAmJiBib3VuZHNBLm1pbi55IDw9IGJvdW5kc0IubWF4LnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBib3VuZHMgYnkgdGhlIGdpdmVuIHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICovXG4gICAgQm91bmRzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGJvdW5kcywgdmVjdG9yKSB7XG4gICAgICAgIGJvdW5kcy5taW4ueCArPSB2ZWN0b3IueDtcbiAgICAgICAgYm91bmRzLm1heC54ICs9IHZlY3Rvci54O1xuICAgICAgICBib3VuZHMubWluLnkgKz0gdmVjdG9yLnk7XG4gICAgICAgIGJvdW5kcy5tYXgueSArPSB2ZWN0b3IueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoZSBib3VuZHMgdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2Qgc2hpZnRcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQm91bmRzLnNoaWZ0ID0gZnVuY3Rpb24oYm91bmRzLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZGVsdGFYID0gYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgZGVsdGFZID0gYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55O1xuICAgICAgICAgICAgXG4gICAgICAgIGJvdW5kcy5taW4ueCA9IHBvc2l0aW9uLng7XG4gICAgICAgIGJvdW5kcy5tYXgueCA9IHBvc2l0aW9uLnggKyBkZWx0YVg7XG4gICAgICAgIGJvdW5kcy5taW4ueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIGJvdW5kcy5tYXgueSA9IHBvc2l0aW9uLnkgKyBkZWx0YVk7XG4gICAgfTtcbiAgICBcbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5WZWN0b3JgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHZlY3RvcnMuXG4qIFZlY3RvcnMgYXJlIHRoZSBiYXNpcyBvZiBhbGwgdGhlIGdlb21ldHJ5IHJlbGF0ZWQgb3BlcmF0aW9ucyBpbiB0aGUgZW5naW5lLlxuKiBBIGBNYXR0ZXIuVmVjdG9yYCBvYmplY3QgaXMgb2YgdGhlIGZvcm0gYHsgeDogMCwgeTogMCB9YC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFZlY3RvclxuKi9cblxuLy8gVE9ETzogY29uc2lkZXIgcGFyYW1zIGZvciByZXVzaW5nIHZlY3RvciBvYmplY3RzXG5cbnZhciBWZWN0b3IgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3I7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yXG4gICAgICovXG4gICAgVmVjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogeCB8fCAwLCB5OiB5IHx8IDAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCBgeGAgYW5kIGB5YCBjb3BpZWQgZnJvbSB0aGUgZ2l2ZW4gYHZlY3RvcmAuXG4gICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IGNsb25lZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IuY2xvbmUgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLngsIHk6IHZlY3Rvci55IH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hZ25pdHVkZSAobGVuZ3RoKSBvZiBhIHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIG1hZ25pdHVkZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5tYWduaXR1ZGUgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgodmVjdG9yLnggKiB2ZWN0b3IueCkgKyAodmVjdG9yLnkgKiB2ZWN0b3IueSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgYSB2ZWN0b3IgKHRoZXJlZm9yZSBzYXZpbmcgYSBgc3FydGAgb3BlcmF0aW9uKS5cbiAgICAgKiBAbWV0aG9kIG1hZ25pdHVkZVNxdWFyZWRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yLnggKiB2ZWN0b3IueCkgKyAodmVjdG9yLnkgKiB2ZWN0b3IueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCAoMCwgMCkgYnkgc3BlY2lmaWVkIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbb3V0cHV0XVxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gVGhlIHZlY3RvciByb3RhdGVkIGFib3V0ICgwLCAwKVxuICAgICAqL1xuICAgIFZlY3Rvci5yb3RhdGUgPSBmdW5jdGlvbih2ZWN0b3IsIGFuZ2xlLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSwgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIHZhciB4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbjtcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3IueCAqIHNpbiArIHZlY3Rvci55ICogY29zO1xuICAgICAgICBvdXRwdXQueCA9IHg7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCBhIHNwZWNpZmllZCBwb2ludCBieSBzcGVjaWZpZWQgYW5nbGUuXG4gICAgICogQG1ldGhvZCByb3RhdGVBYm91dFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciByb3RhdGVkIGFib3V0IHRoZSBwb2ludFxuICAgICAqL1xuICAgIFZlY3Rvci5yb3RhdGVBYm91dCA9IGZ1bmN0aW9uKHZlY3RvciwgYW5nbGUsIHBvaW50LCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSwgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIHZhciB4ID0gcG9pbnQueCArICgodmVjdG9yLnggLSBwb2ludC54KSAqIGNvcyAtICh2ZWN0b3IueSAtIHBvaW50LnkpICogc2luKTtcbiAgICAgICAgb3V0cHV0LnkgPSBwb2ludC55ICsgKCh2ZWN0b3IueCAtIHBvaW50LngpICogc2luICsgKHZlY3Rvci55IC0gcG9pbnQueSkgKiBjb3MpO1xuICAgICAgICBvdXRwdXQueCA9IHg7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGlzZXMgYSB2ZWN0b3IgKHN1Y2ggdGhhdCBpdHMgbWFnbml0dWRlIGlzIGAxYCkuXG4gICAgICogQG1ldGhvZCBub3JtYWxpc2VcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igbm9ybWFsaXNlZFxuICAgICAqL1xuICAgIFZlY3Rvci5ub3JtYWxpc2UgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IFZlY3Rvci5tYWduaXR1ZGUodmVjdG9yKTtcbiAgICAgICAgaWYgKG1hZ25pdHVkZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggLyBtYWduaXR1ZGUsIHk6IHZlY3Rvci55IC8gbWFnbml0dWRlIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdC1wcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgZG90XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSB0d28gdmVjdG9yc1xuICAgICAqL1xuICAgIFZlY3Rvci5kb3QgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yQS54ICogdmVjdG9yQi54KSArICh2ZWN0b3JBLnkgKiB2ZWN0b3JCLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3NcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdHdvIHZlY3RvcnNcbiAgICAgKi9cbiAgICBWZWN0b3IuY3Jvc3MgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yQS54ICogdmVjdG9yQi55KSAtICh2ZWN0b3JBLnkgKiB2ZWN0b3JCLngpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjcm9zcy1wcm9kdWN0IG9mIHRocmVlIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBjcm9zczNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB0aHJlZSB2ZWN0b3JzXG4gICAgICovXG4gICAgVmVjdG9yLmNyb3NzMyA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIHZlY3RvckMpIHtcbiAgICAgICAgcmV0dXJuICh2ZWN0b3JCLnggLSB2ZWN0b3JBLngpICogKHZlY3RvckMueSAtIHZlY3RvckEueSkgLSAodmVjdG9yQi55IC0gdmVjdG9yQS55KSAqICh2ZWN0b3JDLnggLSB2ZWN0b3JBLngpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBvZiB2ZWN0b3JBIGFuZCB2ZWN0b3JCIGFkZGVkXG4gICAgICovXG4gICAgVmVjdG9yLmFkZCA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIG91dHB1dCkge1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIG91dHB1dC54ID0gdmVjdG9yQS54ICsgdmVjdG9yQi54O1xuICAgICAgICBvdXRwdXQueSA9IHZlY3RvckEueSArIHZlY3RvckIueTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIHN1YlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBvZiB2ZWN0b3JBIGFuZCB2ZWN0b3JCIHN1YnRyYWN0ZWRcbiAgICAgKi9cbiAgICBWZWN0b3Iuc3ViID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQiwgb3V0cHV0KSB7XG4gICAgICAgIGlmICghb3V0cHV0KSBvdXRwdXQgPSB7fTtcbiAgICAgICAgb3V0cHV0LnggPSB2ZWN0b3JBLnggLSB2ZWN0b3JCLng7XG4gICAgICAgIG91dHB1dC55ID0gdmVjdG9yQS55IC0gdmVjdG9yQi55O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGFuZCBhIHNjYWxhci5cbiAgICAgKiBAbWV0aG9kIG11bHRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIG11bHRpcGxpZWQgYnkgc2NhbGFyXG4gICAgICovXG4gICAgVmVjdG9yLm11bHQgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCAqIHNjYWxhciwgeTogdmVjdG9yLnkgKiBzY2FsYXIgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBhIHZlY3RvciBhbmQgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBkaXZcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIGRpdmlkZWQgYnkgc2NhbGFyXG4gICAgICovXG4gICAgVmVjdG9yLmRpdiA9IGZ1bmN0aW9uKHZlY3Rvciwgc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gc2NhbGFyLCB5OiB2ZWN0b3IueSAvIHNjYWxhciB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZXJwZW5kaWN1bGFyIHZlY3Rvci4gU2V0IGBuZWdhdGVgIHRvIHRydWUgZm9yIHRoZSBwZXJwZW5kaWN1bGFyIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogQG1ldGhvZCBwZXJwXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW25lZ2F0ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5wZXJwID0gZnVuY3Rpb24odmVjdG9yLCBuZWdhdGUpIHtcbiAgICAgICAgbmVnYXRlID0gbmVnYXRlID09PSB0cnVlID8gLTEgOiAxO1xuICAgICAgICByZXR1cm4geyB4OiBuZWdhdGUgKiAtdmVjdG9yLnksIHk6IG5lZ2F0ZSAqIHZlY3Rvci54IH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgYm90aCBjb21wb25lbnRzIG9mIGEgdmVjdG9yIHN1Y2ggdGhhdCBpdCBwb2ludHMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAgKiBAbWV0aG9kIG5lZ1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBuZWdhdGVkIHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5uZWcgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogLXZlY3Rvci54LCB5OiAtdmVjdG9yLnkgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGB2ZWN0b3JCIC0gdmVjdG9yQWAgYW5kIHRoZSB4LWF4aXMgaW4gcmFkaWFucy5cbiAgICAgKiBAbWV0aG9kIGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBWZWN0b3IuYW5nbGUgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHZlY3RvckIueSAtIHZlY3RvckEueSwgdmVjdG9yQi54IC0gdmVjdG9yQS54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJ5IHZlY3RvciBwb29sIChub3QgdGhyZWFkLXNhZmUpLlxuICAgICAqIEBwcm9wZXJ0eSBfdGVtcFxuICAgICAqIEB0eXBlIHt2ZWN0b3JbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZlY3Rvci5fdGVtcCA9IFtcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKCksIFxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKSwgXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpXG4gICAgXTtcblxufSkoKTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5WZXJ0aWNlc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgc2V0cyBvZiB2ZXJ0aWNlcy5cbiogQSBzZXQgb2YgdmVydGljZXMgaXMgYW4gYXJyYXkgb2YgYE1hdHRlci5WZWN0b3JgIHdpdGggYWRkaXRpb25hbCBpbmRleGluZyBwcm9wZXJ0aWVzIGluc2VydGVkIGJ5IGBWZXJ0aWNlcy5jcmVhdGVgLlxuKiBBIGBNYXR0ZXIuQm9keWAgbWFpbnRhaW5zIGEgc2V0IG9mIHZlcnRpY2VzIHRvIHJlcHJlc2VudCB0aGUgc2hhcGUgb2YgdGhlIG9iamVjdCAoaXRzIGNvbnZleCBodWxsKS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFZlcnRpY2VzXG4qL1xuXG52YXIgVmVydGljZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZXJ0aWNlcztcblxudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzZXQgb2YgYE1hdHRlci5Cb2R5YCBjb21wYXRpYmxlIHZlcnRpY2VzLlxuICAgICAqIFRoZSBgcG9pbnRzYCBhcmd1bWVudCBhY2NlcHRzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgb3JpZW50YXRlZCBhcm91bmQgdGhlIG9yaWdpbiBgKDAsIDApYCwgZm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgW3sgeDogMCwgeTogMCB9LCB7IHg6IDI1LCB5OiA1MCB9LCB7IHg6IDUwLCB5OiAwIH1dXG4gICAgICpcbiAgICAgKiBUaGUgYFZlcnRpY2VzLmNyZWF0ZWAgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkgb2YgdmVydGljZXMsIHdoaWNoIGFyZSBzaW1pbGFyIHRvIE1hdHRlci5WZWN0b3Igb2JqZWN0cyxcbiAgICAgKiBidXQgd2l0aCBzb21lIGFkZGl0aW9uYWwgcmVmZXJlbmNlcyByZXF1aXJlZCBmb3IgZWZmaWNpZW50IGNvbGxpc2lvbiBkZXRlY3Rpb24gcm91dGluZXMuXG4gICAgICpcbiAgICAgKiBWZXJ0aWNlcyBtdXN0IGJlIHNwZWNpZmllZCBpbiBjbG9ja3dpc2Ugb3JkZXIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIGBib2R5YCBhcmd1bWVudCBpcyBub3Qgb3B0aW9uYWwsIGEgYE1hdHRlci5Cb2R5YCByZWZlcmVuY2UgbXVzdCBiZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3JbXX0gcG9pbnRzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICovXG4gICAgVmVydGljZXMuY3JlYXRlID0gZnVuY3Rpb24ocG9pbnRzLCBib2R5KSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV0sXG4gICAgICAgICAgICAgICAgdmVydGV4ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgaXNJbnRlcm5hbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0cmluZyBjb250YWluaW5nIG9yZGVyZWQgeCB5IHBhaXJzIHNlcGFyYXRlZCBieSBzcGFjZXMgKGFuZCBvcHRpb25hbGx5IGNvbW1hcyksIFxuICAgICAqIGludG8gYSBgTWF0dGVyLlZlcnRpY2VzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBgTWF0dGVyLkJvZHlgLlxuICAgICAqIEZvciBwYXJzaW5nIFNWRyBwYXRocywgc2VlIGBTdmcucGF0aFRvVmVydGljZXNgLlxuICAgICAqIEBtZXRob2QgZnJvbVBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIFZlcnRpY2VzLmZyb21QYXRoID0gZnVuY3Rpb24ocGF0aCwgYm9keSkge1xuICAgICAgICB2YXIgcGF0aFBhdHRlcm4gPSAvTD9cXHMqKFstXFxkLmVdKylbXFxzLF0qKFstXFxkLmVdKykqL2lnLFxuICAgICAgICAgICAgcG9pbnRzID0gW107XG5cbiAgICAgICAgcGF0aC5yZXBsYWNlKHBhdGhQYXR0ZXJuLCBmdW5jdGlvbihtYXRjaCwgeCwgeSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeyB4OiBwYXJzZUZsb2F0KHgpLCB5OiBwYXJzZUZsb2F0KHkpIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gVmVydGljZXMuY3JlYXRlKHBvaW50cywgYm9keSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNlbnRyZSAoY2VudHJvaWQpIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBjZW50cmVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gVGhlIGNlbnRyZSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNlbnRyZSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBhcmVhID0gVmVydGljZXMuYXJlYSh2ZXJ0aWNlcywgdHJ1ZSksXG4gICAgICAgICAgICBjZW50cmUgPSB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGNyb3NzLFxuICAgICAgICAgICAgdGVtcCxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaiA9IChpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjcm9zcyA9IFZlY3Rvci5jcm9zcyh2ZXJ0aWNlc1tpXSwgdmVydGljZXNbal0pO1xuICAgICAgICAgICAgdGVtcCA9IFZlY3Rvci5tdWx0KFZlY3Rvci5hZGQodmVydGljZXNbaV0sIHZlcnRpY2VzW2pdKSwgY3Jvc3MpO1xuICAgICAgICAgICAgY2VudHJlID0gVmVjdG9yLmFkZChjZW50cmUsIHRlbXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFZlY3Rvci5kaXYoY2VudHJlLCA2ICogYXJlYSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgKG1lYW4pIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBtZWFuXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBhdmVyYWdlIHBvaW50XG4gICAgICovXG4gICAgVmVydGljZXMubWVhbiA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBhdmVyYWdlID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXZlcmFnZS54ICs9IHZlcnRpY2VzW2ldLng7XG4gICAgICAgICAgICBhdmVyYWdlLnkgKz0gdmVydGljZXNbaV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBWZWN0b3IuZGl2KGF2ZXJhZ2UsIHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFyZWEgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGFyZWFcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gc2lnbmVkXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYXJlYVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmFyZWEgPSBmdW5jdGlvbih2ZXJ0aWNlcywgc2lnbmVkKSB7XG4gICAgICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgICAgIGogPSB2ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgKz0gKHZlcnRpY2VzW2pdLnggLSB2ZXJ0aWNlc1tpXS54KSAqICh2ZXJ0aWNlc1tqXS55ICsgdmVydGljZXNbaV0ueSk7XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gYXJlYSAvIDI7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFyZWEpIC8gMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgKHNlY29uZCBtb21lbnQgb2YgYXJlYSkgb2YgdGhlIHNldCBvZiB2ZXJ0aWNlcyBnaXZlbiB0aGUgdG90YWwgbWFzcy5cbiAgICAgKiBAbWV0aG9kIGluZXJ0aWFcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9seWdvbidzIG1vbWVudCBvZiBpbmVydGlhXG4gICAgICovXG4gICAgVmVydGljZXMuaW5lcnRpYSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBtYXNzKSB7XG4gICAgICAgIHZhciBudW1lcmF0b3IgPSAwLFxuICAgICAgICAgICAgZGVub21pbmF0b3IgPSAwLFxuICAgICAgICAgICAgdiA9IHZlcnRpY2VzLFxuICAgICAgICAgICAgY3Jvc3MsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvbHlnb24ncyBtb21lbnQgb2YgaW5lcnRpYSwgdXNpbmcgc2Vjb25kIG1vbWVudCBvZiBhcmVhXG4gICAgICAgIC8vIGZyb20gZXF1YXRpb25zIGF0IGh0dHA6Ly93d3cucGh5c2ljc2ZvcnVtcy5jb20vc2hvd3RocmVhZC5waHA/dD0yNTI5M1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHYubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGogPSAobiArIDEpICUgdi5sZW5ndGg7XG4gICAgICAgICAgICBjcm9zcyA9IE1hdGguYWJzKFZlY3Rvci5jcm9zcyh2W2pdLCB2W25dKSk7XG4gICAgICAgICAgICBudW1lcmF0b3IgKz0gY3Jvc3MgKiAoVmVjdG9yLmRvdCh2W2pdLCB2W2pdKSArIFZlY3Rvci5kb3QodltqXSwgdltuXSkgKyBWZWN0b3IuZG90KHZbbl0sIHZbbl0pKTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IGNyb3NzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChtYXNzIC8gNikgKiAobnVtZXJhdG9yIC8gZGVub21pbmF0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBzZXQgb2YgdmVydGljZXMgaW4tcGxhY2UuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyXG4gICAgICovXG4gICAgVmVydGljZXMudHJhbnNsYXRlID0gZnVuY3Rpb24odmVydGljZXMsIHZlY3Rvciwgc2NhbGFyKSB7XG4gICAgICAgIHNjYWxhciA9IHR5cGVvZiBzY2FsYXIgIT09ICd1bmRlZmluZWQnID8gc2NhbGFyIDogMTtcblxuICAgICAgICB2YXIgdmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gdmVjdG9yLnggKiBzY2FsYXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVZID0gdmVjdG9yLnkgKiBzY2FsYXIsXG4gICAgICAgICAgICBpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnggKz0gdHJhbnNsYXRlWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgKz0gdHJhbnNsYXRlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgc2V0IG9mIHZlcnRpY2VzIGluLXBsYWNlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5yb3RhdGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgYW5nbGUsIHBvaW50KSB7XG4gICAgICAgIGlmIChhbmdsZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgcG9pbnRYID0gcG9pbnQueCxcbiAgICAgICAgICAgIHBvaW50WSA9IHBvaW50LnksXG4gICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgZHksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGR4ID0gdmVydGV4LnggLSBwb2ludFg7XG4gICAgICAgICAgICBkeSA9IHZlcnRleC55IC0gcG9pbnRZO1xuICAgICAgICAgICAgdmVydGV4LnggPSBwb2ludFggKyAoZHggKiBjb3MgLSBkeSAqIHNpbik7XG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHBvaW50WSArIChkeCAqIHNpbiArIGR5ICogY29zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBwb2ludGAgaXMgaW5zaWRlIHRoZSBzZXQgb2YgYHZlcnRpY2VzYC5cbiAgICAgKiBAbWV0aG9kIGNvbnRhaW5zXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2ZXJ0aWNlcyBjb250YWlucyBwb2ludCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgVmVydGljZXMuY29udGFpbnMgPSBmdW5jdGlvbih2ZXJ0aWNlcywgcG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50WCA9IHBvaW50LngsXG4gICAgICAgICAgICBwb2ludFkgPSBwb2ludC55LFxuICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1t2ZXJ0aWNlc0xlbmd0aCAtIDFdLFxuICAgICAgICAgICAgbmV4dFZlcnRleDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5leHRWZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgaWYgKChwb2ludFggLSB2ZXJ0ZXgueCkgKiAobmV4dFZlcnRleC55IC0gdmVydGV4LnkpIFxuICAgICAgICAgICAgICAgICsgKHBvaW50WSAtIHZlcnRleC55KSAqICh2ZXJ0ZXgueCAtIG5leHRWZXJ0ZXgueCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJ0ZXggPSBuZXh0VmVydGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgdmVydGljZXMgZnJvbSBhIHBvaW50IChkZWZhdWx0IGlzIGNlbnRyZSkgaW4tcGxhY2UuXG4gICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5zY2FsZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQpIHtcbiAgICAgICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XG5cbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCBWZXJ0aWNlcy5jZW50cmUodmVydGljZXMpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXgsXG4gICAgICAgICAgICBkZWx0YTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGRlbHRhID0gVmVjdG9yLnN1Yih2ZXJ0ZXgsIHBvaW50KTtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnggPSBwb2ludC54ICsgZGVsdGEueCAqIHNjYWxlWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIHNjYWxlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbWZlcnMgYSBzZXQgb2YgdmVydGljZXMgYnkgZ2l2aW5nIHRoZW0gcm91bmRlZCBjb3JuZXJzLCByZXR1cm5zIGEgbmV3IHNldCBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBUaGUgcmFkaXVzIHBhcmFtZXRlciBpcyBhIHNpbmdsZSBudW1iZXIgb3IgYW4gYXJyYXkgdG8gc3BlY2lmeSB0aGUgcmFkaXVzIGZvciBlYWNoIHZlcnRleC5cbiAgICAgKiBAbWV0aG9kIGNoYW1mZXJcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlNaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eU1heFxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNoYW1mZXIgPSBmdW5jdGlvbih2ZXJ0aWNlcywgcmFkaXVzLCBxdWFsaXR5LCBxdWFsaXR5TWluLCBxdWFsaXR5TWF4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmFkaXVzID0gW3JhZGl1c107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgWzhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhbGl0eSBkZWZhdWx0cyB0byAtMSwgd2hpY2ggaXMgYXV0b1xuICAgICAgICBxdWFsaXR5ID0gKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykgPyBxdWFsaXR5IDogLTE7XG4gICAgICAgIHF1YWxpdHlNaW4gPSBxdWFsaXR5TWluIHx8IDI7XG4gICAgICAgIHF1YWxpdHlNYXggPSBxdWFsaXR5TWF4IHx8IDE0O1xuXG4gICAgICAgIHZhciBuZXdWZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmVydGV4ID0gdmVydGljZXNbaSAtIDEgPj0gMCA/IGkgLSAxIDogdmVydGljZXMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV0sXG4gICAgICAgICAgICAgICAgbmV4dFZlcnRleCA9IHZlcnRpY2VzWyhpICsgMSkgJSB2ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYWRpdXMgPSByYWRpdXNbaSA8IHJhZGl1cy5sZW5ndGggPyBpIDogcmFkaXVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld1ZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByZXZOb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXG4gICAgICAgICAgICAgICAgeDogdmVydGV4LnkgLSBwcmV2VmVydGV4LnksIFxuICAgICAgICAgICAgICAgIHk6IHByZXZWZXJ0ZXgueCAtIHZlcnRleC54XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG5leHROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKHsgXG4gICAgICAgICAgICAgICAgeDogbmV4dFZlcnRleC55IC0gdmVydGV4LnksIFxuICAgICAgICAgICAgICAgIHk6IHZlcnRleC54IC0gbmV4dFZlcnRleC54XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsUmFkaXVzID0gTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyhjdXJyZW50UmFkaXVzLCAyKSksXG4gICAgICAgICAgICAgICAgcmFkaXVzVmVjdG9yID0gVmVjdG9yLm11bHQoQ29tbW9uLmNsb25lKHByZXZOb3JtYWwpLCBjdXJyZW50UmFkaXVzKSxcbiAgICAgICAgICAgICAgICBtaWROb3JtYWwgPSBWZWN0b3Iubm9ybWFsaXNlKFZlY3Rvci5tdWx0KFZlY3Rvci5hZGQocHJldk5vcm1hbCwgbmV4dE5vcm1hbCksIDAuNSkpLFxuICAgICAgICAgICAgICAgIHNjYWxlZFZlcnRleCA9IFZlY3Rvci5zdWIodmVydGV4LCBWZWN0b3IubXVsdChtaWROb3JtYWwsIGRpYWdvbmFsUmFkaXVzKSk7XG5cbiAgICAgICAgICAgIHZhciBwcmVjaXNpb24gPSBxdWFsaXR5O1xuXG4gICAgICAgICAgICBpZiAocXVhbGl0eSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlY2lkZSBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBNYXRoLnBvdyhjdXJyZW50UmFkaXVzLCAwLjMyKSAqIDEuNzU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZWNpc2lvbiA9IENvbW1vbi5jbGFtcChwcmVjaXNpb24sIHF1YWxpdHlNaW4sIHF1YWxpdHlNYXgpO1xuXG4gICAgICAgICAgICAvLyB1c2UgYW4gZXZlbiB2YWx1ZSBmb3IgcHJlY2lzaW9uLCBtb3JlIGxpa2VseSB0byByZWR1Y2UgYXhlcyBieSB1c2luZyBzeW1tZXRyeVxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAlIDIgPT09IDEpXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uICs9IDE7XG5cbiAgICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGguYWNvcyhWZWN0b3IuZG90KHByZXZOb3JtYWwsIG5leHROb3JtYWwpKSxcbiAgICAgICAgICAgICAgICB0aGV0YSA9IGFscGhhIC8gcHJlY2lzaW9uO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByZWNpc2lvbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3VmVydGljZXMucHVzaChWZWN0b3IuYWRkKFZlY3Rvci5yb3RhdGUocmFkaXVzVmVjdG9yLCB0aGV0YSAqIGopLCBzY2FsZWRWZXJ0ZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdWZXJ0aWNlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGlucHV0IHZlcnRpY2VzIGludG8gY2xvY2t3aXNlIG9yZGVyIGluIHBsYWNlLlxuICAgICAqIEBtZXRob2QgY2xvY2t3aXNlU29ydFxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICovXG4gICAgVmVydGljZXMuY2xvY2t3aXNlU29ydCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBjZW50cmUgPSBWZXJ0aWNlcy5tZWFuKHZlcnRpY2VzKTtcblxuICAgICAgICB2ZXJ0aWNlcy5zb3J0KGZ1bmN0aW9uKHZlcnRleEEsIHZlcnRleEIpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuYW5nbGUoY2VudHJlLCB2ZXJ0ZXhBKSAtIFZlY3Rvci5hbmdsZShjZW50cmUsIHZlcnRleEIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmVydGljZXMgZm9ybSBhIGNvbnZleCBzaGFwZSAodmVydGljZXMgbXVzdCBiZSBpbiBjbG9ja3dpc2Ugb3JkZXIpLlxuICAgICAqIEBtZXRob2QgaXNDb252ZXhcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge2Jvb2x9IGB0cnVlYCBpZiB0aGUgYHZlcnRpY2VzYCBhcmUgY29udmV4LCBgZmFsc2VgIGlmIG5vdCAob3IgYG51bGxgIGlmIG5vdCBjb21wdXRhYmxlKS5cbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5pc0NvbnZleCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9nZW9tZXRyeS9wb2x5Z29ubWVzaC9cbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSBQYXVsIEJvdXJrZSAodXNlIHBlcm1pdHRlZClcblxuICAgICAgICB2YXIgZmxhZyA9IDAsXG4gICAgICAgICAgICBuID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgejtcblxuICAgICAgICBpZiAobiA8IDMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBqID0gKGkgKyAxKSAlIG47XG4gICAgICAgICAgICBrID0gKGkgKyAyKSAlIG47XG4gICAgICAgICAgICB6ID0gKHZlcnRpY2VzW2pdLnggLSB2ZXJ0aWNlc1tpXS54KSAqICh2ZXJ0aWNlc1trXS55IC0gdmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICB6IC09ICh2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSkgKiAodmVydGljZXNba10ueCAtIHZlcnRpY2VzW2pdLngpO1xuXG4gICAgICAgICAgICBpZiAoeiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFnIHw9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHogPiAwKSB7XG4gICAgICAgICAgICAgICAgZmxhZyB8PSAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhZyA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFnICE9PSAwKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udmV4IGh1bGwgb2YgdGhlIGlucHV0IHZlcnRpY2VzIGFzIGEgbmV3IGFycmF5IG9mIHBvaW50cy5cbiAgICAgKiBAbWV0aG9kIGh1bGxcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4gW3ZlcnRleF0gdmVydGljZXNcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5odWxsID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMTAtX2h1bGwtMS5odG1sXG5cbiAgICAgICAgdmFyIHVwcGVyID0gW10sXG4gICAgICAgICAgICBsb3dlciA9IFtdLCBcbiAgICAgICAgICAgIHZlcnRleCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gc29ydCB2ZXJ0aWNlcyBvbiB4LWF4aXMgKHktYXhpcyBmb3IgdGllcylcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5zbGljZSgwKTtcbiAgICAgICAgdmVydGljZXMuc29ydChmdW5jdGlvbih2ZXJ0ZXhBLCB2ZXJ0ZXhCKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB2ZXJ0ZXhBLnggLSB2ZXJ0ZXhCLng7XG4gICAgICAgICAgICByZXR1cm4gZHggIT09IDAgPyBkeCA6IHZlcnRleEEueSAtIHZlcnRleEIueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYnVpbGQgbG93ZXIgaHVsbFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgXG4gICAgICAgICAgICAgICAgICAgJiYgVmVjdG9yLmNyb3NzMyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHZlcnRleCkgPD0gMCkge1xuICAgICAgICAgICAgICAgIGxvd2VyLnBvcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb3dlci5wdXNoKHZlcnRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBidWlsZCB1cHBlciBodWxsXG4gICAgICAgIGZvciAoaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyIFxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcbiAgICAgICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBwZXIucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uY2F0ZW5hdGlvbiBvZiB0aGUgbG93ZXIgYW5kIHVwcGVyIGh1bGxzIGdpdmVzIHRoZSBjb252ZXggaHVsbFxuICAgICAgICAvLyBvbWl0IGxhc3QgcG9pbnRzIGJlY2F1c2UgdGhleSBhcmUgcmVwZWF0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgb3RoZXIgbGlzdFxuICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgbG93ZXIucG9wKCk7XG5cbiAgICAgICAgcmV0dXJuIHVwcGVyLmNvbmNhdChsb3dlcik7XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHJpZ2lkIGJvZGllcy5cbiogRm9yIGNyZWF0aW5nIGJvZGllcyB3aXRoIGNvbW1vbiBjb25maWd1cmF0aW9ucyBzdWNoIGFzIHJlY3RhbmdsZXMsIGNpcmNsZXMgYW5kIG90aGVyIHBvbHlnb25zIHNlZSB0aGUgbW9kdWxlIGBNYXR0ZXIuQm9kaWVzYC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cblxuKiBAY2xhc3MgQm9keVxuKi9cblxudmFyIEJvZHkgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG52YXIgVmVydGljZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgU2xlZXBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBeGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIEJvZHkuX3RpbWVDb3JyZWN0aW9uID0gdHJ1ZTtcbiAgICBCb2R5Ll9pbmVydGlhU2NhbGUgPSA0O1xuICAgIEJvZHkuX25leHRDb2xsaWRpbmdHcm91cElkID0gMTtcbiAgICBCb2R5Ll9uZXh0Tm9uQ29sbGlkaW5nR3JvdXBJZCA9IC0xO1xuICAgIEJvZHkuX25leHRDYXRlZ29yeSA9IDB4MDAwMTtcbiAgICBCb2R5Ll9iYXNlRGVsdGEgPSAxMDAwIC8gNjA7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogVmVydGljZXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gY2xvY2t3aXNlIG9yZGVyLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge2JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICBCb2R5LmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgaWQ6IENvbW1vbi5uZXh0SWQoKSxcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGxhYmVsOiAnQm9keScsXG4gICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICBwbHVnaW46IHt9LFxuICAgICAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgoJ0wgMCAwIEwgNDAgMCBMIDQwIDQwIEwgMCA0MCcpLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgZm9yY2U6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdG9ycXVlOiAwLFxuICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRJbXB1bHNlOiB7IHg6IDAsIHk6IDAsIGFuZ2xlOiAwIH0sXG4gICAgICAgICAgICB0b3RhbENvbnRhY3RzOiAwLFxuICAgICAgICAgICAgc3BlZWQ6IDAsXG4gICAgICAgICAgICBhbmd1bGFyU3BlZWQ6IDAsXG4gICAgICAgICAgICB2ZWxvY2l0eTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDAsXG4gICAgICAgICAgICBpc1NlbnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICBpc1NsZWVwaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIG1vdGlvbjogMCxcbiAgICAgICAgICAgIHNsZWVwVGhyZXNob2xkOiA2MCxcbiAgICAgICAgICAgIGRlbnNpdHk6IDAuMDAxLFxuICAgICAgICAgICAgcmVzdGl0dXRpb246IDAsXG4gICAgICAgICAgICBmcmljdGlvbjogMC4xLFxuICAgICAgICAgICAgZnJpY3Rpb25TdGF0aWM6IDAuNSxcbiAgICAgICAgICAgIGZyaWN0aW9uQWlyOiAwLjAxLFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnk6IDB4MDAwMSxcbiAgICAgICAgICAgICAgICBtYXNrOiAweEZGRkZGRkZGLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvcDogMC4wNSxcbiAgICAgICAgICAgIHRpbWVTY2FsZTogMSxcbiAgICAgICAgICAgIHJlbmRlcjoge1xuICAgICAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogbnVsbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBudWxsLFxuICAgICAgICAgICAgICAgIHNwcml0ZToge1xuICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcbiAgICAgICAgICAgICAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgeU9mZnNldDogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldmVudHM6IG51bGwsXG4gICAgICAgICAgICBib3VuZHM6IG51bGwsXG4gICAgICAgICAgICBjaGFtZmVyOiBudWxsLFxuICAgICAgICAgICAgY2lyY2xlUmFkaXVzOiAwLFxuICAgICAgICAgICAgcG9zaXRpb25QcmV2OiBudWxsLFxuICAgICAgICAgICAgYW5nbGVQcmV2OiAwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgYXhlczogbnVsbCxcbiAgICAgICAgICAgIGFyZWE6IDAsXG4gICAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgICAgaW5lcnRpYTogMCxcbiAgICAgICAgICAgIGRlbHRhVGltZTogMTAwMCAvIDYwLFxuICAgICAgICAgICAgX29yaWdpbmFsOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJvZHkgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBfaW5pdFByb3BlcnRpZXMoYm9keSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIGdyb3VwIGluZGV4IGZvciB3aGljaCBib2RpZXMgd2lsbCBjb2xsaWRlLlxuICAgICAqIElmIGBpc05vbkNvbGxpZGluZ2AgaXMgYHRydWVgLCByZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBncm91cCBpbmRleCBmb3Igd2hpY2ggYm9kaWVzIHdpbGwgX25vdF8gY29sbGlkZS5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAbWV0aG9kIG5leHRHcm91cFxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2lzTm9uQ29sbGlkaW5nPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIGdyb3VwIGluZGV4XG4gICAgICovXG4gICAgQm9keS5uZXh0R3JvdXAgPSBmdW5jdGlvbihpc05vbkNvbGxpZGluZykge1xuICAgICAgICBpZiAoaXNOb25Db2xsaWRpbmcpXG4gICAgICAgICAgICByZXR1cm4gQm9keS5fbmV4dE5vbkNvbGxpZGluZ0dyb3VwSWQtLTtcblxuICAgICAgICByZXR1cm4gQm9keS5fbmV4dENvbGxpZGluZ0dyb3VwSWQrKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgY2F0ZWdvcnkgYml0ZmllbGQgKHN0YXJ0aW5nIGFmdGVyIHRoZSBpbml0aWFsIGRlZmF1bHQgY2F0ZWdvcnkgYDB4MDAwMWApLlxuICAgICAqIFRoZXJlIGFyZSAzMiBhdmFpbGFibGUuIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBtZXRob2QgbmV4dENhdGVnb3J5XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBVbmlxdWUgY2F0ZWdvcnkgYml0ZmllbGRcbiAgICAgKi9cbiAgICBCb2R5Lm5leHRDYXRlZ29yeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBCb2R5Ll9uZXh0Q2F0ZWdvcnkgPSBCb2R5Ll9uZXh0Q2F0ZWdvcnkgPDwgMTtcbiAgICAgICAgcmV0dXJuIEJvZHkuX25leHRDYXRlZ29yeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZXMgYm9keSBwcm9wZXJ0aWVzLlxuICAgICAqIEBtZXRob2QgX2luaXRQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge30gW29wdGlvbnNdXG4gICAgICovXG4gICAgdmFyIF9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gaW5pdCByZXF1aXJlZCBwcm9wZXJ0aWVzIChvcmRlciBpcyBpbXBvcnRhbnQpXG4gICAgICAgIEJvZHkuc2V0KGJvZHksIHtcbiAgICAgICAgICAgIGJvdW5kczogYm9keS5ib3VuZHMgfHwgQm91bmRzLmNyZWF0ZShib2R5LnZlcnRpY2VzKSxcbiAgICAgICAgICAgIHBvc2l0aW9uUHJldjogYm9keS5wb3NpdGlvblByZXYgfHwgVmVjdG9yLmNsb25lKGJvZHkucG9zaXRpb24pLFxuICAgICAgICAgICAgYW5nbGVQcmV2OiBib2R5LmFuZ2xlUHJldiB8fCBib2R5LmFuZ2xlLFxuICAgICAgICAgICAgdmVydGljZXM6IGJvZHkudmVydGljZXMsXG4gICAgICAgICAgICBwYXJ0czogYm9keS5wYXJ0cyB8fCBbYm9keV0sXG4gICAgICAgICAgICBpc1N0YXRpYzogYm9keS5pc1N0YXRpYyxcbiAgICAgICAgICAgIGlzU2xlZXBpbmc6IGJvZHkuaXNTbGVlcGluZyxcbiAgICAgICAgICAgIHBhcmVudDogYm9keS5wYXJlbnQgfHwgYm9keVxuICAgICAgICB9KTtcblxuICAgICAgICBWZXJ0aWNlcy5yb3RhdGUoYm9keS52ZXJ0aWNlcywgYm9keS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIEF4ZXMucm90YXRlKGJvZHkuYXhlcywgYm9keS5hbmdsZSk7XG4gICAgICAgIEJvdW5kcy51cGRhdGUoYm9keS5ib3VuZHMsIGJvZHkudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuXG4gICAgICAgIC8vIGFsbG93IG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgIEJvZHkuc2V0KGJvZHksIHtcbiAgICAgICAgICAgIGF4ZXM6IG9wdGlvbnMuYXhlcyB8fCBib2R5LmF4ZXMsXG4gICAgICAgICAgICBhcmVhOiBvcHRpb25zLmFyZWEgfHwgYm9keS5hcmVhLFxuICAgICAgICAgICAgbWFzczogb3B0aW9ucy5tYXNzIHx8IGJvZHkubWFzcyxcbiAgICAgICAgICAgIGluZXJ0aWE6IG9wdGlvbnMuaW5lcnRpYSB8fCBib2R5LmluZXJ0aWFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVuZGVyIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGRlZmF1bHRGaWxsU3R5bGUgPSAoYm9keS5pc1N0YXRpYyA/ICcjMTQxNTFmJyA6IENvbW1vbi5jaG9vc2UoWycjZjE5NjQ4JywgJyNmNWQyNTknLCAnI2Y1NWEzYycsICcjMDYzZTdiJywgJyNlY2VjZDEnXSkpLFxuICAgICAgICAgICAgZGVmYXVsdFN0cm9rZVN0eWxlID0gYm9keS5pc1N0YXRpYyA/ICcjNTU1JyA6ICcjY2NjJyxcbiAgICAgICAgICAgIGRlZmF1bHRMaW5lV2lkdGggPSBib2R5LmlzU3RhdGljICYmIGJvZHkucmVuZGVyLmZpbGxTdHlsZSA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgICBib2R5LnJlbmRlci5maWxsU3R5bGUgPSBib2R5LnJlbmRlci5maWxsU3R5bGUgfHwgZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgICAgYm9keS5yZW5kZXIuc3Ryb2tlU3R5bGUgPSBib2R5LnJlbmRlci5zdHJva2VTdHlsZSB8fCBkZWZhdWx0U3Ryb2tlU3R5bGU7XG4gICAgICAgIGJvZHkucmVuZGVyLmxpbmVXaWR0aCA9IGJvZHkucmVuZGVyLmxpbmVXaWR0aCB8fCBkZWZhdWx0TGluZVdpZHRoO1xuICAgICAgICBib2R5LnJlbmRlci5zcHJpdGUueE9mZnNldCArPSAtKGJvZHkuYm91bmRzLm1pbi54IC0gYm9keS5wb3NpdGlvbi54KSAvIChib2R5LmJvdW5kcy5tYXgueCAtIGJvZHkuYm91bmRzLm1pbi54KTtcbiAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnlPZmZzZXQgKz0gLShib2R5LmJvdW5kcy5taW4ueSAtIGJvZHkucG9zaXRpb24ueSkgLyAoYm9keS5ib3VuZHMubWF4LnkgLSBib2R5LmJvdW5kcy5taW4ueSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcHJvcGVydHkgYW5kIGEgdmFsdWUgKG9yIG1hcCBvZiksIHNldHMgdGhlIHByb3BlcnR5KHMpIG9uIHRoZSBib2R5LCB1c2luZyB0aGUgYXBwcm9wcmlhdGUgc2V0dGVyIGZ1bmN0aW9ucyBpZiB0aGV5IGV4aXN0LlxuICAgICAqIFByZWZlciB0byB1c2UgdGhlIGFjdHVhbCBzZXR0ZXIgZnVuY3Rpb25zIGluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIHNpdHVhdGlvbnMuXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge30gc2V0dGluZ3MgQSBwcm9wZXJ0eSBuYW1lIChvciBtYXAgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzKSB0byBzZXQgb24gdGhlIGJvZHkuXG4gICAgICogQHBhcmFtIHt9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgaWYgYHNldHRpbmdzYCBpcyBhIHNpbmdsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIEJvZHkuc2V0ID0gZnVuY3Rpb24oYm9keSwgc2V0dGluZ3MsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eTtcblxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHNldHRpbmdzID0ge307XG4gICAgICAgICAgICBzZXR0aW5nc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHRpbmdzLCBwcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3NbcHJvcGVydHldO1xuICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgICBjYXNlICdpc1N0YXRpYyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRTdGF0aWMoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNTbGVlcGluZyc6XG4gICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21hc3MnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZW5zaXR5JzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldERlbnNpdHkoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5lcnRpYSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRJbmVydGlhKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2VzJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FuZ2xlJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ZlbG9jaXR5JzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFZlbG9jaXR5KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FuZ3VsYXJWZWxvY2l0eSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BlZWQnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0U3BlZWQoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5ndWxhclNwZWVkJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldEFuZ3VsYXJTcGVlZChib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwYXJ0cyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRQYXJ0cyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50cmUnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0Q2VudHJlKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYm9keVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvZHkgYXMgc3RhdGljLCBpbmNsdWRpbmcgaXNTdGF0aWMgZmxhZyBhbmQgc2V0dGluZyBtYXNzIGFuZCBpbmVydGlhIHRvIEluZmluaXR5LlxuICAgICAqIEBtZXRob2Qgc2V0U3RhdGljXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtib29sfSBpc1N0YXRpY1xuICAgICAqL1xuICAgIEJvZHkuc2V0U3RhdGljID0gZnVuY3Rpb24oYm9keSwgaXNTdGF0aWMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICAgICAgICAgIGlmICghcGFydC5pc1N0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0Ll9vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpdHV0aW9uOiBwYXJ0LnJlc3RpdHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IHBhcnQuZnJpY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNzOiBwYXJ0Lm1hc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmVydGlhOiBwYXJ0LmluZXJ0aWEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zaXR5OiBwYXJ0LmRlbnNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlTWFzczogcGFydC5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VJbmVydGlhOiBwYXJ0LmludmVyc2VJbmVydGlhXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydC5yZXN0aXR1dGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgcGFydC5tYXNzID0gcGFydC5pbmVydGlhID0gcGFydC5kZW5zaXR5ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgcGFydC5pbnZlcnNlTWFzcyA9IHBhcnQuaW52ZXJzZUluZXJ0aWEgPSAwO1xuXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvblByZXYueCA9IHBhcnQucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi55ID0gcGFydC5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIHBhcnQuYW5nbGVQcmV2ID0gcGFydC5hbmdsZTtcbiAgICAgICAgICAgICAgICBwYXJ0LmFuZ3VsYXJWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5hbmd1bGFyU3BlZWQgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnQubW90aW9uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC5fb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnJlc3RpdHV0aW9uID0gcGFydC5fb3JpZ2luYWwucmVzdGl0dXRpb247XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IHBhcnQuX29yaWdpbmFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHBhcnQubWFzcyA9IHBhcnQuX29yaWdpbmFsLm1hc3M7XG4gICAgICAgICAgICAgICAgcGFydC5pbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW5lcnRpYTtcbiAgICAgICAgICAgICAgICBwYXJ0LmRlbnNpdHkgPSBwYXJ0Ll9vcmlnaW5hbC5kZW5zaXR5O1xuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZU1hc3MgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VJbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW52ZXJzZUluZXJ0aWE7XG5cbiAgICAgICAgICAgICAgICBwYXJ0Ll9vcmlnaW5hbCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnQuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoZSBib2R5LiBJbnZlcnNlIG1hc3MsIGRlbnNpdHkgYW5kIGluZXJ0aWEgYXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICogQG1ldGhvZCBzZXRNYXNzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcbiAgICAgKi9cbiAgICBCb2R5LnNldE1hc3MgPSBmdW5jdGlvbihib2R5LCBtYXNzKSB7XG4gICAgICAgIHZhciBtb21lbnQgPSBib2R5LmluZXJ0aWEgLyAoYm9keS5tYXNzIC8gNik7XG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IG1vbWVudCAqIChtYXNzIC8gNik7XG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuXG4gICAgICAgIGJvZHkubWFzcyA9IG1hc3M7XG4gICAgICAgIGJvZHkuaW52ZXJzZU1hc3MgPSAxIC8gYm9keS5tYXNzO1xuICAgICAgICBib2R5LmRlbnNpdHkgPSBib2R5Lm1hc3MgLyBib2R5LmFyZWE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlbnNpdHkgb2YgdGhlIGJvZHkuIE1hc3MgYW5kIGluZXJ0aWEgYXJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuXG4gICAgICogQG1ldGhvZCBzZXREZW5zaXR5XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldERlbnNpdHkgPSBmdW5jdGlvbihib2R5LCBkZW5zaXR5KSB7XG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBkZW5zaXR5ICogYm9keS5hcmVhKTtcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIGJvZHkuIFRoaXMgaXMgdGhlIHNlY29uZCBtb21lbnQgb2YgYXJlYSBpbiB0d28gZGltZW5zaW9ucy5cbiAgICAgKiBJbnZlcnNlIGluZXJ0aWEgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIGNoYW5nZS4gTWFzcyBpcyBub3QgY2hhbmdlZC5cbiAgICAgKiBAbWV0aG9kIHNldEluZXJ0aWFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5lcnRpYVxuICAgICAqL1xuICAgIEJvZHkuc2V0SW5lcnRpYSA9IGZ1bmN0aW9uKGJvZHksIGluZXJ0aWEpIHtcbiAgICAgICAgYm9keS5pbmVydGlhID0gaW5lcnRpYTtcbiAgICAgICAgYm9keS5pbnZlcnNlSW5lcnRpYSA9IDEgLyBib2R5LmluZXJ0aWE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvZHkncyB2ZXJ0aWNlcyBhbmQgdXBkYXRlcyBib2R5IHByb3BlcnRpZXMgYWNjb3JkaW5nbHksIGluY2x1ZGluZyBpbmVydGlhLCBhcmVhIGFuZCBtYXNzICh3aXRoIHJlc3BlY3QgdG8gYGJvZHkuZGVuc2l0eWApLlxuICAgICAqIFZlcnRpY2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSB0cmFuc2Zvcm1lZCB0byBiZSBvcmllbnRhdGVkIGFyb3VuZCB0aGVpciBjZW50cmUgb2YgbWFzcyBhcyB0aGUgb3JpZ2luLlxuICAgICAqIFRoZXkgYXJlIHRoZW4gYXV0b21hdGljYWxseSB0cmFuc2xhdGVkIHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGBib2R5LnBvc2l0aW9uYC5cbiAgICAgKlxuICAgICAqIFRoZSBgdmVydGljZXNgIGFyZ3VtZW50IHNob3VsZCBiZSBwYXNzZWQgYXMgYW4gYXJyYXkgb2YgYE1hdHRlci5WZWN0b3JgIHBvaW50cyAob3IgYSBgTWF0dGVyLlZlcnRpY2VzYCBhcnJheSkuXG4gICAgICogVmVydGljZXMgbXVzdCBmb3JtIGEgY29udmV4IGh1bGwuIENvbmNhdmUgdmVydGljZXMgbXVzdCBiZSBkZWNvbXBvc2VkIGludG8gY29udmV4IHBhcnRzLlxuICAgICAqIFxuICAgICAqIEBtZXRob2Qgc2V0VmVydGljZXNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3ZlY3RvcltdfSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIEJvZHkuc2V0VmVydGljZXMgPSBmdW5jdGlvbihib2R5LCB2ZXJ0aWNlcykge1xuICAgICAgICAvLyBjaGFuZ2UgdmVydGljZXNcbiAgICAgICAgaWYgKHZlcnRpY2VzWzBdLmJvZHkgPT09IGJvZHkpIHtcbiAgICAgICAgICAgIGJvZHkudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkudmVydGljZXMgPSBWZXJ0aWNlcy5jcmVhdGUodmVydGljZXMsIGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgYm9keS5heGVzID0gQXhlcy5mcm9tVmVydGljZXMoYm9keS52ZXJ0aWNlcyk7XG4gICAgICAgIGJvZHkuYXJlYSA9IFZlcnRpY2VzLmFyZWEoYm9keS52ZXJ0aWNlcyk7XG4gICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBib2R5LmRlbnNpdHkgKiBib2R5LmFyZWEpO1xuXG4gICAgICAgIC8vIG9yaWVudCB2ZXJ0aWNlcyBhcm91bmQgdGhlIGNlbnRyZSBvZiBtYXNzIGF0IG9yaWdpbiAoMCwgMClcbiAgICAgICAgdmFyIGNlbnRyZSA9IFZlcnRpY2VzLmNlbnRyZShib2R5LnZlcnRpY2VzKTtcbiAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGNlbnRyZSwgLTEpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBpbmVydGlhIHdoaWxlIHZlcnRpY2VzIGFyZSBhdCBvcmlnaW4gKDAsIDApXG4gICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCBCb2R5Ll9pbmVydGlhU2NhbGUgKiBWZXJ0aWNlcy5pbmVydGlhKGJvZHkudmVydGljZXMsIGJvZHkubWFzcykpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeVxuICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUoYm9keS52ZXJ0aWNlcywgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIEJvdW5kcy51cGRhdGUoYm9keS5ib3VuZHMsIGJvZHkudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYXJ0cyBvZiB0aGUgYGJvZHlgLiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYGJvZHkucGFydHNgIGZvciBkZXRhaWxzIGFuZCByZXF1aXJlbWVudHMgb24gaG93IHBhcnRzIGFyZSB1c2VkLlxuICAgICAqIFxuICAgICAqIFNlZSBCb2RpZXMuZnJvbVZlcnRpY2VzIGZvciBhIHJlbGF0ZWQgdXRpbGl0eS5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgYGJvZHlgIG1hc3MsIGluZXJ0aWEgYW5kIGNlbnRyb2lkIGJhc2VkIG9uIHRoZSBwYXJ0cyBnZW9tZXRyeS4gIFxuICAgICAqIFNldHMgZWFjaCBgcGFydC5wYXJlbnRgIHRvIGJlIHRoaXMgYGJvZHlgLiAgXG4gICAgICogXG4gICAgICogVGhlIGNvbnZleCBodWxsIGlzIGNvbXB1dGVkIGFuZCBzZXQgb24gdGhpcyBgYm9keWAgKHVubGVzcyBgYXV0b0h1bGxgIGlzIGBmYWxzZWApLiAgXG4gICAgICogQXV0b21hdGljYWxseSBlbnN1cmVzIHRoYXQgdGhlIGZpcnN0IHBhcnQgaW4gYGJvZHkucGFydHNgIGlzIHRoZSBgYm9keWAuXG4gICAgICogQG1ldGhvZCBzZXRQYXJ0c1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2F1dG9IdWxsPXRydWVdXG4gICAgICovXG4gICAgQm9keS5zZXRQYXJ0cyA9IGZ1bmN0aW9uKGJvZHksIHBhcnRzLCBhdXRvSHVsbCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBhZGQgYWxsIHRoZSBwYXJ0cywgZW5zdXJpbmcgdGhhdCB0aGUgZmlyc3QgcGFydCBpcyBhbHdheXMgdGhlIHBhcmVudCBib2R5XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgIGJvZHkucGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgYm9keS5wYXJ0cy5wdXNoKGJvZHkpO1xuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IGJvZHkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnBhcmVudCA9IGJvZHk7XG4gICAgICAgICAgICAgICAgYm9keS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGF1dG9IdWxsID0gdHlwZW9mIGF1dG9IdWxsICE9PSAndW5kZWZpbmVkJyA/IGF1dG9IdWxsIDogdHJ1ZTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBjb252ZXggaHVsbCBvZiBhbGwgcGFydHMgdG8gc2V0IG9uIHRoZSBwYXJlbnQgYm9keVxuICAgICAgICBpZiAoYXV0b0h1bGwpIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQocGFydHNbaV0udmVydGljZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcblxuICAgICAgICAgICAgdmFyIGh1bGwgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICBodWxsQ2VudHJlID0gVmVydGljZXMuY2VudHJlKGh1bGwpO1xuXG4gICAgICAgICAgICBCb2R5LnNldFZlcnRpY2VzKGJvZHksIGh1bGwpO1xuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGh1bGxDZW50cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgdmFyIHRvdGFsID0gQm9keS5fdG90YWxQcm9wZXJ0aWVzKGJvZHkpO1xuXG4gICAgICAgIGJvZHkuYXJlYSA9IHRvdGFsLmFyZWE7XG4gICAgICAgIGJvZHkucGFyZW50ID0gYm9keTtcbiAgICAgICAgYm9keS5wb3NpdGlvbi54ID0gdG90YWwuY2VudHJlLng7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueSA9IHRvdGFsLmNlbnRyZS55O1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gdG90YWwuY2VudHJlLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSB0b3RhbC5jZW50cmUueTtcblxuICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgdG90YWwubWFzcyk7XG4gICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB0b3RhbC5pbmVydGlhKTtcbiAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB0b3RhbC5jZW50cmUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNlbnRyZSBvZiBtYXNzIG9mIHRoZSBib2R5LiBcbiAgICAgKiBUaGUgYGNlbnRyZWAgaXMgYSB2ZWN0b3IgaW4gd29ybGQtc3BhY2UgdW5sZXNzIGByZWxhdGl2ZWAgaXMgc2V0LCBpbiB3aGljaCBjYXNlIGl0IGlzIGEgdHJhbnNsYXRpb24uXG4gICAgICogVGhlIGNlbnRyZSBvZiBtYXNzIGlzIHRoZSBwb2ludCB0aGUgYm9keSByb3RhdGVzIGFib3V0IGFuZCBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBub24tdW5pZm9ybSBkZW5zaXR5LlxuICAgICAqIFRoaXMgaXMgZXF1YWwgdG8gbW92aW5nIGBib2R5LnBvc2l0aW9uYCBidXQgbm90IHRoZSBgYm9keS52ZXJ0aWNlc2AuXG4gICAgICogSW52YWxpZCBpZiB0aGUgYGNlbnRyZWAgZmFsbHMgb3V0c2lkZSB0aGUgYm9keSdzIGNvbnZleCBodWxsLlxuICAgICAqIEBtZXRob2Qgc2V0Q2VudHJlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IGNlbnRyZVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gcmVsYXRpdmVcbiAgICAgKi9cbiAgICBCb2R5LnNldENlbnRyZSA9IGZ1bmN0aW9uKGJvZHksIGNlbnRyZSwgcmVsYXRpdmUpIHtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZSkge1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGNlbnRyZS54IC0gKGJvZHkucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb25QcmV2LngpO1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGNlbnRyZS55IC0gKGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2LnkpO1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi54ID0gY2VudHJlLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uLnkgPSBjZW50cmUueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gY2VudHJlLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGNlbnRyZS55O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi54ICs9IGNlbnRyZS54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi55ICs9IGNlbnRyZS55O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5LiBCeSBkZWZhdWx0IHZlbG9jaXR5IGlzIHVuY2hhbmdlZC5cbiAgICAgKiBJZiBgdXBkYXRlVmVsb2NpdHlgIGlzIGB0cnVlYCB0aGVuIHZlbG9jaXR5IGlzIGluZmVycmVkIGZyb20gdGhlIGNoYW5nZSBpbiBwb3NpdGlvbi5cbiAgICAgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlVmVsb2NpdHk9ZmFsc2VdXG4gICAgICovXG4gICAgQm9keS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uLCB1cGRhdGVWZWxvY2l0eSkge1xuICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKHBvc2l0aW9uLCBib2R5LnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAodXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gYm9keS5wb3NpdGlvbi55O1xuICAgICAgICAgICAgYm9keS52ZWxvY2l0eS54ID0gZGVsdGEueDtcbiAgICAgICAgICAgIGJvZHkudmVsb2NpdHkueSA9IGRlbHRhLnk7XG4gICAgICAgICAgICBib2R5LnNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ICs9IGRlbHRhLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IGRlbHRhLnk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCArPSBkZWx0YS54O1xuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGRlbHRhLnk7XG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgZGVsdGEpO1xuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW5nbGUgb2YgdGhlIGJvZHkuIEJ5IGRlZmF1bHQgYW5ndWxhciB2ZWxvY2l0eSBpcyB1bmNoYW5nZWQuXG4gICAgICogSWYgYHVwZGF0ZVZlbG9jaXR5YCBpcyBgdHJ1ZWAgdGhlbiBhbmd1bGFyIHZlbG9jaXR5IGlzIGluZmVycmVkIGZyb20gdGhlIGNoYW5nZSBpbiBhbmdsZS5cbiAgICAgKiBAbWV0aG9kIHNldEFuZ2xlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlVmVsb2NpdHk9ZmFsc2VdXG4gICAgICovXG4gICAgQm9keS5zZXRBbmdsZSA9IGZ1bmN0aW9uKGJvZHksIGFuZ2xlLCB1cGRhdGVWZWxvY2l0eSkge1xuICAgICAgICB2YXIgZGVsdGEgPSBhbmdsZSAtIGJvZHkuYW5nbGU7XG4gICAgICAgIFxuICAgICAgICBpZiAodXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgICAgIGJvZHkuYW5nbGVQcmV2ID0gYm9keS5hbmdsZTtcbiAgICAgICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gZGVsdGE7XG4gICAgICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkuYW5nbGVQcmV2ICs9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG4gICAgICAgICAgICBwYXJ0LmFuZ2xlICs9IGRlbHRhO1xuICAgICAgICAgICAgVmVydGljZXMucm90YXRlKHBhcnQudmVydGljZXMsIGRlbHRhLCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgZGVsdGEpO1xuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBWZWN0b3Iucm90YXRlQWJvdXQocGFydC5wb3NpdGlvbiwgZGVsdGEsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LiAgXG4gICAgICogQWZmZWN0cyBib2R5IHNwZWVkLlxuICAgICAqIEBtZXRob2Qgc2V0VmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldFZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSwgdmVsb2NpdHkpIHtcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IGJvZHkuZGVsdGFUaW1lIC8gQm9keS5fYmFzZURlbHRhO1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54IC0gdmVsb2NpdHkueCAqIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueSAtIHZlbG9jaXR5LnkgKiB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9IChib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54KSAvIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS52ZWxvY2l0eS55ID0gKGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2LnkpIC8gdGltZVNjYWxlO1xuICAgICAgICBib2R5LnNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShib2R5LnZlbG9jaXR5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsaW5lYXIgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXG4gICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb2R5LmdldFZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICB2YXIgdGltZVNjYWxlID0gQm9keS5fYmFzZURlbHRhIC8gYm9keS5kZWx0YVRpbWU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IChib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54KSAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIHk6IChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KSAqIHRpbWVTY2FsZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmVhciBzcGVlZCBvZiB0aGUgYm9keS4gIFxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIG1hZ25pdHVkZSBvZiBpdHMgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCBnZXRTcGVlZFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gc3BlZWRcbiAgICAgKi9cbiAgICBCb2R5LmdldFNwZWVkID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICByZXR1cm4gVmVjdG9yLm1hZ25pdHVkZShCb2R5LmdldFZlbG9jaXR5KGJvZHkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBsaW5lYXIgc3BlZWQgb2YgdGhlIGJvZHkuICBcbiAgICAgKiBEaXJlY3Rpb24gaXMgbWFpbnRhaW5lZC4gQWZmZWN0cyBib2R5IHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2Qgc2V0U3BlZWRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcbiAgICAgKi9cbiAgICBCb2R5LnNldFNwZWVkID0gZnVuY3Rpb24oYm9keSwgc3BlZWQpIHtcbiAgICAgICAgQm9keS5zZXRWZWxvY2l0eShib2R5LCBWZWN0b3IubXVsdChWZWN0b3Iubm9ybWFsaXNlKEJvZHkuZ2V0VmVsb2NpdHkoYm9keSkpLCBzcGVlZCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGJvZHkuICBcbiAgICAgKiBBZmZlY3RzIGJvZHkgYW5ndWxhciBzcGVlZC5cbiAgICAgKiBAbWV0aG9kIHNldEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2ZWxvY2l0eVxuICAgICAqL1xuICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSwgdmVsb2NpdHkpIHtcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IGJvZHkuZGVsdGFUaW1lIC8gQm9keS5fYmFzZURlbHRhO1xuICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGUgLSB2ZWxvY2l0eSAqIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSAoYm9keS5hbmdsZSAtIGJvZHkuYW5nbGVQcmV2KSAvIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSBNYXRoLmFicyhib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYm9keS5cbiAgICAgKiBAbWV0aG9kIGdldEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYW5ndWxhciB2ZWxvY2l0eVxuICAgICAqL1xuICAgIEJvZHkuZ2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICByZXR1cm4gKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgKiBCb2R5Ll9iYXNlRGVsdGEgLyBib2R5LmRlbHRhVGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBib2R5LiAgXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgbWFnbml0dWRlIG9mIGl0cyBhbmd1bGFyIHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2QgZ2V0QW5ndWxhclNwZWVkXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhbmd1bGFyIHNwZWVkXG4gICAgICovXG4gICAgQm9keS5nZXRBbmd1bGFyU3BlZWQgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhCb2R5LmdldEFuZ3VsYXJWZWxvY2l0eShib2R5KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgYm9keS4gIFxuICAgICAqIERpcmVjdGlvbiBpcyBtYWludGFpbmVkLiBBZmZlY3RzIGJvZHkgYW5ndWxhciB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHNldEFuZ3VsYXJTcGVlZFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICAgICAqL1xuICAgIEJvZHkuc2V0QW5ndWxhclNwZWVkID0gZnVuY3Rpb24oYm9keSwgc3BlZWQpIHtcbiAgICAgICAgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYm9keSwgQ29tbW9uLnNpZ24oQm9keS5nZXRBbmd1bGFyVmVsb2NpdHkoYm9keSkpICogc3BlZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGJvZHkgYnkgYSBnaXZlbiB2ZWN0b3IgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb24uIEJ5IGRlZmF1bHQgdmVsb2NpdHkgaXMgdW5jaGFuZ2VkLlxuICAgICAqIElmIGB1cGRhdGVWZWxvY2l0eWAgaXMgYHRydWVgIHRoZW4gdmVsb2NpdHkgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY2hhbmdlIGluIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlVmVsb2NpdHk9ZmFsc2VdXG4gICAgICovXG4gICAgQm9keS50cmFuc2xhdGUgPSBmdW5jdGlvbihib2R5LCB0cmFuc2xhdGlvbiwgdXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCBWZWN0b3IuYWRkKGJvZHkucG9zaXRpb24sIHRyYW5zbGF0aW9uKSwgdXBkYXRlVmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGEgYm9keSBieSBhIGdpdmVuIGFuZ2xlIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IGFuZ2xlLiBCeSBkZWZhdWx0IGFuZ3VsYXIgdmVsb2NpdHkgaXMgdW5jaGFuZ2VkLlxuICAgICAqIElmIGB1cGRhdGVWZWxvY2l0eWAgaXMgYHRydWVgIHRoZW4gYW5ndWxhciB2ZWxvY2l0eSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBjaGFuZ2UgaW4gYW5nbGUuXG4gICAgICogQG1ldGhvZCByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BvaW50XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZVZlbG9jaXR5PWZhbHNlXVxuICAgICAqL1xuICAgIEJvZHkucm90YXRlID0gZnVuY3Rpb24oYm9keSwgcm90YXRpb24sIHBvaW50LCB1cGRhdGVWZWxvY2l0eSkge1xuICAgICAgICBpZiAoIXBvaW50KSB7XG4gICAgICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIGJvZHkuYW5nbGUgKyByb3RhdGlvbiwgdXBkYXRlVmVsb2NpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKSxcbiAgICAgICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbiksXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyAoZHggKiBjb3MgLSBkeSAqIHNpbiksXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIChkeCAqIHNpbiArIGR5ICogY29zKVxuICAgICAgICAgICAgfSwgdXBkYXRlVmVsb2NpdHkpO1xuXG4gICAgICAgICAgICBCb2R5LnNldEFuZ2xlKGJvZHksIGJvZHkuYW5nbGUgKyByb3RhdGlvbiwgdXBkYXRlVmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGUgYm9keSwgaW5jbHVkaW5nIHVwZGF0aW5nIHBoeXNpY2FsIHByb3BlcnRpZXMgKG1hc3MsIGFyZWEsIGF4ZXMsIGluZXJ0aWEpLCBmcm9tIGEgd29ybGQtc3BhY2UgcG9pbnQgKGRlZmF1bHQgaXMgYm9keSBjZW50cmUpLlxuICAgICAqIEBtZXRob2Qgc2NhbGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbcG9pbnRdXG4gICAgICovXG4gICAgQm9keS5zY2FsZSA9IGZ1bmN0aW9uKGJvZHksIHNjYWxlWCwgc2NhbGVZLCBwb2ludCkge1xuICAgICAgICB2YXIgdG90YWxBcmVhID0gMCxcbiAgICAgICAgICAgIHRvdGFsSW5lcnRpYSA9IDA7XG5cbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCBib2R5LnBvc2l0aW9uO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBzY2FsZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgVmVydGljZXMuc2NhbGUocGFydC52ZXJ0aWNlcywgc2NhbGVYLCBzY2FsZVksIHBvaW50KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHBhcnQuYXhlcyA9IEF4ZXMuZnJvbVZlcnRpY2VzKHBhcnQudmVydGljZXMpO1xuICAgICAgICAgICAgcGFydC5hcmVhID0gVmVydGljZXMuYXJlYShwYXJ0LnZlcnRpY2VzKTtcbiAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhwYXJ0LCBib2R5LmRlbnNpdHkgKiBwYXJ0LmFyZWEpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgaW5lcnRpYSAocmVxdWlyZXMgdmVydGljZXMgdG8gYmUgYXQgb3JpZ2luKVxuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIHsgeDogLXBhcnQucG9zaXRpb24ueCwgeTogLXBhcnQucG9zaXRpb24ueSB9KTtcbiAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShwYXJ0LCBCb2R5Ll9pbmVydGlhU2NhbGUgKiBWZXJ0aWNlcy5pbmVydGlhKHBhcnQudmVydGljZXMsIHBhcnQubWFzcykpO1xuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIHsgeDogcGFydC5wb3NpdGlvbi54LCB5OiBwYXJ0LnBvc2l0aW9uLnkgfSk7XG5cbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHRvdGFsQXJlYSArPSBwYXJ0LmFyZWE7XG4gICAgICAgICAgICAgICAgdG90YWxJbmVydGlhICs9IHBhcnQuaW5lcnRpYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2NhbGUgcG9zaXRpb25cbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCA9IHBvaW50LnggKyAocGFydC5wb3NpdGlvbi54IC0gcG9pbnQueCkgKiBzY2FsZVg7XG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnkgPSBwb2ludC55ICsgKHBhcnQucG9zaXRpb24ueSAtIHBvaW50LnkpICogc2NhbGVZO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm91bmRzXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBwYXJlbnQgYm9keVxuICAgICAgICBpZiAoYm9keS5wYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBib2R5LmFyZWEgPSB0b3RhbEFyZWE7XG5cbiAgICAgICAgICAgIGlmICghYm9keS5pc1N0YXRpYykge1xuICAgICAgICAgICAgICAgIEJvZHkuc2V0TWFzcyhib2R5LCBib2R5LmRlbnNpdHkgKiB0b3RhbEFyZWEpO1xuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB0b3RhbEluZXJ0aWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIGNpcmNsZXNcbiAgICAgICAgaWYgKGJvZHkuY2lyY2xlUmFkaXVzKSB7IFxuICAgICAgICAgICAgaWYgKHNjYWxlWCA9PT0gc2NhbGVZKSB7XG4gICAgICAgICAgICAgICAgYm9keS5jaXJjbGVSYWRpdXMgKj0gc2NhbGVYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBib2R5IGlzIG5vIGxvbmdlciBhIGNpcmNsZVxuICAgICAgICAgICAgICAgIGJvZHkuY2lyY2xlUmFkaXVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiB1cGRhdGUgYnkgaW50ZWdyYXRpbmcgdGhlIGVxdWF0aW9ucyBvZiBtb3Rpb24gb24gdGhlIGBib2R5YC5cbiAgICAgKiBUaGlzIGlzIGFwcGxpZWQgZXZlcnkgdXBkYXRlIGJ5IGBNYXR0ZXIuRW5naW5lYCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YVRpbWU9MTYuNjY2XVxuICAgICAqL1xuICAgIEJvZHkudXBkYXRlID0gZnVuY3Rpb24oYm9keSwgZGVsdGFUaW1lKSB7XG4gICAgICAgIGRlbHRhVGltZSA9ICh0eXBlb2YgZGVsdGFUaW1lICE9PSAndW5kZWZpbmVkJyA/IGRlbHRhVGltZSA6ICgxMDAwIC8gNjApKSAqIGJvZHkudGltZVNjYWxlO1xuXG4gICAgICAgIHZhciBkZWx0YVRpbWVTcXVhcmVkID0gZGVsdGFUaW1lICogZGVsdGFUaW1lLFxuICAgICAgICAgICAgY29ycmVjdGlvbiA9IEJvZHkuX3RpbWVDb3JyZWN0aW9uID8gZGVsdGFUaW1lIC8gKGJvZHkuZGVsdGFUaW1lIHx8IGRlbHRhVGltZSkgOiAxO1xuXG4gICAgICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgICAgdmFyIGZyaWN0aW9uQWlyID0gMSAtIGJvZHkuZnJpY3Rpb25BaXIgKiAoZGVsdGFUaW1lIC8gQ29tbW9uLl9iYXNlRGVsdGEpLFxuICAgICAgICAgICAgdmVsb2NpdHlQcmV2WCA9IChib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54KSAqIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICB2ZWxvY2l0eVByZXZZID0gKGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2LnkpICogY29ycmVjdGlvbjtcblxuICAgICAgICAvLyB1cGRhdGUgdmVsb2NpdHkgd2l0aCBWZXJsZXQgaW50ZWdyYXRpb25cbiAgICAgICAgYm9keS52ZWxvY2l0eS54ID0gKHZlbG9jaXR5UHJldlggKiBmcmljdGlvbkFpcikgKyAoYm9keS5mb3JjZS54IC8gYm9keS5tYXNzKSAqIGRlbHRhVGltZVNxdWFyZWQ7XG4gICAgICAgIGJvZHkudmVsb2NpdHkueSA9ICh2ZWxvY2l0eVByZXZZICogZnJpY3Rpb25BaXIpICsgKGJvZHkuZm9yY2UueSAvIGJvZHkubWFzcykgKiBkZWx0YVRpbWVTcXVhcmVkO1xuXG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnk7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBib2R5LnZlbG9jaXR5Lng7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XG4gICAgICAgIGJvZHkuZGVsdGFUaW1lID0gZGVsdGFUaW1lO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBhbmd1bGFyIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXG4gICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gKChib2R5LmFuZ2xlIC0gYm9keS5hbmdsZVByZXYpICogZnJpY3Rpb25BaXIgKiBjb3JyZWN0aW9uKSArIChib2R5LnRvcnF1ZSAvIGJvZHkuaW5lcnRpYSkgKiBkZWx0YVRpbWVTcXVhcmVkO1xuICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGU7XG4gICAgICAgIGJvZHkuYW5nbGUgKz0gYm9keS5hbmd1bGFyVmVsb2NpdHk7XG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSBib2R5IGdlb21ldHJ5XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuXG4gICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCArPSBib2R5LnZlbG9jaXR5Lng7XG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGJvZHkudmVsb2NpdHkueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvZHkuYW5ndWxhclZlbG9jaXR5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgVmVydGljZXMucm90YXRlKHBhcnQudmVydGljZXMsIGJvZHkuYW5ndWxhclZlbG9jaXR5LCBib2R5LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBBeGVzLnJvdGF0ZShwYXJ0LmF4ZXMsIGJvZHkuYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGJvZHkuYW5ndWxhclZlbG9jaXR5LCBib2R5LnBvc2l0aW9uLCBwYXJ0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcHJvcGVydGllcyBgYm9keS52ZWxvY2l0eWAsIGBib2R5LnNwZWVkYCwgYGJvZHkuYW5ndWxhclZlbG9jaXR5YCBhbmQgYGJvZHkuYW5ndWxhclNwZWVkYCB3aGljaCBhcmUgbm9ybWFsaXNlZCBpbiByZWxhdGlvbiB0byBgQm9keS5fYmFzZURlbHRhYC5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVZlbG9jaXRpZXNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICBCb2R5LnVwZGF0ZVZlbG9jaXRpZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBCb2R5Ll9iYXNlRGVsdGEgLyBib2R5LmRlbHRhVGltZSxcbiAgICAgICAgICAgIGJvZHlWZWxvY2l0eSA9IGJvZHkudmVsb2NpdHk7XG5cbiAgICAgICAgYm9keVZlbG9jaXR5LnggPSAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgKiB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHlWZWxvY2l0eS55ID0gKGJvZHkucG9zaXRpb24ueSAtIGJvZHkucG9zaXRpb25QcmV2LnkpICogdGltZVNjYWxlO1xuICAgICAgICBib2R5LnNwZWVkID0gTWF0aC5zcXJ0KChib2R5VmVsb2NpdHkueCAqIGJvZHlWZWxvY2l0eS54KSArIChib2R5VmVsb2NpdHkueSAqIGJvZHlWZWxvY2l0eS55KSk7XG5cbiAgICAgICAgYm9keS5hbmd1bGFyVmVsb2NpdHkgPSAoYm9keS5hbmdsZSAtIGJvZHkuYW5nbGVQcmV2KSAqIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSBNYXRoLmFicyhib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGBmb3JjZWAgdG8gdGhlIGBib2R5YCBmcm9tIHRoZSBmb3JjZSBvcmlnaW4gYHBvc2l0aW9uYCBpbiB3b3JsZC1zcGFjZSwgb3ZlciBhIHNpbmdsZSB0aW1lc3RlcCwgaW5jbHVkaW5nIGFwcGx5aW5nIGFueSByZXN1bHRpbmcgYW5ndWxhciB0b3JxdWUuXG4gICAgICogXG4gICAgICogRm9yY2VzIGFyZSB1c2VmdWwgZm9yIGVmZmVjdHMgbGlrZSBncmF2aXR5LCB3aW5kIG9yIHJvY2tldCB0aHJ1c3QsIGJ1dCBjYW4gYmUgZGlmZmljdWx0IGluIHByYWN0aWNlIHdoZW4gcHJlY2lzZSBjb250cm9sIGlzIG5lZWRlZC4gSW4gdGhlc2UgY2FzZXMgc2VlIGBCb2R5LnNldFZlbG9jaXR5YCBhbmQgYEJvZHkuc2V0UG9zaXRpb25gIGFzIGFuIGFsdGVybmF0aXZlLlxuICAgICAqIFxuICAgICAqIFRoZSBmb3JjZSBmcm9tIHRoaXMgZnVuY3Rpb24gaXMgb25seSBhcHBsaWVkIG9uY2UgZm9yIHRoZSBkdXJhdGlvbiBvZiBhIHNpbmdsZSB0aW1lc3RlcCwgaW4gb3RoZXIgd29yZHMgdGhlIGR1cmF0aW9uIGRlcGVuZHMgZGlyZWN0bHkgb24gdGhlIGN1cnJlbnQgZW5naW5lIHVwZGF0ZSBgZGVsdGFgIGFuZCB0aGUgcmF0ZSBvZiBjYWxscyB0byB0aGlzIGZ1bmN0aW9uLlxuICAgICAqIFxuICAgICAqIFRoZXJlZm9yZSB0byBhY2NvdW50IGZvciB0aW1lLCB5b3Ugc2hvdWxkIGFwcGx5IHRoZSBmb3JjZSBjb25zdGFudGx5IG92ZXIgYXMgbWFueSBlbmdpbmUgdXBkYXRlcyBhcyBlcXVpdmFsZW50IHRvIHRoZSBpbnRlbmRlZCBkdXJhdGlvbi5cbiAgICAgKiBcbiAgICAgKiBJZiBhbGwgb3IgcGFydCBvZiB0aGUgZm9yY2UgZHVyYXRpb24gaXMgc29tZSBmcmFjdGlvbiBvZiBhIHRpbWVzdGVwLCBmaXJzdCBtdWx0aXBseSB0aGUgZm9yY2UgYnkgYGR1cmF0aW9uIC8gdGltZXN0ZXBgLlxuICAgICAqIFxuICAgICAqIFRoZSBmb3JjZSBvcmlnaW4gYHBvc2l0aW9uYCBpbiB3b3JsZC1zcGFjZSBtdXN0IGFsc28gYmUgc3BlY2lmaWVkLiBQYXNzaW5nIGBib2R5LnBvc2l0aW9uYCB3aWxsIHJlc3VsdCBpbiB6ZXJvIGFuZ3VsYXIgZWZmZWN0IGFzIHRoZSBmb3JjZSBvcmlnaW4gd291bGQgYmUgYXQgdGhlIGNlbnRyZSBvZiBtYXNzLlxuICAgICAqIFxuICAgICAqIFRoZSBgYm9keWAgd2lsbCB0YWtlIHRpbWUgdG8gYWNjZWxlcmF0ZSB1bmRlciBhIGZvcmNlLCB0aGUgcmVzdWx0aW5nIGVmZmVjdCBkZXBlbmRzIG9uIGR1cmF0aW9uIG9mIHRoZSBmb3JjZSwgdGhlIGJvZHkgbWFzcyBhbmQgb3RoZXIgZm9yY2VzIG9uIHRoZSBib2R5IGluY2x1ZGluZyBmcmljdGlvbiBjb21iaW5lZC5cbiAgICAgKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9zaXRpb24gVGhlIGZvcmNlIG9yaWdpbiBpbiB3b3JsZC1zcGFjZS4gUGFzcyBgYm9keS5wb3NpdGlvbmAgdG8gYXZvaWQgYW5ndWxhciB0b3JxdWUuXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IGZvcmNlXG4gICAgICovXG4gICAgQm9keS5hcHBseUZvcmNlID0gZnVuY3Rpb24oYm9keSwgcG9zaXRpb24sIGZvcmNlKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB7IHg6IHBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uLnkgfTtcbiAgICAgICAgYm9keS5mb3JjZS54ICs9IGZvcmNlLng7XG4gICAgICAgIGJvZHkuZm9yY2UueSArPSBmb3JjZS55O1xuICAgICAgICBib2R5LnRvcnF1ZSArPSBvZmZzZXQueCAqIGZvcmNlLnkgLSBvZmZzZXQueSAqIGZvcmNlLng7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN1bXMgb2YgdGhlIHByb3BlcnRpZXMgb2YgYWxsIGNvbXBvdW5kIHBhcnRzIG9mIHRoZSBwYXJlbnQgYm9keS5cbiAgICAgKiBAbWV0aG9kIF90b3RhbFByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBCb2R5Ll90b3RhbFByb3BlcnRpZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIC8vIGZyb20gZXF1YXRpb25zIGF0OlxuICAgICAgICAvLyBodHRwczovL2Vjb3Vyc2VzLm91LmVkdS9jZ2ktYmluL2Vib29rLmNnaT9kb2M9JnRvcGljPXN0JmNoYXBfc2VjPTA3LjImcGFnZT10aGVvcnlcbiAgICAgICAgLy8gaHR0cDovL291dHB1dC50by9zaWRld2F5L2RlZmF1bHQuYXNwP3Fubz0xMjExMDAwODdcblxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1hc3M6IDAsXG4gICAgICAgICAgICBhcmVhOiAwLFxuICAgICAgICAgICAgaW5lcnRpYTogMCxcbiAgICAgICAgICAgIGNlbnRyZTogeyB4OiAwLCB5OiAwIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdW0gdGhlIHByb3BlcnRpZXMgb2YgYWxsIGNvbXBvdW5kIHBhcnRzIG9mIHRoZSBwYXJlbnQgYm9keVxuICAgICAgICBmb3IgKHZhciBpID0gYm9keS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXSxcbiAgICAgICAgICAgICAgICBtYXNzID0gcGFydC5tYXNzICE9PSBJbmZpbml0eSA/IHBhcnQubWFzcyA6IDE7XG5cbiAgICAgICAgICAgIHByb3BlcnRpZXMubWFzcyArPSBtYXNzO1xuICAgICAgICAgICAgcHJvcGVydGllcy5hcmVhICs9IHBhcnQuYXJlYTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuaW5lcnRpYSArPSBwYXJ0LmluZXJ0aWE7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNlbnRyZSA9IFZlY3Rvci5hZGQocHJvcGVydGllcy5jZW50cmUsIFZlY3Rvci5tdWx0KHBhcnQucG9zaXRpb24sIG1hc3MpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BlcnRpZXMuY2VudHJlID0gVmVjdG9yLmRpdihwcm9wZXJ0aWVzLmNlbnRyZSwgcHJvcGVydGllcy5tYXNzKTtcblxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGJvZHkgc3RhcnRzIHNsZWVwaW5nICh3aGVyZSBgdGhpc2AgaXMgdGhlIGJvZHkpLlxuICAgICpcbiAgICAqIEBldmVudCBzbGVlcFN0YXJ0XG4gICAgKiBAdGhpcyB7Ym9keX0gVGhlIGJvZHkgdGhhdCBoYXMgc3RhcnRlZCBzbGVlcGluZ1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGVuZHMgc2xlZXBpbmcgKHdoZXJlIGB0aGlzYCBpcyB0aGUgYm9keSkuXG4gICAgKlxuICAgICogQGV2ZW50IHNsZWVwRW5kXG4gICAgKiBAdGhpcyB7Ym9keX0gVGhlIGJvZHkgdGhhdCBoYXMgZW5kZWQgc2xlZXBpbmdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlZ2VyIGBOdW1iZXJgIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIG51bWJlciBnZW5lcmF0ZWQgaW4gYEJvZHkuY3JlYXRlYCBieSBgQ29tbW9uLm5leHRJZGAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBTZXQgYnkgYEJvZHkuY3JlYXRlYC5cbiAgICAgKiBcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJib2R5XCJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkJvZHlcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRQYXJ0c2AgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYEJvZGllcy5mcm9tVmVydGljZXNgIGZvciBhIHJlbGF0ZWQgdXRpbGl0eS5cbiAgICAgKiBcbiAgICAgKiBBbiBhcnJheSBvZiBib2RpZXMgKHRoZSAncGFydHMnKSB0aGF0IG1ha2UgdXAgdGhpcyBib2R5ICh0aGUgJ3BhcmVudCcpLiBUaGUgZmlyc3QgYm9keSBpbiB0aGlzIGFycmF5IG11c3QgYWx3YXlzIGJlIGEgc2VsZi1yZWZlcmVuY2UgdG8gdGhpcyBgYm9keWAuICBcbiAgICAgKiBcbiAgICAgKiBUaGUgcGFydHMgYXJlIGZpeGVkIHRvZ2V0aGVyIGFuZCB0aGVyZWZvcmUgcGVyZm9ybSBhcyBhIHNpbmdsZSB1bmlmaWVkIHJpZ2lkIGJvZHkuXG4gICAgICogXG4gICAgICogUGFydHMgaW4gcmVsYXRpb24gdG8gZWFjaCBvdGhlciBhcmUgYWxsb3dlZCB0byBvdmVybGFwLCBhcyB3ZWxsIGFzIGZvcm0gZ2FwcyBvciBob2xlcywgc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGNvbXBsZXggY29uY2F2ZSBib2RpZXMgdW5saWtlIHdoZW4gdXNpbmcgYSBzaW5nbGUgcGFydC4gXG4gICAgICogXG4gICAgICogVXNlIHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucyBvbiB0aGUgcGFyZW50IGBib2R5YCByYXRoZXIgdGhhbiBvbiBwYXJ0cy5cbiAgICAgKiAgIFxuICAgICAqIE91dHNpZGUgb2YgdGhlaXIgZ2VvbWV0cnksIG1vc3QgcHJvcGVydGllcyBvbiBwYXJ0cyBhcmUgbm90IGNvbnNpZGVyZWQgb3IgdXBkYXRlZC4gIFxuICAgICAqIEFzIHN1Y2ggJ3Blci1wYXJ0JyBtYXRlcmlhbCBwcm9wZXJ0aWVzIGFtb25nIG90aGVycyBhcmUgbm90IGN1cnJlbnRseSBjb25zaWRlcmVkLlxuICAgICAqIFxuICAgICAqIFBhcnRzIHNob3VsZCBiZSBjcmVhdGVkIHNwZWNpZmljYWxseSBmb3IgdGhlaXIgcGFyZW50IGJvZHkuICBcbiAgICAgKiBQYXJ0cyBzaG91bGQgbm90IGJlIHNoYXJlZCBvciByZXVzZWQgYmV0d2VlbiBib2RpZXMsIG9ubHkgb25lIHBhcmVudCBpcyBzdXBwb3J0ZWQuICBcbiAgICAgKiBQYXJ0cyBzaG91bGQgbm90IGhhdmUgdGhlaXIgb3duIHBhcnRzLCB0aGV5IGFyZSBub3QgaGFuZGxlZCByZWN1cnNpdmVseS4gIFxuICAgICAqIFBhcnRzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIHdvcmxkIGRpcmVjdGx5IG9yIGFueSBvdGhlciBjb21wb3NpdGUuICBcbiAgICAgKiBQYXJ0cyBvd24gdmVydGljZXMgbXVzdCBiZSBjb252ZXggYW5kIGluIGNsb2Nrd2lzZSBvcmRlci4gICBcbiAgICAgKiBcbiAgICAgKiBBIGJvZHkgd2l0aCBtb3JlIHRoYW4gb25lIHBhcnQgaXMgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIGEgJ2NvbXBvdW5kJyBib2R5LiBcbiAgICAgKiBcbiAgICAgKiBVc2UgYEJvZHkuc2V0UGFydHNgIHdoZW4gc2V0dGluZyBwYXJ0cyB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIG9mIGFsbCBwcm9wZXJ0aWVzLiAgXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgcGFydHNcbiAgICAgKiBAdHlwZSBib2R5W11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVwZGF0ZWQgYnkgYEJvZHkuc2V0UGFydHNgLlxuICAgICAqIFxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBib2R5IHRoYXQgdGhpcyBpcyBhIHBhcnQgb2YuIFNlZSBgYm9keS5wYXJ0c2AuXG4gICAgICogVGhpcyBpcyBhIHNlbGYgcmVmZXJlbmNlIGlmIHRoZSBib2R5IGlzIG5vdCBhIHBhcnQgb2YgYW5vdGhlciBib2R5LlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHBhcmVudFxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgc3BlY2lmeWluZyB0aGUgYW5nbGUgb2YgdGhlIGJvZHksIGluIHJhZGlhbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldFZlcnRpY2VzYCBvciBgQm9keS5zZXRQYXJ0c2AgdG8gc2V0LiBTZWUgYWxzbyBgQm9kaWVzLmZyb21WZXJ0aWNlc2AuXG4gICAgICogXG4gICAgICogQW4gYXJyYXkgb2YgYFZlY3RvcmAgb2JqZWN0cyB0aGF0IHNwZWNpZnkgdGhlIGNvbnZleCBodWxsIG9mIHRoZSByaWdpZCBib2R5LlxuICAgICAqIFRoZXNlIHNob3VsZCBiZSBwcm92aWRlZCBhYm91dCB0aGUgb3JpZ2luIGAoMCwgMClgLiBFLmcuXG4gICAgICpcbiAgICAgKiBgW3sgeDogMCwgeTogMCB9LCB7IHg6IDI1LCB5OiA1MCB9LCB7IHg6IDUwLCB5OiAwIH1dYFxuICAgICAqIFxuICAgICAqIFZlcnRpY2VzIG11c3QgYWx3YXlzIGJlIGNvbnZleCwgaW4gY2xvY2t3aXNlIG9yZGVyIGFuZCBtdXN0IG5vdCBjb250YWluIGFueSBkdXBsaWNhdGUgcG9pbnRzLlxuICAgICAqIFxuICAgICAqIENvbmNhdmUgdmVydGljZXMgc2hvdWxkIGJlIGRlY29tcG9zZWQgaW50byBjb252ZXggYHBhcnRzYCwgc2VlIGBCb2RpZXMuZnJvbVZlcnRpY2VzYCBhbmQgYEJvZHkuc2V0UGFydHNgLlxuICAgICAqXG4gICAgICogV2hlbiBzZXQgdGhlIHZlcnRpY2VzIGFyZSB0cmFuc2xhdGVkIHN1Y2ggdGhhdCBgYm9keS5wb3NpdGlvbmAgaXMgYXQgdGhlIGNlbnRyZSBvZiBtYXNzLlxuICAgICAqIE1hbnkgb3RoZXIgYm9keSBwcm9wZXJ0aWVzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSB0aGVzZSB2ZXJ0aWNlcyB3aGVuIHNldCBpbmNsdWRpbmcgYGRlbnNpdHlgLCBgYXJlYWAgYW5kIGBpbmVydGlhYC5cbiAgICAgKiBcbiAgICAgKiBUaGUgbW9kdWxlIGBNYXR0ZXIuVmVydGljZXNgIGNvbnRhaW5zIHVzZWZ1bCBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggdmVydGljZXMuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB2ZWN0b3JbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRQb3NpdGlvbmAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBjdXJyZW50IHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgYWNjdW11bGF0ZXMgdGhlIHRvdGFsIGZvcmNlIGFwcGxpZWQgdG8gdGhlIGJvZHkgZm9yIGEgc2luZ2xlIHVwZGF0ZS5cbiAgICAgKiBGb3JjZSBpcyB6ZXJvZWQgYWZ0ZXIgZXZlcnkgYEVuZ2luZS51cGRhdGVgLCBzbyBjb25zdGFudCBmb3JjZXMgc2hvdWxkIGJlIGFwcGxpZWQgZm9yIGV2ZXJ5IHVwZGF0ZSB0aGV5IGFyZSBuZWVkZWQuIFNlZSBhbHNvIGBCb2R5LmFwcGx5Rm9yY2VgLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBmb3JjZVxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgYWNjdW11bGF0ZXMgdGhlIHRvdGFsIHRvcnF1ZSAodHVybmluZyBmb3JjZSkgYXBwbGllZCB0byB0aGUgYm9keSBmb3IgYSBzaW5nbGUgdXBkYXRlLiBTZWUgYWxzbyBgQm9keS5hcHBseUZvcmNlYC5cbiAgICAgKiBUb3JxdWUgaXMgemVyb2VkIGFmdGVyIGV2ZXJ5IGBFbmdpbmUudXBkYXRlYCwgc28gY29uc3RhbnQgdG9ycXVlcyBzaG91bGQgYmUgYXBwbGllZCBmb3IgZXZlcnkgdXBkYXRlIHRoZXkgYXJlIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRvcnF1ZXMgcmVzdWx0IGluIGFuZ3VsYXIgYWNjZWxlcmF0aW9uIG9uIGV2ZXJ5IHVwZGF0ZSwgd2hpY2ggZGVwZW5kcyBvbiBib2R5IGluZXJ0aWEgYW5kIHRoZSBlbmdpbmUgdXBkYXRlIGRlbHRhLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSB0b3JxdWVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldFNwZWVkYCB0byBzZXQuIFxuICAgICAqIFxuICAgICAqIFNlZSBgQm9keS5nZXRTcGVlZGAgZm9yIGRldGFpbHMuXG4gICAgICogXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgbWFnbml0dWRlIG9mIGBib2R5LnZlbG9jaXR5YCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgc3BlZWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldFZlbG9jaXR5YCB0byBzZXQuIFxuICAgICAqIFxuICAgICAqIFNlZSBgQm9keS5nZXRWZWxvY2l0eWAgZm9yIGRldGFpbHMuXG4gICAgICogXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgbWFnbml0dWRlIG9mIGBib2R5LmFuZ3VsYXJWZWxvY2l0eWAgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5XG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0QW5ndWxhclNwZWVkYCB0byBzZXQuIFxuICAgICAqIFxuICAgICAqIFNlZSBgQm9keS5nZXRBbmd1bGFyU3BlZWRgIGZvciBkZXRhaWxzLlxuICAgICAqIFxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyU3BlZWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldEFuZ3VsYXJWZWxvY2l0eWAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYEJvZHkuZ2V0QW5ndWxhclZlbG9jaXR5YCBmb3IgZGV0YWlscy5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyVmVsb2NpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldFN0YXRpY2AgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBhIGJvZHkgaXMgY29uc2lkZXJlZCBzdGF0aWMuIEEgc3RhdGljIGJvZHkgY2FuIG5ldmVyIGNoYW5nZSBwb3NpdGlvbiBvciBhbmdsZSBhbmQgaXMgY29tcGxldGVseSBmaXhlZC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBpc1N0YXRpY1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBib2R5IGlzIGEgc2Vuc29yLiBTZW5zb3IgdHJpZ2dlcnMgY29sbGlzaW9uIGV2ZW50cywgYnV0IGRvZXNuJ3QgcmVhY3Qgd2l0aCBjb2xsaWRpbmcgYm9keSBwaHlzaWNhbGx5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlzU2Vuc29yXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBTbGVlcGluZy5zZXRgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJvZHkgaXMgY29uc2lkZXJlZCBzbGVlcGluZy4gQSBzbGVlcGluZyBib2R5IGFjdHMgc2ltaWxhciB0byBhIHN0YXRpYyBib2R5LCBleGNlcHQgaXQgaXMgb25seSB0ZW1wb3JhcnkgYW5kIGNhbiBiZSBhd29rZW4uXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgaXNTbGVlcGluZ1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIENhbGN1bGF0ZWQgZHVyaW5nIGVuZ2luZSB1cGRhdGUgb25seSB3aGVuIHNsZWVwaW5nIGlzIGVuYWJsZWQuXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGxvb3NlbHkgbWVhc3VyZXMgdGhlIGFtb3VudCBvZiBtb3ZlbWVudCBhIGJvZHkgY3VycmVudGx5IGhhcy5cbiAgICAgKlxuICAgICAqIERlcml2ZWQgZnJvbSBgYm9keS5zcGVlZF4yICsgYm9keS5hbmd1bGFyU3BlZWReMmAuIFNlZSBgU2xlZXBpbmcudXBkYXRlYC5cbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgbW90aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGxlbmd0aCBvZiB0aW1lIGR1cmluZyB3aGljaCB0aGlzIGJvZHkgbXVzdCBoYXZlIG5lYXItemVybyB2ZWxvY2l0eSBiZWZvcmUgaXQgaXMgc2V0IGFzIHNsZWVwaW5nIGJ5IHRoZSBgTWF0dGVyLlNsZWVwaW5nYCBtb2R1bGUgKGlmIHNsZWVwaW5nIGlzIGVuYWJsZWQgYnkgdGhlIGVuZ2luZSkuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGhyZXNob2xkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgNjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0RGVuc2l0eWAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgZGVuc2l0eSBvZiB0aGUgYm9keSAobWFzcyBwZXIgdW5pdCBhcmVhKS5cbiAgICAgKiBcbiAgICAgKiBNYXNzIHdpbGwgYWxzbyBiZSB1cGRhdGVkIHdoZW4gc2V0LlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IGRlbnNpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRNYXNzYCB0byBzZXQuIFxuICAgICAqIFxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBtYXNzIG9mIHRoZSBib2R5LlxuICAgICAqIFxuICAgICAqIERlbnNpdHkgd2lsbCBhbHNvIGJlIHVwZGF0ZWQgd2hlbiBzZXQuXG4gICAgICogXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IG1hc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0TWFzc2AgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgaW52ZXJzZSBtYXNzIG9mIHRoZSBib2R5IChgMSAvIG1hc3NgKS5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlTWFzc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB3aGVuIHZlcnRpY2VzLCBtYXNzIG9yIGRlbnNpdHkgYXJlIHNldCBvciBzZXQgdGhyb3VnaCBgQm9keS5zZXRJbmVydGlhYC5cbiAgICAgKiBcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIGJvZHkuIFRoaXMgaXMgdGhlIHNlY29uZCBtb21lbnQgb2YgYXJlYSBpbiB0d28gZGltZW5zaW9ucy5cbiAgICAgKiBcbiAgICAgKiBDYW4gYmUgbWFudWFsbHkgc2V0IHRvIGBJbmZpbml0eWAgdG8gcHJldmVudCByb3RhdGlvbiBvZiB0aGUgYm9keS4gU2VlIGBCb2R5LnNldEluZXJ0aWFgLlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gQXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHdoZW4gdmVydGljZXMsIG1hc3Mgb3IgZGVuc2l0eSBhcmUgc2V0IG9yIGNhbGN1bGF0ZWQgYnkgYEJvZHkuc2V0SW5lcnRpYWAuXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGludmVyc2UgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIGJvZHkgKGAxIC8gaW5lcnRpYWApLlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBpbnZlcnNlSW5lcnRpYVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHJlc3RpdHV0aW9uIChlbGFzdGljaXR5KSBvZiB0aGUgYm9keS4gVGhlIHZhbHVlIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGAoMCwgMSlgLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIGNvbGxpc2lvbnMgbWF5IGJlIHBlcmZlY3RseSBpbmVsYXN0aWMgYW5kIG5vIGJvdW5jaW5nIG1heSBvY2N1ci4gXG4gICAgICogQSB2YWx1ZSBvZiBgMC44YCBtZWFucyB0aGUgYm9keSBtYXkgYm91bmNlIGJhY2sgd2l0aCBhcHByb3hpbWF0ZWx5IDgwJSBvZiBpdHMga2luZXRpYyBlbmVyZ3kuXG4gICAgICogTm90ZSB0aGF0IGNvbGxpc2lvbiByZXNwb25zZSBpcyBiYXNlZCBvbiBfcGFpcnNfIG9mIGJvZGllcywgYW5kIHRoYXQgYHJlc3RpdHV0aW9uYCB2YWx1ZXMgYXJlIF9jb21iaW5lZF8gd2l0aCB0aGUgZm9sbG93aW5nIGZvcm11bGE6XG4gICAgICpcbiAgICAgKiBgTWF0aC5tYXgoYm9keUEucmVzdGl0dXRpb24sIGJvZHlCLnJlc3RpdHV0aW9uKWBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBmcmljdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZhbHVlIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGAoMCwgMSlgLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoYXQgdGhlIGJvZHkgbWF5IHNsaWRlIGluZGVmaW5pdGVseS5cbiAgICAgKiBBIHZhbHVlIG9mIGAxYCBtZWFucyB0aGUgYm9keSBtYXkgY29tZSB0byBhIHN0b3AgYWxtb3N0IGluc3RhbnRseSBhZnRlciBhIGZvcmNlIGlzIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZWZmZWN0cyBvZiB0aGUgdmFsdWUgbWF5IGJlIG5vbi1saW5lYXIuIFxuICAgICAqIEhpZ2ggdmFsdWVzIG1heSBiZSB1bnN0YWJsZSBkZXBlbmRpbmcgb24gdGhlIGJvZHkuXG4gICAgICogVGhlIGVuZ2luZSB1c2VzIGEgQ291bG9tYiBmcmljdGlvbiBtb2RlbCBpbmNsdWRpbmcgc3RhdGljIGFuZCBraW5ldGljIGZyaWN0aW9uLlxuICAgICAqIE5vdGUgdGhhdCBjb2xsaXNpb24gcmVzcG9uc2UgaXMgYmFzZWQgb24gX3BhaXJzXyBvZiBib2RpZXMsIGFuZCB0aGF0IGBmcmljdGlvbmAgdmFsdWVzIGFyZSBfY29tYmluZWRfIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtdWxhOlxuICAgICAqXG4gICAgICogYE1hdGgubWluKGJvZHlBLmZyaWN0aW9uLCBib2R5Qi5mcmljdGlvbilgXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBzdGF0aWMgZnJpY3Rpb24gb2YgdGhlIGJvZHkgKGluIHRoZSBDb3Vsb21iIGZyaWN0aW9uIG1vZGVsKS4gXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgdGhlIGJvZHkgd2lsbCBuZXZlciAnc3RpY2snIHdoZW4gaXQgaXMgbmVhcmx5IHN0YXRpb25hcnkgYW5kIG9ubHkgZHluYW1pYyBgZnJpY3Rpb25gIGlzIHVzZWQuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUgKGUuZy4gYDEwYCksIHRoZSBtb3JlIGZvcmNlIGl0IHdpbGwgdGFrZSB0byBpbml0aWFsbHkgZ2V0IHRoZSBib2R5IG1vdmluZyB3aGVuIG5lYXJseSBzdGF0aW9uYXJ5LlxuICAgICAqIFRoaXMgdmFsdWUgaXMgbXVsdGlwbGllZCB3aXRoIHRoZSBgZnJpY3Rpb25gIHByb3BlcnR5IHRvIG1ha2UgaXQgZWFzaWVyIHRvIGNoYW5nZSBgZnJpY3Rpb25gIGFuZCBtYWludGFpbiBhbiBhcHByb3ByaWF0ZSBhbW91bnQgb2Ygc3RhdGljIGZyaWN0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RhdGljXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC41XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgYWlyIGZyaWN0aW9uIG9mIHRoZSBib2R5IChhaXIgcmVzaXN0YW5jZSkuIFxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgc2xvdyBhcyBpdCBtb3ZlcyB0aHJvdWdoIHNwYWNlLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlLCB0aGUgZmFzdGVyIGEgYm9keSBzbG93cyB3aGVuIG1vdmluZyB0aHJvdWdoIHNwYWNlLlxuICAgICAqIFRoZSBlZmZlY3RzIG9mIHRoZSB2YWx1ZSBhcmUgbm9uLWxpbmVhci4gXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25BaXJcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGZpbHRlcmluZyBwcm9wZXJ0aWVzIG9mIHRoaXMgYm9keS5cbiAgICAgKlxuICAgICAqIENvbGxpc2lvbnMgYmV0d2VlbiB0d28gYm9kaWVzIHdpbGwgb2JleSB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICAgICAqIC0gSWYgdGhlIHR3byBib2RpZXMgaGF2ZSB0aGUgc2FtZSBub24temVybyB2YWx1ZSBvZiBgY29sbGlzaW9uRmlsdGVyLmdyb3VwYCxcbiAgICAgKiAgIHRoZXkgd2lsbCBhbHdheXMgY29sbGlkZSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmUsIGFuZCB0aGV5IHdpbGwgbmV2ZXIgY29sbGlkZVxuICAgICAqICAgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgICAqIC0gSWYgdGhlIHR3byBib2RpZXMgaGF2ZSBkaWZmZXJlbnQgdmFsdWVzIG9mIGBjb2xsaXNpb25GaWx0ZXIuZ3JvdXBgIG9yIGlmIG9uZVxuICAgICAqICAgKG9yIGJvdGgpIG9mIHRoZSBib2RpZXMgaGFzIGEgdmFsdWUgb2YgMCwgdGhlbiB0aGUgY2F0ZWdvcnkvbWFzayBydWxlcyBhcHBseSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogRWFjaCBib2R5IGJlbG9uZ3MgdG8gYSBjb2xsaXNpb24gY2F0ZWdvcnksIGdpdmVuIGJ5IGBjb2xsaXNpb25GaWx0ZXIuY2F0ZWdvcnlgLiBUaGlzXG4gICAgICogdmFsdWUgaXMgdXNlZCBhcyBhIGJpdCBmaWVsZCBhbmQgdGhlIGNhdGVnb3J5IHNob3VsZCBoYXZlIG9ubHkgb25lIGJpdCBzZXQsIG1lYW5pbmcgdGhhdFxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IGlzIGEgcG93ZXIgb2YgdHdvIGluIHRoZSByYW5nZSBbMSwgMl4zMV0uIFRodXMsIHRoZXJlIGFyZSAzMlxuICAgICAqIGRpZmZlcmVudCBjb2xsaXNpb24gY2F0ZWdvcmllcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBFYWNoIGJvZHkgYWxzbyBkZWZpbmVzIGEgY29sbGlzaW9uIGJpdG1hc2ssIGdpdmVuIGJ5IGBjb2xsaXNpb25GaWx0ZXIubWFza2Agd2hpY2ggc3BlY2lmaWVzXG4gICAgICogdGhlIGNhdGVnb3JpZXMgaXQgY29sbGlkZXMgd2l0aCAodGhlIHZhbHVlIGlzIHRoZSBiaXR3aXNlIEFORCB2YWx1ZSBvZiBhbGwgdGhlc2UgY2F0ZWdvcmllcykuXG4gICAgICpcbiAgICAgKiBVc2luZyB0aGUgY2F0ZWdvcnkvbWFzayBydWxlcywgdHdvIGJvZGllcyBgQWAgYW5kIGBCYCBjb2xsaWRlIGlmIGVhY2ggaW5jbHVkZXMgdGhlIG90aGVyJ3NcbiAgICAgKiBjYXRlZ29yeSBpbiBpdHMgbWFzaywgaS5lLiBgKGNhdGVnb3J5QSAmIG1hc2tCKSAhPT0gMGAgYW5kIGAoY2F0ZWdvcnlCICYgbWFza0EpICE9PSAwYFxuICAgICAqIGFyZSBib3RoIHRydWUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBJbnRlZ2VyIGBOdW1iZXJgLCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGdyb3VwIHRoaXMgYm9keSBiZWxvbmdzIHRvLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5ncm91cFxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYml0IGZpZWxkIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gY2F0ZWdvcnkgdGhpcyBib2R5IGJlbG9uZ3MgdG8uXG4gICAgICogVGhlIGNhdGVnb3J5IHZhbHVlIHNob3VsZCBoYXZlIG9ubHkgb25lIGJpdCBzZXQsIGZvciBleGFtcGxlIGAweDAwMDFgLlxuICAgICAqIFRoaXMgbWVhbnMgdGhlcmUgYXJlIHVwIHRvIDMyIHVuaXF1ZSBjb2xsaXNpb24gY2F0ZWdvcmllcyBhdmFpbGFibGUuXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5XG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBiaXQgbWFzayB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGNhdGVnb3JpZXMgdGhpcyBib2R5IG1heSBjb2xsaWRlIHdpdGguXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29sbGlzaW9uRmlsdGVyLm1hc2tcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyBhIHRoaW4gYm91bmRhcnkgYXJvdW5kIHRoZSBib2R5IHdoZXJlIGl0IGlzIGFsbG93ZWQgdG8gc2xpZ2h0bHkgc2luayBpbnRvIG90aGVyIGJvZGllcy5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGZvciBwcm9wZXIgY29sbGlzaW9uIHJlc3BvbnNlLCBpbmNsdWRpbmcgZnJpY3Rpb24gYW5kIHJlc3RpdHV0aW9uIGVmZmVjdHMuXG4gICAgICogXG4gICAgICogVGhlIGRlZmF1bHQgc2hvdWxkIGdlbmVyYWxseSBzdWZmaWNlIGluIG1vc3QgY2FzZXMuIFlvdSBtYXkgbmVlZCB0byBkZWNyZWFzZSB0aGlzIHZhbHVlIGZvciB2ZXJ5IHNtYWxsIGJvZGllcyB0aGF0IGFyZSBuZWFyaW5nIHRoZSBkZWZhdWx0IHZhbHVlIGluIHNjYWxlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNsb3BcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjA1XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHBlci1ib2R5IHRpbWUgc2NhbGluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lU2NhbGVcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXBkYXRlZCBkdXJpbmcgZW5naW5lIHVwZGF0ZS5cbiAgICAgKiBcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgcmVjb3JkcyB0aGUgbGFzdCBkZWx0YSB0aW1lIHZhbHVlIHVzZWQgdG8gdXBkYXRlIHRoaXMgYm9keS5cbiAgICAgKiBVc2VkIHRvIGNhbGN1bGF0ZSBzcGVlZCBhbmQgdmVsb2NpdHkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgZGVsdGFUaW1lXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMTAwMCAvIDYwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgT2JqZWN0YCB0aGF0IGRlZmluZXMgdGhlIHJlbmRlcmluZyBwcm9wZXJ0aWVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb2R1bGUgYE1hdHRlci5SZW5kZXJgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBib2R5IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudmlzaWJsZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcGFjaXR5IHRvIHVzZSB3aGVuIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIub3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSBzcHJpdGUgcHJvcGVydGllcyB0byB1c2Ugd2hlbiByZW5kZXJpbmcsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIHVzZSBhcyB0aGUgc3ByaXRlIHRleHR1cmUsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnRleHR1cmVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHgtYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueFNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIHNjYWxpbmcgaW4gdGhlIHktYXhpcyBmb3IgdGhlIHNwcml0ZSwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHgtYXhpcyBmb3IgdGhlIHNwcml0ZSAobm9ybWFsaXNlZCBieSB0ZXh0dXJlIHdpZHRoKS5cbiAgICAgICpcbiAgICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueE9mZnNldFxuICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICogQGRlZmF1bHQgMFxuICAgICAgKi9cblxuICAgIC8qKlxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB5LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSBoZWlnaHQpLlxuICAgICAgKlxuICAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZS55T2Zmc2V0XG4gICAgICAqIEB0eXBlIG51bWJlclxuICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGxpbmUgd2lkdGggdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBib2R5IG91dGxpbmUgKGlmIGEgc3ByaXRlIGlzIG5vdCBkZWZpbmVkKS5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyBubyBvdXRsaW5lIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmxpbmVXaWR0aFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBmaWxsIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuZmlsbFN0eWxlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgYSByYW5kb20gY29sb3VyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSBvdXRsaW5lIChpZiBhIHNwcml0ZSBpcyBub3QgZGVmaW5lZCkuXG4gICAgICogSXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB1c2luZyBhIGNhbnZhcywgc28gaXQgYWNjZXB0cyBDU1Mgc3R5bGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5zdHJva2VTdHlsZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IGEgcmFuZG9tIGNvbG91clxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIENhbGN1bGF0ZWQgYXV0b21hdGljYWxseSB3aGVuIHZlcnRpY2VzIGFyZSBzZXQuXG4gICAgICogXG4gICAgICogQW4gYXJyYXkgb2YgdW5pcXVlIGF4aXMgdmVjdG9ycyAoZWRnZSBub3JtYWxzKSB1c2VkIGZvciBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuICAgICAqIFRoZXNlIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgd2hlbiB2ZXJ0aWNlcyBhcmUgc2V0LlxuICAgICAqIFRoZXkgYXJlIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBheGVzXG4gICAgICogQHR5cGUgdmVjdG9yW11cbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIENhbGN1bGF0ZWQgYXV0b21hdGljYWxseSB3aGVuIHZlcnRpY2VzIGFyZSBzZXQuXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IG1lYXN1cmVzIHRoZSBhcmVhIG9mIHRoZSBib2R5J3MgY29udmV4IGh1bGwuXG4gICAgICogXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IGFyZWFcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgQUFCQiByZWdpb24gZm9yIHRoZSBib2R5LlxuICAgICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB3aGVuIHZlcnRpY2VzIGFyZSBzZXQgYW5kIGNvbnN0YW50bHkgdXBkYXRlZCBieSBgQm9keS51cGRhdGVgIGR1cmluZyBzaW11bGF0aW9uLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZHNcbiAgICAgKiBAdHlwZSBib3VuZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IG1heSBob2xkIHBhcmFtZXRlcnMgdG8gYmUgcGFzc2VkIHRvIGBWZXJ0aWNlcy5jaGFtZmVyYCB3aGVyZSBzdXBwb3J0ZWQgYnkgZXh0ZXJuYWwgZnVuY3Rpb25zLlxuICAgICAqIFxuICAgICAqIFNlZSBgVmVydGljZXMuY2hhbWZlcmAgZm9yIHBvc3NpYmxlIHBhcmFtZXRlcnMgdGhpcyBvYmplY3QgbWF5IGhvbGQuXG4gICAgICogXG4gICAgICogQ3VycmVudGx5IG9ubHkgZnVuY3Rpb25zIGluc2lkZSBgTWF0dGVyLkJvZGllc2AgcHJvdmlkZSBhIHV0aWxpdHkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBhcyBhIHZlcnRpY2VzIHByZS1wcm9jZXNzaW5nIG9wdGlvbi5cbiAgICAgKiBcbiAgICAgKiBBbHRlcm5hdGl2ZWx5IGNvbnNpZGVyIHVzaW5nIGBWZXJ0aWNlcy5jaGFtZmVyYCBkaXJlY3RseSBvbiB2ZXJ0aWNlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIGEgYm9keSBjcmVhdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgY2hhbWZlclxuICAgICAqIEB0eXBlIG9iamVjdHxudWxsfHVuZGVmaW5lZFxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuRXZlbnRzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyB0byBmaXJlIGFuZCBsaXN0ZW4gdG8gZXZlbnRzIG9uIG90aGVyIG9iamVjdHMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBFdmVudHNcbiovXG5cbnZhciBFdmVudHMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG5cbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdGhlIGdpdmVuIG9iamVjdCdzIGBldmVudE5hbWVgLlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIEV2ZW50cy5vbiA9IGZ1bmN0aW9uKG9iamVjdCwgZXZlbnROYW1lcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG5hbWVzID0gZXZlbnROYW1lcy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgbmFtZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzID0gb2JqZWN0LmV2ZW50cyB8fCB7fTtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZV0gPSBvYmplY3QuZXZlbnRzW25hbWVdIHx8IFtdO1xuICAgICAgICAgICAgb2JqZWN0LmV2ZW50c1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gZXZlbnQgY2FsbGJhY2suIElmIG5vIGNhbGxiYWNrLCBjbGVhcnMgYWxsIGNhbGxiYWNrcyBpbiBgZXZlbnROYW1lc2AuIElmIG5vIGBldmVudE5hbWVzYCwgY2xlYXJzIGFsbCBldmVudHMuXG4gICAgICogQG1ldGhvZCBvZmZcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIEV2ZW50cy5vZmYgPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lcykge1xuICAgICAgICAgICAgb2JqZWN0LmV2ZW50cyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIEV2ZW50cy5vZmYob2JqZWN0LCBjYWxsYmFjaylcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGV2ZW50TmFtZXM7XG4gICAgICAgICAgICBldmVudE5hbWVzID0gQ29tbW9uLmtleXMob2JqZWN0LmV2ZW50cykuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWVzID0gZXZlbnROYW1lcy5zcGxpdCgnICcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBvYmplY3QuZXZlbnRzW25hbWVzW2ldXSxcbiAgICAgICAgICAgICAgICBuZXdDYWxsYmFja3MgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3Nbal0gIT09IGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2tzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdC5ldmVudHNbbmFtZXNbaV1dID0gbmV3Q2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGFsbCB0aGUgY2FsbGJhY2tzIHN1YnNjcmliZWQgdG8gdGhlIGdpdmVuIG9iamVjdCdzIGBldmVudE5hbWVgLCBpbiB0aGUgb3JkZXIgdGhleSBzdWJzY3JpYmVkLCBpZiBhbnkuXG4gICAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAgICogQHBhcmFtIHt9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVzXG4gICAgICogQHBhcmFtIHt9IGV2ZW50XG4gICAgICovXG4gICAgRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihvYmplY3QsIGV2ZW50TmFtZXMsIGV2ZW50KSB7XG4gICAgICAgIHZhciBuYW1lcyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICBldmVudENsb25lO1xuXG4gICAgICAgIHZhciBldmVudHMgPSBvYmplY3QuZXZlbnRzO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBDb21tb24ua2V5cyhldmVudHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQpXG4gICAgICAgICAgICAgICAgZXZlbnQgPSB7fTtcblxuICAgICAgICAgICAgbmFtZXMgPSBldmVudE5hbWVzLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBldmVudENsb25lID0gQ29tbW9uLmNsb25lKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUuc291cmNlID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Nbal0uYXBwbHkob2JqZWN0LCBbZXZlbnRDbG9uZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIEEgY29tcG9zaXRlIGlzIGEgY29sbGVjdGlvbiBvZiBgTWF0dGVyLkJvZHlgLCBgTWF0dGVyLkNvbnN0cmFpbnRgIGFuZCBvdGhlciBgTWF0dGVyLkNvbXBvc2l0ZWAgb2JqZWN0cy5cbipcbiogVGhleSBhcmUgYSBjb250YWluZXIgdGhhdCBjYW4gcmVwcmVzZW50IGNvbXBsZXggb2JqZWN0cyBtYWRlIG9mIG11bHRpcGxlIHBhcnRzLCBldmVuIGlmIHRoZXkgYXJlIG5vdCBwaHlzaWNhbGx5IGNvbm5lY3RlZC5cbiogQSBjb21wb3NpdGUgY291bGQgY29udGFpbiBhbnl0aGluZyBmcm9tIGEgc2luZ2xlIGJvZHkgYWxsIHRoZSB3YXkgdXAgdG8gYSB3aG9sZSB3b3JsZC5cbiogXG4qIFdoZW4gbWFraW5nIGFueSBjaGFuZ2VzIHRvIGNvbXBvc2l0ZXMsIHVzZSB0aGUgaW5jbHVkZWQgZnVuY3Rpb25zIHJhdGhlciB0aGFuIGNoYW5naW5nIHRoZWlyIHByb3BlcnRpZXMgZGlyZWN0bHkuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb21wb3NpdGVcbiovXG5cbnZhciBDb21wb3NpdGUgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGU7XG5cbnZhciBFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBCb2R5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb21wb3NpdGUuIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVyaXRlcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge30gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGVcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZCh7IFxuICAgICAgICAgICAgaWQ6IENvbW1vbi5uZXh0SWQoKSxcbiAgICAgICAgICAgIHR5cGU6ICdjb21wb3NpdGUnLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgaXNNb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICBib2RpZXM6IFtdLCBcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBbXSwgXG4gICAgICAgICAgICBjb21wb3NpdGVzOiBbXSxcbiAgICAgICAgICAgIGxhYmVsOiAnQ29tcG9zaXRlJyxcbiAgICAgICAgICAgIHBsdWdpbjoge30sXG4gICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgIGFsbEJvZGllczogbnVsbCxcbiAgICAgICAgICAgICAgICBhbGxDb25zdHJhaW50czogbnVsbCxcbiAgICAgICAgICAgICAgICBhbGxDb21wb3NpdGVzOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wb3NpdGUncyBgaXNNb2RpZmllZGAgZmxhZy4gXG4gICAgICogSWYgYHVwZGF0ZVBhcmVudHNgIGlzIHRydWUsIGFsbCBwYXJlbnRzIHdpbGwgYmUgc2V0IChkZWZhdWx0OiBmYWxzZSkuXG4gICAgICogSWYgYHVwZGF0ZUNoaWxkcmVuYCBpcyB0cnVlLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBzZXQgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2Qgc2V0TW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc01vZGlmaWVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlUGFyZW50cz1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVDaGlsZHJlbj1mYWxzZV1cbiAgICAgKi9cbiAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGlzTW9kaWZpZWQsIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5pc01vZGlmaWVkID0gaXNNb2RpZmllZDtcblxuICAgICAgICBpZiAoaXNNb2RpZmllZCAmJiBjb21wb3NpdGUuY2FjaGUpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5jYWNoZS5hbGxCb2RpZXMgPSBudWxsO1xuICAgICAgICAgICAgY29tcG9zaXRlLmNhY2hlLmFsbENvbnN0cmFpbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5jYWNoZS5hbGxDb21wb3NpdGVzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVQYXJlbnRzICYmIGNvbXBvc2l0ZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUucGFyZW50LCBpc01vZGlmaWVkLCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb21wb3NpdGUgPSBjb21wb3NpdGUuY29tcG9zaXRlc1tpXTtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY2hpbGRDb21wb3NpdGUsIGlzTW9kaWZpZWQsIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmljIHNpbmdsZSBvciBtdWx0aS1hZGQgZnVuY3Rpb24uIEFkZHMgYSBzaW5nbGUgb3IgYW4gYXJyYXkgb2YgYm9keShzKSwgY29uc3RyYWludChzKSBvciBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlQWRkYCBhbmQgYGFmdGVyQWRkYCBldmVudHMgb24gdGhlIGBjb21wb3NpdGVgLlxuICAgICAqIEBtZXRob2QgYWRkXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fSBvYmplY3QgQSBzaW5nbGUgb3IgYW4gYXJyYXkgb2YgYm9keShzKSwgY29uc3RyYWludChzKSBvciBjb21wb3NpdGUocylcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGQgPSBmdW5jdGlvbihjb21wb3NpdGUsIG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqZWN0cyA9IFtdLmNvbmNhdChvYmplY3QpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGNvbXBvc2l0ZSwgJ2JlZm9yZUFkZCcsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0c1tpXTtcblxuICAgICAgICAgICAgc3dpdGNoIChvYmoudHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgICAgICAvLyBza2lwIGFkZGluZyBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChvYmoucGFyZW50ICE9PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ0NvbXBvc2l0ZS5hZGQ6IHNraXBwZWQgYWRkaW5nIGEgY29tcG91bmQgYm9keSBwYXJ0ICh5b3UgbXVzdCBhZGQgaXRzIHBhcmVudCBpbnN0ZWFkKScpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUoY29tcG9zaXRlLCBvYmopO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW91c2VDb25zdHJhaW50JzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIG9iai5jb25zdHJhaW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYWZ0ZXJBZGQnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgcmVtb3ZlIGZ1bmN0aW9uLiBSZW1vdmVzIG9uZSBvciBtYW55IGJvZHkocyksIGNvbnN0cmFpbnQocykgb3IgYSBjb21wb3NpdGUocykgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBPcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVJlbW92ZWAgYW5kIGBhZnRlclJlbW92ZWAgZXZlbnRzIG9uIHRoZSBgY29tcG9zaXRlYC5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdHxhcnJheX0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgb2JqZWN0cyByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0LCBkZWVwKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gW10uY29uY2F0KG9iamVjdCk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlUmVtb3ZlJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGUsIG9iaiwgZGVlcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZUNvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlclJlbW92ZScsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXBvc2l0ZSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRDb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBvYmplY3RzIGZyb20gY29tcG9zaXRlQiBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGRDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCKSB7XG4gICAgICAgIGNvbXBvc2l0ZUEuY29tcG9zaXRlcy5wdXNoKGNvbXBvc2l0ZUIpO1xuICAgICAgICBjb21wb3NpdGVCLnBhcmVudCA9IGNvbXBvc2l0ZUE7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGVBLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgYW5kIG9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlQSB3aXRoIHRoZSBjb21wb3NpdGUgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBjb21wb3NpdGVCLCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZUEuY29tcG9zaXRlcywgY29tcG9zaXRlQik7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlQik7XG5cbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGVBdChjb21wb3NpdGVBLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwQ291bnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGVBLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb21wb3NpdGUoY29tcG9zaXRlQS5jb21wb3NpdGVzW2ldLCBjb21wb3NpdGVCLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9zaXRlIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29tcG9zaXRlQXRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbXBvc2l0ZSByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZUF0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBwb3NpdGlvbikge1xuICAgICAgICBjb21wb3NpdGUuY29tcG9zaXRlcy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBib2R5IHRvIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGFkZEJvZHlcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgYWRkZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWRkQm9keSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgYm9keSkge1xuICAgICAgICBjb21wb3NpdGUuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBhbmQgb3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBib2R5LCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZS5ib2RpZXMsIGJvZHkpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5QXQoY29tcG9zaXRlLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHkoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGJvZHksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5QXRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5QXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29uc3RyYWludCB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb25zdHJhaW50IGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnN0cmFpbnQgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBhbmQgb3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBjb25zdHJhaW50LCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZS5jb25zdHJhaW50cywgY29uc3RyYWludCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludEF0KGNvbXBvc2l0ZSwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50KGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldLCBjb25zdHJhaW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBib2R5IGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludEF0XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb25zdHJhaW50IHJlbW92ZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmVtb3ZlQ29uc3RyYWludEF0ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBwb3NpdGlvbikge1xuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBjb21wb3NpdGVzIGZyb20gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBPcHRpb25hbGx5IGNsZWFyaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN0YXRpY1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmNsZWFyID0gZnVuY3Rpb24oY29tcG9zaXRlLCBrZWVwU3RhdGljLCBkZWVwKSB7XG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuY2xlYXIoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGtlZXBTdGF0aWMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoa2VlcFN0YXRpYykge1xuICAgICAgICAgICAgY29tcG9zaXRlLmJvZGllcyA9IGNvbXBvc2l0ZS5ib2RpZXMuZmlsdGVyKGZ1bmN0aW9uKGJvZHkpIHsgcmV0dXJuIGJvZHkuaXNTdGF0aWM7IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9zaXRlLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBpbmNsdWRpbmcgYWxsIGJvZGllcyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgYWxsQm9kaWVzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge2JvZHlbXX0gQWxsIHRoZSBib2RpZXNcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWxsQm9kaWVzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGUuY2FjaGUgJiYgY29tcG9zaXRlLmNhY2hlLmFsbEJvZGllcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZS5jYWNoZS5hbGxCb2RpZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYm9kaWVzID0gW10uY29uY2F0KGNvbXBvc2l0ZS5ib2RpZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBib2RpZXMgPSBib2RpZXMuY29uY2F0KENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcblxuICAgICAgICBpZiAoY29tcG9zaXRlLmNhY2hlKSB7XG4gICAgICAgICAgICBjb21wb3NpdGUuY2FjaGUuYWxsQm9kaWVzID0gYm9kaWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZGllcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY29uc3RyYWludHMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb25zdHJhaW50cyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgYWxsQ29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29uc3RyYWludFtdfSBBbGwgdGhlIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XG4gICAgICAgIGlmIChjb21wb3NpdGUuY2FjaGUgJiYgY29tcG9zaXRlLmNhY2hlLmFsbENvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlLmNhY2hlLmFsbENvbnN0cmFpbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW10uY29uY2F0KGNvbXBvc2l0ZS5jb25zdHJhaW50cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xuXG4gICAgICAgIGlmIChjb21wb3NpdGUuY2FjaGUpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5jYWNoZS5hbGxDb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjb21wb3NpdGVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUsIGluY2x1ZGluZyBhbGwgY29tcG9zaXRlcyBpbiBpdHMgY2hpbGRyZW4sIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgYWxsQ29tcG9zaXRlc1xuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGVbXX0gQWxsIHRoZSBjb21wb3NpdGVzXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZS5jYWNoZSAmJiBjb21wb3NpdGUuY2FjaGUuYWxsQ29tcG9zaXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZS5jYWNoZS5hbGxDb21wb3NpdGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbXBvc2l0ZXMgPSBbXS5jb25jYXQoY29tcG9zaXRlLmNvbXBvc2l0ZXMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb21wb3NpdGVzID0gY29tcG9zaXRlcy5jb25jYXQoQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXMoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0pKTtcblxuICAgICAgICBpZiAoY29tcG9zaXRlLmNhY2hlKSB7XG4gICAgICAgICAgICBjb21wb3NpdGUuY2FjaGUuYWxsQ29tcG9zaXRlcyA9IGNvbXBvc2l0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNvbXBvc2l0ZSByZWN1cnNpdmVseSBmb3IgYW4gb2JqZWN0IG1hdGNoaW5nIHRoZSB0eXBlIGFuZCBpZCBzdXBwbGllZCwgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSByZXF1ZXN0ZWQgb2JqZWN0LCBpZiBmb3VuZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5nZXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGlkLCB0eXBlKSB7XG4gICAgICAgIHZhciBvYmplY3RzLFxuICAgICAgICAgICAgb2JqZWN0O1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XG4gICAgICAgICAgICBvYmplY3RzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29tcG9zaXRlJzpcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUpLmNvbmNhdChjb21wb3NpdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iamVjdHMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBvYmplY3QgPSBvYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHsgXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0LmlkLnRvU3RyaW5nKCkgPT09IGlkLnRvU3RyaW5nKCk7IFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2JqZWN0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiBvYmplY3RbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBnaXZlbiBvYmplY3QocykgZnJvbSBjb21wb3NpdGVBIHRvIGNvbXBvc2l0ZUIgKGVxdWFsIHRvIGEgcmVtb3ZlIGZvbGxvd2VkIGJ5IGFuIGFkZCkuXG4gICAgICogQG1ldGhvZCBtb3ZlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGVBfSBjb21wb3NpdGVBXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlQn0gY29tcG9zaXRlQlxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gUmV0dXJucyBjb21wb3NpdGVBXG4gICAgICovXG4gICAgQ29tcG9zaXRlLm1vdmUgPSBmdW5jdGlvbihjb21wb3NpdGVBLCBvYmplY3RzLCBjb21wb3NpdGVCKSB7XG4gICAgICAgIENvbXBvc2l0ZS5yZW1vdmUoY29tcG9zaXRlQSwgb2JqZWN0cyk7XG4gICAgICAgIENvbXBvc2l0ZS5hZGQoY29tcG9zaXRlQiwgb2JqZWN0cyk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVBO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG5ldyBpZHMgZm9yIGFsbCBvYmplY3RzIGluIHRoZSBjb21wb3NpdGUsIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgcmViYXNlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gUmV0dXJucyBjb21wb3NpdGVcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmViYXNlID0gZnVuY3Rpb24oY29tcG9zaXRlKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpXG4gICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyhjb21wb3NpdGUpKVxuICAgICAgICAgICAgLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUpKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iamVjdHNbaV0uaWQgPSBDb21tb24ubmV4dElkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIHRoZWlyIGN1cnJlbnQgcG9zaXRpb25zLCBcbiAgICAgKiB3aXRob3V0IGltcGFydGluZyBhbnkgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgdHJhbnNsYXRpb24sIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQm9keS50cmFuc2xhdGUoYm9kaWVzW2ldLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlIGJ5IGEgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIGdpdmVuIHBvaW50LCB3aXRob3V0IGltcGFydGluZyBhbnkgYW5ndWxhciB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtyZWN1cnNpdmU9dHJ1ZV1cbiAgICAgKi9cbiAgICBDb21wb3NpdGUucm90YXRlID0gZnVuY3Rpb24oY29tcG9zaXRlLCByb3RhdGlvbiwgcG9pbnQsIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3Mocm90YXRpb24pLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocm90YXRpb24pLFxuICAgICAgICAgICAgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyAoZHggKiBjb3MgLSBkeSAqIHNpbiksXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIChkeCAqIHNpbiArIGR5ICogY29zKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIEJvZHkucm90YXRlKGJvZHksIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbGwgY2hpbGRyZW4gaW4gdGhlIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIHVwZGF0aW5nIHBoeXNpY2FsIHByb3BlcnRpZXMgKG1hc3MsIGFyZWEsIGF4ZXMsIGluZXJ0aWEpLCBmcm9tIGEgd29ybGQtc3BhY2UgcG9pbnQuXG4gICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW3JlY3Vyc2l2ZT10cnVlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5zY2FsZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgc2NhbGVYLCBzY2FsZVksIHBvaW50LCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IHJlY3Vyc2l2ZSA/IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSA6IGNvbXBvc2l0ZS5ib2RpZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgZHggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIGR5ICogc2NhbGVZXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgQm9keS5zY2FsZShib2R5LCBzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlvbiBvZiB0aGUgYm91bmRzIG9mIGFsbCBvZiB0aGUgY29tcG9zaXRlJ3MgYm9kaWVzLlxuICAgICAqIEBtZXRob2QgYm91bmRzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZSBUaGUgY29tcG9zaXRlLlxuICAgICAqIEByZXR1cm5zIHtib3VuZHN9IFRoZSBjb21wb3NpdGUgYm91bmRzLlxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5ib3VuZHMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKSxcbiAgICAgICAgICAgIHZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChib2R5LmJvdW5kcy5taW4sIGJvZHkuYm91bmRzLm1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm91bmRzLmNyZWF0ZSh2ZXJ0aWNlcyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBjYWxsIHRvIGBDb21wb3NpdGUuYWRkYCBpcyBtYWRlLCBiZWZvcmUgb2JqZWN0cyBoYXZlIGJlZW4gYWRkZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZUFkZFxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRvIGJlIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5hZGRgIGlzIG1hZGUsIGFmdGVyIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICpcbiAgICAqIEBldmVudCBhZnRlckFkZFxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5yZW1vdmVgIGlzIG1hZGUsIGJlZm9yZSBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVSZW1vdmVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0byBiZSByZW1vdmVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5yZW1vdmVgIGlzIG1hZGUsIGFmdGVyIG9iamVjdHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVtb3ZlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCAobWF5IGJlIGEgc2luZ2xlIGJvZHksIGNvbnN0cmFpbnQsIGNvbXBvc2l0ZSBvciBhIG1peGVkIGFycmF5IG9mIHRoZXNlKVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQ29tcG9zaXRlLmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJjb21wb3NpdGVcIlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJiaXRyYXJ5IGBTdHJpbmdgIG5hbWUgdG8gaGVscCB0aGUgdXNlciBpZGVudGlmeSBhbmQgbWFuYWdlIGNvbXBvc2l0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkNvbXBvc2l0ZVwiXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgY29tcG9zaXRlIGhhcyBiZWVuIG1vZGlmaWVkIGR1cmluZyB0aGUgY3VycmVudCBzdGVwLlxuICAgICAqIFRoaXMgaXMgYXV0b21hdGljYWxseSBtYW5hZ2VkIHdoZW4gYm9kaWVzLCBjb25zdHJhaW50cyBvciBjb21wb3NpdGVzIGFyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlzTW9kaWZpZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBgQ29tcG9zaXRlYCB0aGF0IGlzIHRoZSBwYXJlbnQgb2YgdGhpcyBjb21wb3NpdGUuIEl0IGlzIGF1dG9tYXRpY2FsbHkgbWFuYWdlZCBieSB0aGUgYE1hdHRlci5Db21wb3NpdGVgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50XG4gICAgICogQHR5cGUgY29tcG9zaXRlXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYEJvZHlgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgYm9kaWVzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbEJvZGllc2AgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIGJvZHlbXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBgQ29uc3RyYWludGAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb25zdHJhaW50cyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxDb25zdHJhaW50c2AgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUgY29uc3RyYWludFtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBDb21wb3NpdGVgIHRoYXQgYXJlIF9kaXJlY3RfIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9zaXRlLlxuICAgICAqIFRvIGFkZCBvciByZW1vdmUgY29tcG9zaXRlcyB5b3Ugc2hvdWxkIHVzZSBgQ29tcG9zaXRlLmFkZGAgYW5kIGBDb21wb3NpdGUucmVtb3ZlYCBtZXRob2RzIHJhdGhlciB0aGFuIGRpcmVjdGx5IG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LlxuICAgICAqIElmIHlvdSB3aXNoIHRvIHJlY3Vyc2l2ZWx5IGZpbmQgYWxsIGRlc2NlbmRhbnRzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29tcG9zaXRlc1xuICAgICAqIEB0eXBlIGNvbXBvc2l0ZVtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgZm9yIHN0b3JpbmcgY2FjaGVkIHJlc3VsdHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgb25seSBhbmQgaXMgYXV0b21hdGljYWxseSBtYW5hZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgY2FjaGVcbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuU2xlZXBpbmdgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIHRvIG1hbmFnZSB0aGUgc2xlZXBpbmcgc3RhdGUgb2YgYm9kaWVzLlxuKlxuKiBAY2xhc3MgU2xlZXBpbmdcbiovXG5cbnZhciBTbGVlcGluZyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsZWVwaW5nO1xuXG52YXIgQm9keSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgRXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBTbGVlcGluZy5fbW90aW9uV2FrZVRocmVzaG9sZCA9IDAuMTg7XG4gICAgU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkID0gMC4wODtcbiAgICBTbGVlcGluZy5fbWluQmlhcyA9IDAuOTtcblxuICAgIC8qKlxuICAgICAqIFB1dHMgYm9kaWVzIHRvIHNsZWVwIG9yIHdha2VzIHRoZW0gdXAgZGVwZW5kaW5nIG9uIHRoZWlyIG1vdGlvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBTbGVlcGluZy51cGRhdGUgPSBmdW5jdGlvbihib2RpZXMsIGRlbHRhKSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBkZWx0YSAvIENvbW1vbi5fYmFzZURlbHRhLFxuICAgICAgICAgICAgbW90aW9uU2xlZXBUaHJlc2hvbGQgPSBTbGVlcGluZy5fbW90aW9uU2xlZXBUaHJlc2hvbGQ7XG4gICAgICAgIFxuICAgICAgICAvLyB1cGRhdGUgYm9kaWVzIHNsZWVwaW5nIHN0YXR1c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgc3BlZWQgPSBCb2R5LmdldFNwZWVkKGJvZHkpLFxuICAgICAgICAgICAgICAgIGFuZ3VsYXJTcGVlZCA9IEJvZHkuZ2V0QW5ndWxhclNwZWVkKGJvZHkpLFxuICAgICAgICAgICAgICAgIG1vdGlvbiA9IHNwZWVkICogc3BlZWQgKyBhbmd1bGFyU3BlZWQgKiBhbmd1bGFyU3BlZWQ7XG5cbiAgICAgICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGlmIHRoZXkgaGF2ZSBhIGZvcmNlIGFwcGxpZWRcbiAgICAgICAgICAgIGlmIChib2R5LmZvcmNlLnggIT09IDAgfHwgYm9keS5mb3JjZS55ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgU2xlZXBpbmcuc2V0KGJvZHksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1pbk1vdGlvbiA9IE1hdGgubWluKGJvZHkubW90aW9uLCBtb3Rpb24pLFxuICAgICAgICAgICAgICAgIG1heE1vdGlvbiA9IE1hdGgubWF4KGJvZHkubW90aW9uLCBtb3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGJpYXNlZCBhdmVyYWdlIG1vdGlvbiBlc3RpbWF0aW9uIGJldHdlZW4gZnJhbWVzXG4gICAgICAgICAgICBib2R5Lm1vdGlvbiA9IFNsZWVwaW5nLl9taW5CaWFzICogbWluTW90aW9uICsgKDEgLSBTbGVlcGluZy5fbWluQmlhcykgKiBtYXhNb3Rpb247XG5cbiAgICAgICAgICAgIGlmIChib2R5LnNsZWVwVGhyZXNob2xkID4gMCAmJiBib2R5Lm1vdGlvbiA8IG1vdGlvblNsZWVwVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5zbGVlcENvdW50ZXIgPj0gYm9keS5zbGVlcFRocmVzaG9sZCAvIHRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChib2R5LnNsZWVwQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2V0IG9mIGNvbGxpZGluZyBwYWlycywgd2FrZXMgdGhlIHNsZWVwaW5nIGJvZGllcyBpbnZvbHZlZC5cbiAgICAgKiBAbWV0aG9kIGFmdGVyQ29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFNsZWVwaW5nLmFmdGVyQ29sbGlzaW9ucyA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgICAgIHZhciBtb3Rpb25TbGVlcFRocmVzaG9sZCA9IFNsZWVwaW5nLl9tb3Rpb25TbGVlcFRocmVzaG9sZDtcblxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGRvbid0IHdha2UgaW5hY3RpdmUgcGFpcnNcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBLnBhcmVudCwgXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUIucGFyZW50O1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIGRvbid0IHdha2UgaWYgYXQgbGVhc3Qgb25lIGJvZHkgaXMgc3RhdGljXG4gICAgICAgICAgICBpZiAoKGJvZHlBLmlzU2xlZXBpbmcgJiYgYm9keUIuaXNTbGVlcGluZykgfHwgYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU2xlZXBpbmcgfHwgYm9keUIuaXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIHZhciBzbGVlcGluZ0JvZHkgPSAoYm9keUEuaXNTbGVlcGluZyAmJiAhYm9keUEuaXNTdGF0aWMpID8gYm9keUEgOiBib2R5QixcbiAgICAgICAgICAgICAgICAgICAgbW92aW5nQm9keSA9IHNsZWVwaW5nQm9keSA9PT0gYm9keUEgPyBib2R5QiA6IGJvZHlBO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzbGVlcGluZ0JvZHkuaXNTdGF0aWMgJiYgbW92aW5nQm9keS5tb3Rpb24gPiBtb3Rpb25TbGVlcFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoc2xlZXBpbmdCb2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgXG4gICAgLyoqXG4gICAgICogU2V0IGEgYm9keSBhcyBzbGVlcGluZyBvciBhd2FrZS5cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTbGVlcGluZ1xuICAgICAqL1xuICAgIFNsZWVwaW5nLnNldCA9IGZ1bmN0aW9uKGJvZHksIGlzU2xlZXBpbmcpIHtcbiAgICAgICAgdmFyIHdhc1NsZWVwaW5nID0gYm9keS5pc1NsZWVwaW5nO1xuXG4gICAgICAgIGlmIChpc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICBib2R5LmlzU2xlZXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYm9keS5zbGVlcENvdW50ZXIgPSBib2R5LnNsZWVwVGhyZXNob2xkO1xuXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnkgPSAwO1xuXG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueTtcblxuICAgICAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlO1xuICAgICAgICAgICAgYm9keS5zcGVlZCA9IDA7XG4gICAgICAgICAgICBib2R5LmFuZ3VsYXJTcGVlZCA9IDA7XG4gICAgICAgICAgICBib2R5Lm1vdGlvbiA9IDA7XG5cbiAgICAgICAgICAgIGlmICghd2FzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihib2R5LCAnc2xlZXBTdGFydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5pc1NsZWVwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciA9IDA7XG5cbiAgICAgICAgICAgIGlmICh3YXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGJvZHksICdzbGVlcEVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkNvbGxpc2lvbmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGRldGVjdGluZyBjb2xsaXNpb25zIGJldHdlZW4gYSBnaXZlbiBwYWlyIG9mIGJvZGllcy5cbipcbiogRm9yIGVmZmljaWVudCBkZXRlY3Rpb24gYmV0d2VlbiBhIGxpc3Qgb2YgYm9kaWVzLCBzZWUgYE1hdHRlci5EZXRlY3RvcmAgYW5kIGBNYXR0ZXIuUXVlcnlgLlxuKlxuKiBTZWUgYE1hdHRlci5FbmdpbmVgIGZvciBjb2xsaXNpb24gZXZlbnRzLlxuKlxuKiBAY2xhc3MgQ29sbGlzaW9uXG4qL1xuXG52YXIgQ29sbGlzaW9uID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uO1xuXG52YXIgVmVydGljZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIFBhaXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9zdXBwb3J0cyA9IFtdO1xuXG4gICAgdmFyIF9vdmVybGFwQUIgPSB7XG4gICAgICAgIG92ZXJsYXA6IDAsXG4gICAgICAgIGF4aXM6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9vdmVybGFwQkEgPSB7XG4gICAgICAgIG92ZXJsYXA6IDAsXG4gICAgICAgIGF4aXM6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xsaXNpb24gcmVjb3JkLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QSBUaGUgZmlyc3QgYm9keSBwYXJ0IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gcmVjb3JkXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QiBUaGUgc2Vjb25kIGJvZHkgcGFydCByZXByZXNlbnRlZCBieSB0aGUgY29sbGlzaW9uIHJlY29yZFxuICAgICAqIEByZXR1cm4ge2NvbGxpc2lvbn0gQSBuZXcgY29sbGlzaW9uIHJlY29yZFxuICAgICAqL1xuICAgIENvbGxpc2lvbi5jcmVhdGUgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpIHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBwYWlyOiBudWxsLFxuICAgICAgICAgICAgY29sbGlkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYm9keUE6IGJvZHlBLFxuICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxuICAgICAgICAgICAgcGFyZW50QTogYm9keUEucGFyZW50LFxuICAgICAgICAgICAgcGFyZW50QjogYm9keUIucGFyZW50LFxuICAgICAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgICAgICBub3JtYWw6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdGFuZ2VudDogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBwZW5ldHJhdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBzdXBwb3J0czogW251bGwsIG51bGxdLFxuICAgICAgICAgICAgc3VwcG9ydENvdW50OiAwXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlBXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QlxuICAgICAqIEBwYXJhbSB7cGFpcnN9IFtwYWlyc10gT3B0aW9uYWxseSByZXVzZSBjb2xsaXNpb24gcmVjb3JkcyBmcm9tIGV4aXN0aW5nIHBhaXJzLlxuICAgICAqIEByZXR1cm4ge2NvbGxpc2lvbnxudWxsfSBBIGNvbGxpc2lvbiByZWNvcmQgaWYgZGV0ZWN0ZWQsIG90aGVyd2lzZSBudWxsXG4gICAgICovXG4gICAgQ29sbGlzaW9uLmNvbGxpZGVzID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBwYWlycykge1xuICAgICAgICBDb2xsaXNpb24uX292ZXJsYXBBeGVzKF9vdmVybGFwQUIsIGJvZHlBLnZlcnRpY2VzLCBib2R5Qi52ZXJ0aWNlcywgYm9keUEuYXhlcyk7XG5cbiAgICAgICAgaWYgKF9vdmVybGFwQUIub3ZlcmxhcCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIENvbGxpc2lvbi5fb3ZlcmxhcEF4ZXMoX292ZXJsYXBCQSwgYm9keUIudmVydGljZXMsIGJvZHlBLnZlcnRpY2VzLCBib2R5Qi5heGVzKTtcblxuICAgICAgICBpZiAoX292ZXJsYXBCQS5vdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV1c2UgY29sbGlzaW9uIHJlY29yZHMgZm9yIGdjIGVmZmljaWVuY3lcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlycyAmJiBwYWlycy50YWJsZVtQYWlyLmlkKGJvZHlBLCBib2R5QildLFxuICAgICAgICAgICAgY29sbGlzaW9uO1xuXG4gICAgICAgIGlmICghcGFpcikge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gQ29sbGlzaW9uLmNyZWF0ZShib2R5QSwgYm9keUIpO1xuICAgICAgICAgICAgY29sbGlzaW9uLmNvbGxpZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbGxpc2lvbi5ib2R5QSA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QSA6IGJvZHlCO1xuICAgICAgICAgICAgY29sbGlzaW9uLmJvZHlCID0gYm9keUEuaWQgPCBib2R5Qi5pZCA/IGJvZHlCIDogYm9keUE7XG4gICAgICAgICAgICBjb2xsaXNpb24ucGFyZW50QSA9IGNvbGxpc2lvbi5ib2R5QS5wYXJlbnQ7XG4gICAgICAgICAgICBjb2xsaXNpb24ucGFyZW50QiA9IGNvbGxpc2lvbi5ib2R5Qi5wYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBO1xuICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5QjtcblxuICAgICAgICB2YXIgbWluT3ZlcmxhcDtcblxuICAgICAgICBpZiAoX292ZXJsYXBBQi5vdmVybGFwIDwgX292ZXJsYXBCQS5vdmVybGFwKSB7XG4gICAgICAgICAgICBtaW5PdmVybGFwID0gX292ZXJsYXBBQjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBfb3ZlcmxhcEJBO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWwsXG4gICAgICAgICAgICB0YW5nZW50ID0gY29sbGlzaW9uLnRhbmdlbnQsXG4gICAgICAgICAgICBwZW5ldHJhdGlvbiA9IGNvbGxpc2lvbi5wZW5ldHJhdGlvbixcbiAgICAgICAgICAgIHN1cHBvcnRzID0gY29sbGlzaW9uLnN1cHBvcnRzLFxuICAgICAgICAgICAgZGVwdGggPSBtaW5PdmVybGFwLm92ZXJsYXAsXG4gICAgICAgICAgICBtaW5BeGlzID0gbWluT3ZlcmxhcC5heGlzLFxuICAgICAgICAgICAgbm9ybWFsWCA9IG1pbkF4aXMueCxcbiAgICAgICAgICAgIG5vcm1hbFkgPSBtaW5BeGlzLnksXG4gICAgICAgICAgICBkZWx0YVggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb24ueCxcbiAgICAgICAgICAgIGRlbHRhWSA9IGJvZHlCLnBvc2l0aW9uLnkgLSBib2R5QS5wb3NpdGlvbi55O1xuXG4gICAgICAgIC8vIGVuc3VyZSBub3JtYWwgaXMgZmFjaW5nIGF3YXkgZnJvbSBib2R5QVxuICAgICAgICBpZiAobm9ybWFsWCAqIGRlbHRhWCArIG5vcm1hbFkgKiBkZWx0YVkgPj0gMCkge1xuICAgICAgICAgICAgbm9ybWFsWCA9IC1ub3JtYWxYO1xuICAgICAgICAgICAgbm9ybWFsWSA9IC1ub3JtYWxZO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsLnggPSBub3JtYWxYO1xuICAgICAgICBub3JtYWwueSA9IG5vcm1hbFk7XG4gICAgICAgIFxuICAgICAgICB0YW5nZW50LnggPSAtbm9ybWFsWTtcbiAgICAgICAgdGFuZ2VudC55ID0gbm9ybWFsWDtcblxuICAgICAgICBwZW5ldHJhdGlvbi54ID0gbm9ybWFsWCAqIGRlcHRoO1xuICAgICAgICBwZW5ldHJhdGlvbi55ID0gbm9ybWFsWSAqIGRlcHRoO1xuXG4gICAgICAgIGNvbGxpc2lvbi5kZXB0aCA9IGRlcHRoO1xuXG4gICAgICAgIC8vIGZpbmQgc3VwcG9ydCBwb2ludHMsIHRoZXJlIGlzIGFsd2F5cyBlaXRoZXIgZXhhY3RseSBvbmUgb3IgdHdvXG4gICAgICAgIHZhciBzdXBwb3J0c0IgPSBDb2xsaXNpb24uX2ZpbmRTdXBwb3J0cyhib2R5QSwgYm9keUIsIG5vcm1hbCwgMSksXG4gICAgICAgICAgICBzdXBwb3J0Q291bnQgPSAwO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHN1cHBvcnRzIGZyb20gYm9keUIgdGhhdCBhcmUgaW5zaWRlIGJvZHlBXG4gICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5QS52ZXJ0aWNlcywgc3VwcG9ydHNCWzBdKSkge1xuICAgICAgICAgICAgc3VwcG9ydHNbc3VwcG9ydENvdW50KytdID0gc3VwcG9ydHNCWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCBzdXBwb3J0c0JbMV0pKSB7XG4gICAgICAgICAgICBzdXBwb3J0c1tzdXBwb3J0Q291bnQrK10gPSBzdXBwb3J0c0JbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBzdXBwb3J0cyBmcm9tIGJvZHlBIHRoYXQgYXJlIGluc2lkZSBib2R5QlxuICAgICAgICBpZiAoc3VwcG9ydENvdW50IDwgMikge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRzQSA9IENvbGxpc2lvbi5fZmluZFN1cHBvcnRzKGJvZHlCLCBib2R5QSwgbm9ybWFsLCAtMSk7XG5cbiAgICAgICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5Qi52ZXJ0aWNlcywgc3VwcG9ydHNBWzBdKSkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzW3N1cHBvcnRDb3VudCsrXSA9IHN1cHBvcnRzQVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRDb3VudCA8IDIgJiYgVmVydGljZXMuY29udGFpbnMoYm9keUIudmVydGljZXMsIHN1cHBvcnRzQVsxXSkpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1tzdXBwb3J0Q291bnQrK10gPSBzdXBwb3J0c0FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgZWRnZSBjYXNlIG9mIG92ZXJsYXBwaW5nIGJ1dCBubyB2ZXJ0ZXggY29udGFpbm1lbnRcbiAgICAgICAgaWYgKHN1cHBvcnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3VwcG9ydHNbc3VwcG9ydENvdW50KytdID0gc3VwcG9ydHNCWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHN1cHBvcnQgY291bnRcbiAgICAgICAgY29sbGlzaW9uLnN1cHBvcnRDb3VudCA9IHN1cHBvcnRDb3VudDtcblxuICAgICAgICByZXR1cm4gY29sbGlzaW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvdmVybGFwIGJldHdlZW4gdHdvIHNldHMgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBfb3ZlcmxhcEF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXN1bHRcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc0FcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc0JcbiAgICAgKiBAcGFyYW0ge2F4ZXN9IGF4ZXNcbiAgICAgKi9cbiAgICBDb2xsaXNpb24uX292ZXJsYXBBeGVzID0gZnVuY3Rpb24ocmVzdWx0LCB2ZXJ0aWNlc0EsIHZlcnRpY2VzQiwgYXhlcykge1xuICAgICAgICB2YXIgdmVydGljZXNBTGVuZ3RoID0gdmVydGljZXNBLmxlbmd0aCxcbiAgICAgICAgICAgIHZlcnRpY2VzQkxlbmd0aCA9IHZlcnRpY2VzQi5sZW5ndGgsXG4gICAgICAgICAgICB2ZXJ0aWNlc0FYID0gdmVydGljZXNBWzBdLngsXG4gICAgICAgICAgICB2ZXJ0aWNlc0FZID0gdmVydGljZXNBWzBdLnksXG4gICAgICAgICAgICB2ZXJ0aWNlc0JYID0gdmVydGljZXNCWzBdLngsXG4gICAgICAgICAgICB2ZXJ0aWNlc0JZID0gdmVydGljZXNCWzBdLnksXG4gICAgICAgICAgICBheGVzTGVuZ3RoID0gYXhlcy5sZW5ndGgsXG4gICAgICAgICAgICBvdmVybGFwTWluID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG92ZXJsYXBBeGlzTnVtYmVyID0gMCxcbiAgICAgICAgICAgIG92ZXJsYXAsXG4gICAgICAgICAgICBvdmVybGFwQUIsXG4gICAgICAgICAgICBvdmVybGFwQkEsXG4gICAgICAgICAgICBkb3QsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXhlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbaV0sXG4gICAgICAgICAgICAgICAgYXhpc1ggPSBheGlzLngsXG4gICAgICAgICAgICAgICAgYXhpc1kgPSBheGlzLnksXG4gICAgICAgICAgICAgICAgbWluQSA9IHZlcnRpY2VzQVggKiBheGlzWCArIHZlcnRpY2VzQVkgKiBheGlzWSxcbiAgICAgICAgICAgICAgICBtaW5CID0gdmVydGljZXNCWCAqIGF4aXNYICsgdmVydGljZXNCWSAqIGF4aXNZLFxuICAgICAgICAgICAgICAgIG1heEEgPSBtaW5BLFxuICAgICAgICAgICAgICAgIG1heEIgPSBtaW5CO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgdmVydGljZXNBTGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkb3QgPSB2ZXJ0aWNlc0Fbal0ueCAqIGF4aXNYICsgdmVydGljZXNBW2pdLnkgKiBheGlzWTtcblxuICAgICAgICAgICAgICAgIGlmIChkb3QgPiBtYXhBKSB7IFxuICAgICAgICAgICAgICAgICAgICBtYXhBID0gZG90O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG90IDwgbWluQSkgeyBcbiAgICAgICAgICAgICAgICAgICAgbWluQSA9IGRvdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCB2ZXJ0aWNlc0JMZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGRvdCA9IHZlcnRpY2VzQltqXS54ICogYXhpc1ggKyB2ZXJ0aWNlc0Jbal0ueSAqIGF4aXNZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvdCA+IG1heEIpIHsgXG4gICAgICAgICAgICAgICAgICAgIG1heEIgPSBkb3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb3QgPCBtaW5CKSB7IFxuICAgICAgICAgICAgICAgICAgICBtaW5CID0gZG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3ZlcmxhcEFCID0gbWF4QSAtIG1pbkI7XG4gICAgICAgICAgICBvdmVybGFwQkEgPSBtYXhCIC0gbWluQTtcbiAgICAgICAgICAgIG92ZXJsYXAgPSBvdmVybGFwQUIgPCBvdmVybGFwQkEgPyBvdmVybGFwQUIgOiBvdmVybGFwQkE7XG5cbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgb3ZlcmxhcE1pbikge1xuICAgICAgICAgICAgICAgIG92ZXJsYXBNaW4gPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIG92ZXJsYXBBeGlzTnVtYmVyID0gaTtcblxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG5vdCBiZSBpbnRlcnNlY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5heGlzID0gYXhlc1tvdmVybGFwQXhpc051bWJlcl07XG4gICAgICAgIHJlc3VsdC5vdmVybGFwID0gb3ZlcmxhcE1pbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgc3VwcG9ydGluZyB2ZXJ0aWNlcyBnaXZlbiB0d28gYm9kaWVzIGFsb25nIGEgZ2l2ZW4gZGlyZWN0aW9uIHVzaW5nIGhpbGwtY2xpbWJpbmcuXG4gICAgICogQG1ldGhvZCBfZmluZFN1cHBvcnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlBXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBub3JtYWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uXG4gICAgICogQHJldHVybiBbdmVjdG9yXVxuICAgICAqL1xuICAgIENvbGxpc2lvbi5fZmluZFN1cHBvcnRzID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCLCBub3JtYWwsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBib2R5Qi52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHZlcnRpY2VzTGVuZ3RoID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgYm9keUFQb3NpdGlvblggPSBib2R5QS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgYm9keUFQb3NpdGlvblkgPSBib2R5QS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgbm9ybWFsWCA9IG5vcm1hbC54ICogZGlyZWN0aW9uLFxuICAgICAgICAgICAgbm9ybWFsWSA9IG5vcm1hbC55ICogZGlyZWN0aW9uLFxuICAgICAgICAgICAgdmVydGV4QSA9IHZlcnRpY2VzWzBdLFxuICAgICAgICAgICAgdmVydGV4QiA9IHZlcnRleEEsXG4gICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBub3JtYWxYICogKGJvZHlBUG9zaXRpb25YIC0gdmVydGV4Qi54KSArIG5vcm1hbFkgKiAoYm9keUFQb3NpdGlvblkgLSB2ZXJ0ZXhCLnkpLFxuICAgICAgICAgICAgdmVydGV4QyxcbiAgICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgICAgajtcblxuICAgICAgICAvLyBmaW5kIGRlZXBlc3QgdmVydGV4IHJlbGF0aXZlIHRvIHRoZSBheGlzXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCB2ZXJ0aWNlc0xlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhCID0gdmVydGljZXNbal07XG4gICAgICAgICAgICBkaXN0YW5jZSA9IG5vcm1hbFggKiAoYm9keUFQb3NpdGlvblggLSB2ZXJ0ZXhCLngpICsgbm9ybWFsWSAqIChib2R5QVBvc2l0aW9uWSAtIHZlcnRleEIueSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnZleCBoaWxsLWNsaW1iaW5nXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBuZWFyZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhBID0gdmVydGV4QjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1lYXN1cmUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgdmVydGV4QyA9IHZlcnRpY2VzWyh2ZXJ0aWNlc0xlbmd0aCArIHZlcnRleEEuaW5kZXggLSAxKSAlIHZlcnRpY2VzTGVuZ3RoXTtcbiAgICAgICAgbmVhcmVzdERpc3RhbmNlID0gbm9ybWFsWCAqIChib2R5QVBvc2l0aW9uWCAtIHZlcnRleEMueCkgKyBub3JtYWxZICogKGJvZHlBUG9zaXRpb25ZIC0gdmVydGV4Qy55KTtcblxuICAgICAgICAvLyBjb21wYXJlIHdpdGggcHJldmlvdXMgdmVydGV4XG4gICAgICAgIHZlcnRleEIgPSB2ZXJ0aWNlc1sodmVydGV4QS5pbmRleCArIDEpICUgdmVydGljZXNMZW5ndGhdO1xuICAgICAgICBpZiAobm9ybWFsWCAqIChib2R5QVBvc2l0aW9uWCAtIHZlcnRleEIueCkgKyBub3JtYWxZICogKGJvZHlBUG9zaXRpb25ZIC0gdmVydGV4Qi55KSA8IG5lYXJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgX3N1cHBvcnRzWzBdID0gdmVydGV4QTtcbiAgICAgICAgICAgIF9zdXBwb3J0c1sxXSA9IHZlcnRleEI7XG5cbiAgICAgICAgICAgIHJldHVybiBfc3VwcG9ydHM7XG4gICAgICAgIH1cblxuICAgICAgICBfc3VwcG9ydHNbMF0gPSB2ZXJ0ZXhBO1xuICAgICAgICBfc3VwcG9ydHNbMV0gPSB2ZXJ0ZXhDO1xuXG4gICAgICAgIHJldHVybiBfc3VwcG9ydHM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHBhaXIgdXNpbmcgdGhpcyBjb2xsaXNpb24gcmVjb3JkLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGFpclxuICAgICAqIEB0eXBlIHtwYWlyfG51bGx9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBib2RpZXMgd2VyZSBjb2xsaWRpbmcgd2hlbiB0aGUgY29sbGlzaW9uIHdhcyBsYXN0IHVwZGF0ZWQuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgYm9keSBwYXJ0IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gKHNlZSBhbHNvIGBjb2xsaXNpb24ucGFyZW50QWApLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmQgYm9keSBwYXJ0IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gKHNlZSBhbHNvIGBjb2xsaXNpb24ucGFyZW50QmApLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBib2R5IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gKGkuZS4gYGNvbGxpc2lvbi5ib2R5QS5wYXJlbnRgKS5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50QVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmQgYm9keSByZXByZXNlbnRlZCBieSB0aGUgY29sbGlzaW9uIChpLmUuIGBjb2xsaXNpb24uYm9keUIucGFyZW50YCkuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IHBhcmVudEJcbiAgICAgKiBAdHlwZSBib2R5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgcmVwcmVzZW50cyB0aGUgbWluaW11bSBzZXBhcmF0aW5nIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcyBhbG9uZyB0aGUgY29sbGlzaW9uIG5vcm1hbC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBkZXB0aFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgbm9ybWFsaXNlZCBgVmVjdG9yYCB0aGF0IHJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHRoZSBib2RpZXMgdGhhdCBwcm92aWRlcyB0aGUgbWluaW11bSBzZXBhcmF0aW5nIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5vcm1hbFxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIG5vcm1hbGlzZWQgYFZlY3RvcmAgdGhhdCBpcyB0aGUgdGFuZ2VudCBkaXJlY3Rpb24gdG8gdGhlIGNvbGxpc2lvbiBub3JtYWwuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGFuZ2VudFxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgcmVwcmVzZW50cyB0aGUgZGlyZWN0aW9uIGFuZCBkZXB0aCBvZiB0aGUgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBlbmV0cmF0aW9uXG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGJvZHkgdmVydGljZXMgdGhhdCByZXByZXNlbnQgdGhlIHN1cHBvcnQgcG9pbnRzIGluIHRoZSBjb2xsaXNpb24uXG4gICAgICogXG4gICAgICogX05vdGU6XyBPbmx5IHRoZSBmaXJzdCBgY29sbGlzaW9uLnN1cHBvcnRDb3VudGAgaXRlbXMgb2YgYGNvbGxpc2lvbi5zdXBwb3J0c2AgYXJlIGFjdGl2ZS5cbiAgICAgKiBUaGVyZWZvcmUgdXNlIGBjb2xsaXNpb24uc3VwcG9ydENvdW50YCBpbnN0ZWFkIG9mIGBjb2xsaXNpb24uc3VwcG9ydHMubGVuZ3RoYCB3aGVuIGl0ZXJhdGluZyB0aGUgYWN0aXZlIHN1cHBvcnRzLlxuICAgICAqIFxuICAgICAqIFRoZXNlIGFyZSB0aGUgZGVlcGVzdCB2ZXJ0aWNlcyAoYWxvbmcgdGhlIGNvbGxpc2lvbiBub3JtYWwpIG9mIGVhY2ggYm9keSB0aGF0IGFyZSBjb250YWluZWQgYnkgdGhlIG90aGVyIGJvZHkncyB2ZXJ0aWNlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzdXBwb3J0c1xuICAgICAqIEB0eXBlIHZlY3RvcltdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYWN0aXZlIHN1cHBvcnRzIGZvciB0aGlzIGNvbGxpc2lvbiBmb3VuZCBpbiBgY29sbGlzaW9uLnN1cHBvcnRzYC5cbiAgICAgKiBcbiAgICAgKiBfTm90ZTpfIE9ubHkgdGhlIGZpcnN0IGBjb2xsaXNpb24uc3VwcG9ydENvdW50YCBpdGVtcyBvZiBgY29sbGlzaW9uLnN1cHBvcnRzYCBhcmUgYWN0aXZlLlxuICAgICAqIFRoZXJlZm9yZSB1c2UgYGNvbGxpc2lvbi5zdXBwb3J0Q291bnRgIGluc3RlYWQgb2YgYGNvbGxpc2lvbi5zdXBwb3J0cy5sZW5ndGhgIHdoZW4gaXRlcmF0aW5nIHRoZSBhY3RpdmUgc3VwcG9ydHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3VwcG9ydENvdW50XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuUGFpcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIHBhaXJzLlxuKlxuKiBAY2xhc3MgUGFpclxuKi9cblxudmFyIFBhaXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWlyO1xuXG52YXIgQ29udGFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhaXIuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gY29sbGlzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqIEByZXR1cm4ge3BhaXJ9IEEgbmV3IHBhaXJcbiAgICAgKi9cbiAgICBQYWlyLmNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxpc2lvbiwgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QSxcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCO1xuXG4gICAgICAgIHZhciBwYWlyID0ge1xuICAgICAgICAgICAgaWQ6IFBhaXIuaWQoYm9keUEsIGJvZHlCKSxcbiAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCOiBib2R5QixcbiAgICAgICAgICAgIGNvbGxpc2lvbjogY29sbGlzaW9uLFxuICAgICAgICAgICAgY29udGFjdHM6IFtDb250YWN0LmNyZWF0ZSgpLCBDb250YWN0LmNyZWF0ZSgpXSxcbiAgICAgICAgICAgIGNvbnRhY3RDb3VudDogMCxcbiAgICAgICAgICAgIHNlcGFyYXRpb246IDAsXG4gICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlzU2Vuc29yOiBib2R5QS5pc1NlbnNvciB8fCBib2R5Qi5pc1NlbnNvcixcbiAgICAgICAgICAgIHRpbWVDcmVhdGVkOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICB0aW1lVXBkYXRlZDogdGltZXN0YW1wLFxuICAgICAgICAgICAgaW52ZXJzZU1hc3M6IDAsXG4gICAgICAgICAgICBmcmljdGlvbjogMCxcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiAwLFxuICAgICAgICAgICAgcmVzdGl0dXRpb246IDAsXG4gICAgICAgICAgICBzbG9wOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgUGFpci51cGRhdGUocGFpciwgY29sbGlzaW9uLCB0aW1lc3RhbXApO1xuXG4gICAgICAgIHJldHVybiBwYWlyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgcGFpciBnaXZlbiBhIGNvbGxpc2lvbi5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7cGFpcn0gcGFpclxuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICovXG4gICAgUGFpci51cGRhdGUgPSBmdW5jdGlvbihwYWlyLCBjb2xsaXNpb24sIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgc3VwcG9ydHMgPSBjb2xsaXNpb24uc3VwcG9ydHMsXG4gICAgICAgICAgICBzdXBwb3J0Q291bnQgPSBjb2xsaXNpb24uc3VwcG9ydENvdW50LFxuICAgICAgICAgICAgY29udGFjdHMgPSBwYWlyLmNvbnRhY3RzLFxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgcGFyZW50QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xuICAgICAgICBcbiAgICAgICAgcGFpci5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgIHBhaXIuY29sbGlzaW9uID0gY29sbGlzaW9uO1xuICAgICAgICBwYWlyLnNlcGFyYXRpb24gPSBjb2xsaXNpb24uZGVwdGg7XG4gICAgICAgIHBhaXIuaW52ZXJzZU1hc3MgPSBwYXJlbnRBLmludmVyc2VNYXNzICsgcGFyZW50Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgcGFpci5mcmljdGlvbiA9IHBhcmVudEEuZnJpY3Rpb24gPCBwYXJlbnRCLmZyaWN0aW9uID8gcGFyZW50QS5mcmljdGlvbiA6IHBhcmVudEIuZnJpY3Rpb247XG4gICAgICAgIHBhaXIuZnJpY3Rpb25TdGF0aWMgPSBwYXJlbnRBLmZyaWN0aW9uU3RhdGljID4gcGFyZW50Qi5mcmljdGlvblN0YXRpYyA/IHBhcmVudEEuZnJpY3Rpb25TdGF0aWMgOiBwYXJlbnRCLmZyaWN0aW9uU3RhdGljO1xuICAgICAgICBwYWlyLnJlc3RpdHV0aW9uID0gcGFyZW50QS5yZXN0aXR1dGlvbiA+IHBhcmVudEIucmVzdGl0dXRpb24gPyBwYXJlbnRBLnJlc3RpdHV0aW9uIDogcGFyZW50Qi5yZXN0aXR1dGlvbjtcbiAgICAgICAgcGFpci5zbG9wID0gcGFyZW50QS5zbG9wID4gcGFyZW50Qi5zbG9wID8gcGFyZW50QS5zbG9wIDogcGFyZW50Qi5zbG9wO1xuXG4gICAgICAgIHBhaXIuY29udGFjdENvdW50ID0gc3VwcG9ydENvdW50O1xuICAgICAgICBjb2xsaXNpb24ucGFpciA9IHBhaXI7XG5cbiAgICAgICAgdmFyIHN1cHBvcnRBID0gc3VwcG9ydHNbMF0sXG4gICAgICAgICAgICBjb250YWN0QSA9IGNvbnRhY3RzWzBdLFxuICAgICAgICAgICAgc3VwcG9ydEIgPSBzdXBwb3J0c1sxXSxcbiAgICAgICAgICAgIGNvbnRhY3RCID0gY29udGFjdHNbMV07XG5cbiAgICAgICAgLy8gbWF0Y2ggY29udGFjdHMgdG8gc3VwcG9ydHNcbiAgICAgICAgaWYgKGNvbnRhY3RCLnZlcnRleCA9PT0gc3VwcG9ydEEgfHwgY29udGFjdEEudmVydGV4ID09PSBzdXBwb3J0Qikge1xuICAgICAgICAgICAgY29udGFjdHNbMV0gPSBjb250YWN0QTtcbiAgICAgICAgICAgIGNvbnRhY3RzWzBdID0gY29udGFjdEEgPSBjb250YWN0QjtcbiAgICAgICAgICAgIGNvbnRhY3RCID0gY29udGFjdHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgY29udGFjdHNcbiAgICAgICAgY29udGFjdEEudmVydGV4ID0gc3VwcG9ydEE7XG4gICAgICAgIGNvbnRhY3RCLnZlcnRleCA9IHN1cHBvcnRCO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFpciBhcyBhY3RpdmUgb3IgaW5hY3RpdmUuXG4gICAgICogQG1ldGhvZCBzZXRBY3RpdmVcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGlzQWN0aXZlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqL1xuICAgIFBhaXIuc2V0QWN0aXZlID0gZnVuY3Rpb24ocGFpciwgaXNBY3RpdmUsIHRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcGFpci50aW1lVXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhaXIuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhaXIuY29udGFjdENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGlkIGZvciB0aGUgZ2l2ZW4gcGFpci5cbiAgICAgKiBAbWV0aG9kIGlkXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVuaXF1ZSBwYWlySWRcbiAgICAgKi9cbiAgICBQYWlyLmlkID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKSB7XG4gICAgICAgIHJldHVybiBib2R5QS5pZCA8IGJvZHlCLmlkID8gYm9keUEuaWQudG9TdHJpbmcoMzYpICsgJzonICsgYm9keUIuaWQudG9TdHJpbmcoMzYpIFxuICAgICAgICAgICAgOiBib2R5Qi5pZC50b1N0cmluZygzNikgKyAnOicgKyBib2R5QS5pZC50b1N0cmluZygzNik7XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Db25zdHJhaW50YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb25zdHJhaW50cy5cbiogQ29uc3RyYWludHMgYXJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgdGhhdCBhIGZpeGVkIGRpc3RhbmNlIG11c3QgYmUgbWFpbnRhaW5lZCBiZXR3ZWVuIHR3byBib2RpZXMgKG9yIGEgYm9keSBhbmQgYSBmaXhlZCB3b3JsZC1zcGFjZSBwb3NpdGlvbikuXG4qIFRoZSBzdGlmZm5lc3Mgb2YgY29uc3RyYWludHMgY2FuIGJlIG1vZGlmaWVkIHRvIGNyZWF0ZSBzcHJpbmdzIG9yIGVsYXN0aWMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb25zdHJhaW50XG4qL1xuXG52YXIgQ29uc3RyYWludCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgVmVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBTbGVlcGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBBeGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgQ29uc3RyYWludC5fd2FybWluZyA9IDAuNDtcbiAgICBDb25zdHJhaW50Ll90b3JxdWVEYW1wZW4gPSAxO1xuICAgIENvbnN0cmFpbnQuX21pbkxlbmd0aCA9IDAuMDAwMDAxO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb25zdHJhaW50LlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogVG8gc2ltdWxhdGUgYSByZXZvbHV0ZSBjb25zdHJhaW50IChvciBwaW4gam9pbnQpIHNldCBgbGVuZ3RoOiAwYCBhbmQgYSBoaWdoIGBzdGlmZm5lc3NgIHZhbHVlIChlLmcuIGAwLjdgIG9yIGFib3ZlKS5cbiAgICAgKiBJZiB0aGUgY29uc3RyYWludCBpcyB1bnN0YWJsZSwgdHJ5IGxvd2VyaW5nIHRoZSBgc3RpZmZuZXNzYCB2YWx1ZSBhbmQgLyBvciBpbmNyZWFzaW5nIGBlbmdpbmUuY29uc3RyYWludEl0ZXJhdGlvbnNgLlxuICAgICAqIEZvciBjb21wb3VuZCBib2RpZXMsIGNvbnN0cmFpbnRzIG11c3QgYmUgYXBwbGllZCB0byB0aGUgcGFyZW50IGJvZHkgKG5vdCBvbmUgb2YgaXRzIHBhcnRzKS5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICovXG4gICAgQ29uc3RyYWludC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gb3B0aW9ucztcblxuICAgICAgICAvLyBpZiBib2RpZXMgZGVmaW5lZCBidXQgbm8gcG9pbnRzLCB1c2UgYm9keSBjZW50cmVcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUEgJiYgIWNvbnN0cmFpbnQucG9pbnRBKVxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm9keUIgJiYgIWNvbnN0cmFpbnQucG9pbnRCKVxuICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEIgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3RhdGljIGxlbmd0aCB1c2luZyBpbml0aWFsIHdvcmxkIHNwYWNlIHBvaW50c1xuICAgICAgICB2YXIgaW5pdGlhbFBvaW50QSA9IGNvbnN0cmFpbnQuYm9keUEgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKSA6IGNvbnN0cmFpbnQucG9pbnRBLFxuICAgICAgICAgICAgaW5pdGlhbFBvaW50QiA9IGNvbnN0cmFpbnQuYm9keUIgPyBWZWN0b3IuYWRkKGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKSA6IGNvbnN0cmFpbnQucG9pbnRCLFxuICAgICAgICAgICAgbGVuZ3RoID0gVmVjdG9yLm1hZ25pdHVkZShWZWN0b3Iuc3ViKGluaXRpYWxQb2ludEEsIGluaXRpYWxQb2ludEIpKTtcbiAgICBcbiAgICAgICAgY29uc3RyYWludC5sZW5ndGggPSB0eXBlb2YgY29uc3RyYWludC5sZW5ndGggIT09ICd1bmRlZmluZWQnID8gY29uc3RyYWludC5sZW5ndGggOiBsZW5ndGg7XG5cbiAgICAgICAgLy8gb3B0aW9uIGRlZmF1bHRzXG4gICAgICAgIGNvbnN0cmFpbnQuaWQgPSBjb25zdHJhaW50LmlkIHx8IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgY29uc3RyYWludC5sYWJlbCA9IGNvbnN0cmFpbnQubGFiZWwgfHwgJ0NvbnN0cmFpbnQnO1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSAnY29uc3RyYWludCc7XG4gICAgICAgIGNvbnN0cmFpbnQuc3RpZmZuZXNzID0gY29uc3RyYWludC5zdGlmZm5lc3MgfHwgKGNvbnN0cmFpbnQubGVuZ3RoID4gMCA/IDEgOiAwLjcpO1xuICAgICAgICBjb25zdHJhaW50LmRhbXBpbmcgPSBjb25zdHJhaW50LmRhbXBpbmcgfHwgMDtcbiAgICAgICAgY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzID0gY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzIHx8IDA7XG4gICAgICAgIGNvbnN0cmFpbnQuYW5nbGVBID0gY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEuYW5nbGUgOiBjb25zdHJhaW50LmFuZ2xlQTtcbiAgICAgICAgY29uc3RyYWludC5hbmdsZUIgPSBjb25zdHJhaW50LmJvZHlCID8gY29uc3RyYWludC5ib2R5Qi5hbmdsZSA6IGNvbnN0cmFpbnQuYW5nbGVCO1xuICAgICAgICBjb25zdHJhaW50LnBsdWdpbiA9IHt9O1xuXG4gICAgICAgIC8vIHJlbmRlclxuICAgICAgICB2YXIgcmVuZGVyID0ge1xuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICBhbmNob3JzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVuZ3RoID09PSAwICYmIGNvbnN0cmFpbnQuc3RpZmZuZXNzID4gMC4xKSB7XG4gICAgICAgICAgICByZW5kZXIudHlwZSA9ICdwaW4nO1xuICAgICAgICAgICAgcmVuZGVyLmFuY2hvcnMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zdHJhaW50LnN0aWZmbmVzcyA8IDAuOSkge1xuICAgICAgICAgICAgcmVuZGVyLnR5cGUgPSAnc3ByaW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cmFpbnQucmVuZGVyID0gQ29tbW9uLmV4dGVuZChyZW5kZXIsIGNvbnN0cmFpbnQucmVuZGVyKTtcblxuICAgICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgZm9yIHNvbHZpbmcgYnkgY29uc3RyYWludCB3YXJtaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBwcmVTb2x2ZUFsbFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnByZVNvbHZlQWxsID0gZnVuY3Rpb24oYm9kaWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gYm9keS5jb25zdHJhaW50SW1wdWxzZTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgKGltcHVsc2UueCA9PT0gMCAmJiBpbXB1bHNlLnkgPT09IDAgJiYgaW1wdWxzZS5hbmdsZSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi54ICs9IGltcHVsc2UueDtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBpbXB1bHNlLnk7XG4gICAgICAgICAgICBib2R5LmFuZ2xlICs9IGltcHVsc2UuYW5nbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU29sdmVzIGFsbCBjb25zdHJhaW50cyBpbiBhIGxpc3Qgb2YgY29sbGlzaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2Qgc29sdmVBbGxcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnRbXX0gY29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnNvbHZlQWxsID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGRlbHRhKSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBDb21tb24uY2xhbXAoZGVsdGEgLyBDb21tb24uX2Jhc2VEZWx0YSwgMCwgMSk7XG5cbiAgICAgICAgLy8gU29sdmUgZml4ZWQgY29uc3RyYWludHMgZmlyc3QuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV0sXG4gICAgICAgICAgICAgICAgZml4ZWRBID0gIWNvbnN0cmFpbnQuYm9keUEgfHwgKGNvbnN0cmFpbnQuYm9keUEgJiYgY29uc3RyYWludC5ib2R5QS5pc1N0YXRpYyksXG4gICAgICAgICAgICAgICAgZml4ZWRCID0gIWNvbnN0cmFpbnQuYm9keUIgfHwgKGNvbnN0cmFpbnQuYm9keUIgJiYgY29uc3RyYWludC5ib2R5Qi5pc1N0YXRpYyk7XG5cbiAgICAgICAgICAgIGlmIChmaXhlZEEgfHwgZml4ZWRCKSB7XG4gICAgICAgICAgICAgICAgQ29uc3RyYWludC5zb2x2ZShjb25zdHJhaW50c1tpXSwgdGltZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbHZlIGZyZWUgY29uc3RyYWludHMgbGFzdC5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XG4gICAgICAgICAgICBmaXhlZEEgPSAhY29uc3RyYWludC5ib2R5QSB8fCAoY29uc3RyYWludC5ib2R5QSAmJiBjb25zdHJhaW50LmJvZHlBLmlzU3RhdGljKTtcbiAgICAgICAgICAgIGZpeGVkQiA9ICFjb25zdHJhaW50LmJvZHlCIHx8IChjb25zdHJhaW50LmJvZHlCICYmIGNvbnN0cmFpbnQuYm9keUIuaXNTdGF0aWMpO1xuXG4gICAgICAgICAgICBpZiAoIWZpeGVkQSAmJiAhZml4ZWRCKSB7XG4gICAgICAgICAgICAgICAgQ29uc3RyYWludC5zb2x2ZShjb25zdHJhaW50c1tpXSwgdGltZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTb2x2ZXMgYSBkaXN0YW5jZSBjb25zdHJhaW50IHdpdGggR2F1c3MtU2llZGVsIG1ldGhvZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2Qgc29sdmVcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVNjYWxlXG4gICAgICovXG4gICAgQ29uc3RyYWludC5zb2x2ZSA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIHRpbWVTY2FsZSkge1xuICAgICAgICB2YXIgYm9keUEgPSBjb25zdHJhaW50LmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxuICAgICAgICAgICAgcG9pbnRBID0gY29uc3RyYWludC5wb2ludEEsXG4gICAgICAgICAgICBwb2ludEIgPSBjb25zdHJhaW50LnBvaW50QjtcblxuICAgICAgICBpZiAoIWJvZHlBICYmICFib2R5QilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyB1cGRhdGUgcmVmZXJlbmNlIGFuZ2xlXG4gICAgICAgIGlmIChib2R5QSAmJiAhYm9keUEuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIFZlY3Rvci5yb3RhdGUocG9pbnRBLCBib2R5QS5hbmdsZSAtIGNvbnN0cmFpbnQuYW5nbGVBLCBwb2ludEEpO1xuICAgICAgICAgICAgY29uc3RyYWludC5hbmdsZUEgPSBib2R5QS5hbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdXBkYXRlIHJlZmVyZW5jZSBhbmdsZVxuICAgICAgICBpZiAoYm9keUIgJiYgIWJvZHlCLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBWZWN0b3Iucm90YXRlKHBvaW50QiwgYm9keUIuYW5nbGUgLSBjb25zdHJhaW50LmFuZ2xlQiwgcG9pbnRCKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuYW5nbGVCID0gYm9keUIuYW5nbGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnRBV29ybGQgPSBwb2ludEEsXG4gICAgICAgICAgICBwb2ludEJXb3JsZCA9IHBvaW50QjtcblxuICAgICAgICBpZiAoYm9keUEpIHBvaW50QVdvcmxkID0gVmVjdG9yLmFkZChib2R5QS5wb3NpdGlvbiwgcG9pbnRBKTtcbiAgICAgICAgaWYgKGJvZHlCKSBwb2ludEJXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIHBvaW50Qik7XG5cbiAgICAgICAgaWYgKCFwb2ludEFXb3JsZCB8fCAhcG9pbnRCV29ybGQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGRlbHRhID0gVmVjdG9yLnN1Yihwb2ludEFXb3JsZCwgcG9pbnRCV29ybGQpLFxuICAgICAgICAgICAgY3VycmVudExlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoZGVsdGEpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgc2luZ3VsYXJpdHlcbiAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCBDb25zdHJhaW50Ll9taW5MZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBDb25zdHJhaW50Ll9taW5MZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzb2x2ZSBkaXN0YW5jZSBjb25zdHJhaW50IHdpdGggR2F1c3MtU2llZGVsIG1ldGhvZFxuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IChjdXJyZW50TGVuZ3RoIC0gY29uc3RyYWludC5sZW5ndGgpIC8gY3VycmVudExlbmd0aCxcbiAgICAgICAgICAgIGlzUmlnaWQgPSBjb25zdHJhaW50LnN0aWZmbmVzcyA+PSAxIHx8IGNvbnN0cmFpbnQubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgc3RpZmZuZXNzID0gaXNSaWdpZCA/IGNvbnN0cmFpbnQuc3RpZmZuZXNzICogdGltZVNjYWxlIFxuICAgICAgICAgICAgICAgIDogY29uc3RyYWludC5zdGlmZm5lc3MgKiB0aW1lU2NhbGUgKiB0aW1lU2NhbGUsXG4gICAgICAgICAgICBkYW1waW5nID0gY29uc3RyYWludC5kYW1waW5nICogdGltZVNjYWxlLFxuICAgICAgICAgICAgZm9yY2UgPSBWZWN0b3IubXVsdChkZWx0YSwgZGlmZmVyZW5jZSAqIHN0aWZmbmVzcyksXG4gICAgICAgICAgICBtYXNzVG90YWwgPSAoYm9keUEgPyBib2R5QS5pbnZlcnNlTWFzcyA6IDApICsgKGJvZHlCID8gYm9keUIuaW52ZXJzZU1hc3MgOiAwKSxcbiAgICAgICAgICAgIGluZXJ0aWFUb3RhbCA9IChib2R5QSA/IGJvZHlBLmludmVyc2VJbmVydGlhIDogMCkgKyAoYm9keUIgPyBib2R5Qi5pbnZlcnNlSW5lcnRpYSA6IDApLFxuICAgICAgICAgICAgcmVzaXN0YW5jZVRvdGFsID0gbWFzc1RvdGFsICsgaW5lcnRpYVRvdGFsLFxuICAgICAgICAgICAgdG9ycXVlLFxuICAgICAgICAgICAgc2hhcmUsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBub3JtYWxWZWxvY2l0eSxcbiAgICAgICAgICAgIHJlbGF0aXZlVmVsb2NpdHk7XG4gICAgXG4gICAgICAgIGlmIChkYW1waW5nID4gMCkge1xuICAgICAgICAgICAgdmFyIHplcm8gPSBWZWN0b3IuY3JlYXRlKCk7XG4gICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IuZGl2KGRlbHRhLCBjdXJyZW50TGVuZ3RoKTtcblxuICAgICAgICAgICAgcmVsYXRpdmVWZWxvY2l0eSA9IFZlY3Rvci5zdWIoXG4gICAgICAgICAgICAgICAgYm9keUIgJiYgVmVjdG9yLnN1Yihib2R5Qi5wb3NpdGlvbiwgYm9keUIucG9zaXRpb25QcmV2KSB8fCB6ZXJvLFxuICAgICAgICAgICAgICAgIGJvZHlBICYmIFZlY3Rvci5zdWIoYm9keUEucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uUHJldikgfHwgemVyb1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbm9ybWFsVmVsb2NpdHkgPSBWZWN0b3IuZG90KG5vcm1hbCwgcmVsYXRpdmVWZWxvY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBzaGFyZSA9IGJvZHlBLmludmVyc2VNYXNzIC8gbWFzc1RvdGFsO1xuXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFwcGxpZWQgaW1wdWxzZXMgZm9yIHBvc3Qgc29sdmluZ1xuICAgICAgICAgICAgYm9keUEuY29uc3RyYWludEltcHVsc2UueCAtPSBmb3JjZS54ICogc2hhcmU7XG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS55IC09IGZvcmNlLnkgKiBzaGFyZTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgZm9yY2VzXG4gICAgICAgICAgICBib2R5QS5wb3NpdGlvbi54IC09IGZvcmNlLnggKiBzaGFyZTtcbiAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uLnkgLT0gZm9yY2UueSAqIHNoYXJlO1xuXG4gICAgICAgICAgICAvLyBhcHBseSBkYW1waW5nXG4gICAgICAgICAgICBpZiAoZGFtcGluZyA+IDApIHtcbiAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueCAtPSBkYW1waW5nICogbm9ybWFsLnggKiBub3JtYWxWZWxvY2l0eSAqIHNoYXJlO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55IC09IGRhbXBpbmcgKiBub3JtYWwueSAqIG5vcm1hbFZlbG9jaXR5ICogc2hhcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRvcnF1ZVxuICAgICAgICAgICAgdG9ycXVlID0gKFZlY3Rvci5jcm9zcyhwb2ludEEsIGZvcmNlKSAvIHJlc2lzdGFuY2VUb3RhbCkgKiBDb25zdHJhaW50Ll90b3JxdWVEYW1wZW4gKiBib2R5QS5pbnZlcnNlSW5lcnRpYSAqICgxIC0gY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzKTtcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlIC09IHRvcnF1ZTtcbiAgICAgICAgICAgIGJvZHlBLmFuZ2xlIC09IHRvcnF1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5QiAmJiAhYm9keUIuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHNoYXJlID0gYm9keUIuaW52ZXJzZU1hc3MgLyBtYXNzVG90YWw7XG5cbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYXBwbGllZCBpbXB1bHNlcyBmb3IgcG9zdCBzb2x2aW5nXG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS54ICs9IGZvcmNlLnggKiBzaGFyZTtcbiAgICAgICAgICAgIGJvZHlCLmNvbnN0cmFpbnRJbXB1bHNlLnkgKz0gZm9yY2UueSAqIHNoYXJlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhcHBseSBmb3JjZXNcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnggKz0gZm9yY2UueCAqIHNoYXJlO1xuICAgICAgICAgICAgYm9keUIucG9zaXRpb24ueSArPSBmb3JjZS55ICogc2hhcmU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGRhbXBpbmdcbiAgICAgICAgICAgIGlmIChkYW1waW5nID4gMCkge1xuICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi54ICs9IGRhbXBpbmcgKiBub3JtYWwueCAqIG5vcm1hbFZlbG9jaXR5ICogc2hhcmU7XG4gICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnkgKz0gZGFtcGluZyAqIG5vcm1hbC55ICogbm9ybWFsVmVsb2NpdHkgKiBzaGFyZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwbHkgdG9ycXVlXG4gICAgICAgICAgICB0b3JxdWUgPSAoVmVjdG9yLmNyb3NzKHBvaW50QiwgZm9yY2UpIC8gcmVzaXN0YW5jZVRvdGFsKSAqIENvbnN0cmFpbnQuX3RvcnF1ZURhbXBlbiAqIGJvZHlCLmludmVyc2VJbmVydGlhICogKDEgLSBjb25zdHJhaW50LmFuZ3VsYXJTdGlmZm5lc3MpO1xuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UuYW5nbGUgKz0gdG9ycXVlO1xuICAgICAgICAgICAgYm9keUIuYW5nbGUgKz0gdG9ycXVlO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYm9keSB1cGRhdGVzIHJlcXVpcmVkIGFmdGVyIHNvbHZpbmcgY29uc3RyYWludHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHBvc3RTb2x2ZUFsbFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbCA9IGZ1bmN0aW9uKGJvZGllcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IGJvZHkuY29uc3RyYWludEltcHVsc2U7XG5cbiAgICAgICAgICAgIGlmIChib2R5LmlzU3RhdGljIHx8IChpbXB1bHNlLnggPT09IDAgJiYgaW1wdWxzZS55ID09PSAwICYmIGltcHVsc2UuYW5nbGUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBnZW9tZXRyeSBhbmQgcmVzZXRcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcy50cmFuc2xhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IGltcHVsc2UueDtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ICs9IGltcHVsc2UueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW1wdWxzZS5hbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5yb3RhdGUocGFydC52ZXJ0aWNlcywgaW1wdWxzZS5hbmdsZSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIEF4ZXMucm90YXRlKHBhcnQuYXhlcywgaW1wdWxzZS5hbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGltcHVsc2UuYW5nbGUsIGJvZHkucG9zaXRpb24sIHBhcnQucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRhbXBlbiB0aGUgY2FjaGVkIGltcHVsc2UgZm9yIHdhcm1pbmcgbmV4dCBzdGVwXG4gICAgICAgICAgICBpbXB1bHNlLmFuZ2xlICo9IENvbnN0cmFpbnQuX3dhcm1pbmc7XG4gICAgICAgICAgICBpbXB1bHNlLnggKj0gQ29uc3RyYWludC5fd2FybWluZztcbiAgICAgICAgICAgIGltcHVsc2UueSAqPSBDb25zdHJhaW50Ll93YXJtaW5nO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIGBjb25zdHJhaW50LnBvaW50QWAsIGFjY291bnRpbmcgZm9yIGBjb25zdHJhaW50LmJvZHlBYC5cbiAgICAgKiBAbWV0aG9kIHBvaW50QVdvcmxkXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHJldHVybnMge3ZlY3Rvcn0gdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ29uc3RyYWludC5wb2ludEFXb3JsZCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IChjb25zdHJhaW50LmJvZHlBID8gY29uc3RyYWludC5ib2R5QS5wb3NpdGlvbi54IDogMCkgXG4gICAgICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEEgPyBjb25zdHJhaW50LnBvaW50QS54IDogMCksXG4gICAgICAgICAgICB5OiAoY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24ueSA6IDApIFxuICAgICAgICAgICAgICAgICsgKGNvbnN0cmFpbnQucG9pbnRBID8gY29uc3RyYWludC5wb2ludEEueSA6IDApXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIGBjb25zdHJhaW50LnBvaW50QmAsIGFjY291bnRpbmcgZm9yIGBjb25zdHJhaW50LmJvZHlCYC5cbiAgICAgKiBAbWV0aG9kIHBvaW50QldvcmxkXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHJldHVybnMge3ZlY3Rvcn0gdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ29uc3RyYWludC5wb2ludEJXb3JsZCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IChjb25zdHJhaW50LmJvZHlCID8gY29uc3RyYWludC5ib2R5Qi5wb3NpdGlvbi54IDogMCkgXG4gICAgICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEIgPyBjb25zdHJhaW50LnBvaW50Qi54IDogMCksXG4gICAgICAgICAgICB5OiAoY29uc3RyYWludC5ib2R5QiA/IGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24ueSA6IDApIFxuICAgICAgICAgICAgICAgICsgKGNvbnN0cmFpbnQucG9pbnRCID8gY29uc3RyYWludC5wb2ludEIueSA6IDApXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRoZSBjb25zdHJhaW50LiBcbiAgICAgKiBUaGlzIGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGJvdGggb2YgdGhlIGNvbnN0cmFpbnQncyBlbmQgcG9pbnRzLlxuICAgICAqIFNlZSBgY29uc3RyYWludC5sZW5ndGhgIGZvciB0aGUgdGFyZ2V0IHJlc3QgbGVuZ3RoLlxuICAgICAqIEBtZXRob2QgY3VycmVudExlbmd0aFxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGxlbmd0aFxuICAgICAqL1xuICAgIENvbnN0cmFpbnQuY3VycmVudExlbmd0aCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIHBvaW50QVggPSAoY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24ueCA6IDApIFxuICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEEgPyBjb25zdHJhaW50LnBvaW50QS54IDogMCk7XG5cbiAgICAgICAgdmFyIHBvaW50QVkgPSAoY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24ueSA6IDApIFxuICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEEgPyBjb25zdHJhaW50LnBvaW50QS55IDogMCk7XG5cbiAgICAgICAgdmFyIHBvaW50QlggPSAoY29uc3RyYWludC5ib2R5QiA/IGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24ueCA6IDApIFxuICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEIgPyBjb25zdHJhaW50LnBvaW50Qi54IDogMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIHBvaW50QlkgPSAoY29uc3RyYWludC5ib2R5QiA/IGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24ueSA6IDApIFxuICAgICAgICAgICAgKyAoY29uc3RyYWludC5wb2ludEIgPyBjb25zdHJhaW50LnBvaW50Qi55IDogMCk7XG5cbiAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50QVggLSBwb2ludEJYO1xuICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRBWSAtIHBvaW50Qlk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQ29tcG9zaXRlLmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkNvbnN0cmFpbnRcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgcHJvcGVydGllcyB0byBiZSBjb25zdW1lZCBieSB0aGUgbW9kdWxlIGBNYXR0ZXIuUmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY29uc3RyYWludCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnZpc2libGVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGxpbmUgd2lkdGggdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBjb25zdHJhaW50IG91dGxpbmUuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgbm8gb3V0bGluZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5saW5lV2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgY29uc3RyYWludCBvdXRsaW5lLlxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3Ryb2tlU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBjb25zdHJhaW50IHJlbmRlcmluZyB0eXBlLiBcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZSAnbGluZScsICdwaW4nLCAnc3ByaW5nJy5cbiAgICAgKiBBbiBhcHByb3ByaWF0ZSByZW5kZXIgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2hvc2VuIHVubGVzcyBvbmUgaXMgZ2l2ZW4gaW4gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdsaW5lJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgQm9vbGVhbmAgdGhhdCBkZWZpbmVzIGlmIHRoZSBjb25zdHJhaW50J3MgYW5jaG9yIHBvaW50cyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmFuY2hvcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kIHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGNvbnN0cmFpbnQgZnJvbSBjZW50ZXIgb2YgdGhlIGBjb25zdHJhaW50LmJvZHlBYCBpZiBkZWZpbmVkLCBvdGhlcndpc2UgYSB3b3JsZC1zcGFjZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb2ludEFcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBjb25zdHJhaW50IGZyb20gY2VudGVyIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QmAgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGEgd29ybGQtc3BhY2UgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9pbnRCXG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIHN0aWZmbmVzcyBvZiB0aGUgY29uc3RyYWludCwgaS5lLiB0aGUgcmF0ZSBhdCB3aGljaCBpdCByZXR1cm5zIHRvIGl0cyByZXN0aW5nIGBjb25zdHJhaW50Lmxlbmd0aGAuXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHZlcnkgc3RpZmYuXG4gICAgICogQSB2YWx1ZSBvZiBgMC4yYCBtZWFucyB0aGUgY29uc3RyYWludCBhY3RzIGxpa2UgYSBzb2Z0IHNwcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBkYW1waW5nIG9mIHRoZSBjb25zdHJhaW50LCBcbiAgICAgKiBpLmUuIHRoZSBhbW91bnQgb2YgcmVzaXN0YW5jZSBhcHBsaWVkIHRvIGVhY2ggYm9keSBiYXNlZCBvbiB0aGVpciB2ZWxvY2l0aWVzIHRvIGxpbWl0IHRoZSBhbW91bnQgb2Ygb3NjaWxsYXRpb24uXG4gICAgICogRGFtcGluZyB3aWxsIG9ubHkgYmUgYXBwYXJlbnQgd2hlbiB0aGUgY29uc3RyYWludCBhbHNvIGhhcyBhIHZlcnkgbG93IGBzdGlmZm5lc3NgLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgd2lsbCBhcHBseSBoZWF2eSBkYW1waW5nLCByZXN1bHRpbmcgaW4gbGl0dGxlIHRvIG5vIG9zY2lsbGF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBjb25zdHJhaW50IHdpbGwgYXBwbHkgbm8gZGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlc3RpbmcgbGVuZ3RoIG9mIHRoZSBjb25zdHJhaW50LiBcbiAgICAgKiBJdCBpcyBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgaW4gYENvbnN0cmFpbnQuY3JlYXRlYCBmcm9tIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QWAgYW5kIGBjb25zdHJhaW50LmJvZHlCYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkF4ZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgYXhlcy5cbipcbiogQGNsYXNzIEF4ZXNcbiovXG5cbnZhciBBeGVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQXhlcztcblxudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzZXQgb2YgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7YXhlc30gQSBuZXcgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIEF4ZXMuZnJvbVZlcnRpY2VzID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSB7fTtcblxuICAgICAgICAvLyBmaW5kIHRoZSB1bmlxdWUgYXhlcywgdXNpbmcgZWRnZSBub3JtYWwgZ3JhZGllbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aCwgXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxuICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSwgXG4gICAgICAgICAgICAgICAgICAgIHk6IHZlcnRpY2VzW2ldLnggLSB2ZXJ0aWNlc1tqXS54XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSAobm9ybWFsLnkgPT09IDApID8gSW5maW5pdHkgOiAobm9ybWFsLnggLyBub3JtYWwueSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGxpbWl0IHByZWNpc2lvblxuICAgICAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC50b0ZpeGVkKDMpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBheGVzW2dyYWRpZW50XSA9IG5vcm1hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb21tb24udmFsdWVzKGF4ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGEgc2V0IG9mIGF4ZXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtheGVzfSBheGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgQXhlcy5yb3RhdGUgPSBmdW5jdGlvbihheGVzLCBhbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGVzW2ldLFxuICAgICAgICAgICAgICAgIHh4O1xuICAgICAgICAgICAgeHggPSBheGlzLnggKiBjb3MgLSBheGlzLnkgKiBzaW47XG4gICAgICAgICAgICBheGlzLnkgPSBheGlzLnggKiBzaW4gKyBheGlzLnkgKiBjb3M7XG4gICAgICAgICAgICBheGlzLnggPSB4eDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQm9kaWVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyByaWdpZCBib2R5IG1vZGVscyBcbiogd2l0aCBjb21tb25seSB1c2VkIGJvZHkgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgcmVjdGFuZ2xlcywgY2lyY2xlcyBhbmQgb3RoZXIgcG9seWdvbnMpLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgQm9kaWVzXG4qL1xuXG4vLyBUT0RPOiB0cnVlIGNpcmNsZSBib2RpZXNcblxudmFyIEJvZGllcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZGllcztcblxudmFyIFZlcnRpY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIEJvZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgVmVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWN0YW5nbGUgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyByZWN0YW5nbGUgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy5yZWN0YW5nbGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdSZWN0YW5nbGUgQm9keScsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgoJ0wgMCAwIEwgJyArIHdpZHRoICsgJyAwIEwgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0ICsgJyBMIDAgJyArIGhlaWdodClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgICAgIHJlY3RhbmdsZS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIocmVjdGFuZ2xlLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHJlY3RhbmdsZSwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSB0cmFwZXpvaWQgaHVsbC4gXG4gICAgICogVGhlIGBzbG9wZWAgaXMgcGFyYW1ldGVyaXNlZCBhcyBhIGZyYWN0aW9uIG9mIGB3aWR0aGAgYW5kIG11c3QgYmUgPCAxIHRvIGZvcm0gYSB2YWxpZCB0cmFwZXpvaWQuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgdHJhcGV6b2lkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2xvcGUgTXVzdCBiZSBhIG51bWJlciA8IDEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHRyYXBlem9pZCBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLnRyYXBlem9pZCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNsb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChzbG9wZSA+PSAxKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignQm9kaWVzLnRyYXBlem9pZDogc2xvcGUgcGFyYW1ldGVyIG11c3QgYmUgPCAxLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2xvcGUgKj0gMC41O1xuICAgICAgICB2YXIgcm9vZiA9ICgxIC0gKHNsb3BlICogMikpICogd2lkdGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgeDEgPSB3aWR0aCAqIHNsb3BlLFxuICAgICAgICAgICAgeDIgPSB4MSArIHJvb2YsXG4gICAgICAgICAgICB4MyA9IHgyICsgeDEsXG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGg7XG5cbiAgICAgICAgaWYgKHNsb3BlIDwgMC41KSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDEgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgyICsgJyAnICsgKC1oZWlnaHQpICsgJyBMICcgKyB4MyArICcgMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1BhdGggPSAnTCAwIDAgTCAnICsgeDIgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgzICsgJyAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFwZXpvaWQgPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdUcmFwZXpvaWQgQm9keScsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgodmVydGljZXNQYXRoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW1mZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICAgICAgdHJhcGV6b2lkLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcih0cmFwZXpvaWQudmVydGljZXMsIGNoYW1mZXIucmFkaXVzLCBcbiAgICAgICAgICAgICAgICBjaGFtZmVyLnF1YWxpdHksIGNoYW1mZXIucXVhbGl0eU1pbiwgY2hhbWZlci5xdWFsaXR5TWF4KTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7fSwgdHJhcGV6b2lkLCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQgYm9keSBtb2RlbCB3aXRoIGEgY2lyY2xlIGh1bGwuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhTaWRlc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyBjaXJjbGUgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy5jaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIG9wdGlvbnMsIG1heFNpZGVzKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBjaXJjbGUgPSB7XG4gICAgICAgICAgICBsYWJlbDogJ0NpcmNsZSBCb2R5JyxcbiAgICAgICAgICAgIGNpcmNsZVJhZGl1czogcmFkaXVzXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjaXJjbGVzIHdpdGggcG9seWdvbnMgdW50aWwgdHJ1ZSBjaXJjbGVzIGltcGxlbWVudGVkIGluIFNBVFxuICAgICAgICBtYXhTaWRlcyA9IG1heFNpZGVzIHx8IDI1O1xuICAgICAgICB2YXIgc2lkZXMgPSBNYXRoLmNlaWwoTWF0aC5tYXgoMTAsIE1hdGgubWluKG1heFNpZGVzLCByYWRpdXMpKSk7XG5cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uOiBhbHdheXMgdXNlIGV2ZW4gbnVtYmVyIG9mIHNpZGVzIChoYWxmIHRoZSBudW1iZXIgb2YgdW5pcXVlIGF4ZXMpXG4gICAgICAgIGlmIChzaWRlcyAlIDIgPT09IDEpXG4gICAgICAgICAgICBzaWRlcyArPSAxO1xuXG4gICAgICAgIHJldHVybiBCb2RpZXMucG9seWdvbih4LCB5LCBzaWRlcywgcmFkaXVzLCBDb21tb24uZXh0ZW5kKHt9LCBjaXJjbGUsIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWd1bGFyIHBvbHlnb24gaHVsbCB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2Ygc2lkZXMuIFxuICAgICAqIFRoZSBvcHRpb25zIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBzcGVjaWZpZXMgYW55IHByb3BlcnRpZXMgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIG9mIHRoZSBgTWF0dGVyLkJvZHlgIG1vZHVsZSBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgcG9seWdvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lkZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IHJlZ3VsYXIgcG9seWdvbiBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLnBvbHlnb24gPSBmdW5jdGlvbih4LCB5LCBzaWRlcywgcmFkaXVzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChzaWRlcyA8IDMpXG4gICAgICAgICAgICByZXR1cm4gQm9kaWVzLmNpcmNsZSh4LCB5LCByYWRpdXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gc2lkZXMsXG4gICAgICAgICAgICBwYXRoID0gJycsXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGV0YSAqIDAuNTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IG9mZnNldCArIChpICogdGhldGEpLFxuICAgICAgICAgICAgICAgIHh4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgICAgICAgICAgIHl5ID0gTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzO1xuXG4gICAgICAgICAgICBwYXRoICs9ICdMICcgKyB4eC50b0ZpeGVkKDMpICsgJyAnICsgeXkudG9GaXhlZCgzKSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2x5Z29uID0geyBcbiAgICAgICAgICAgIGxhYmVsOiAnUG9seWdvbiBCb2R5JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBWZXJ0aWNlcy5mcm9tUGF0aChwYXRoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYW1mZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFtZmVyID0gb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICAgICAgcG9seWdvbi52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIocG9seWdvbi52ZXJ0aWNlcywgY2hhbWZlci5yYWRpdXMsIFxuICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCBwb2x5Z29uLCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gY3JlYXRlIGEgY29tcG91bmQgYm9keSBiYXNlZCBvbiBzZXQocykgb2YgdmVydGljZXMuXG4gICAgICogXG4gICAgICogX05vdGU6XyBUbyBvcHRpb25hbGx5IGVuYWJsZSBhdXRvbWF0aWMgY29uY2F2ZSB2ZXJ0aWNlcyBkZWNvbXBvc2l0aW9uIHRoZSBbcG9seS1kZWNvbXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wb2x5LWRlY29tcC5qcykgXG4gICAgICogcGFja2FnZSBtdXN0IGJlIGZpcnN0IGluc3RhbGxlZCBhbmQgcHJvdmlkZWQgc2VlIGBDb21tb24uc2V0RGVjb21wYCwgb3RoZXJ3aXNlIHRoZSBjb252ZXggaHVsbCBvZiBlYWNoIHZlcnRleCBzZXQgd2lsbCBiZSB1c2VkLlxuICAgICAqIFxuICAgICAqIFRoZSByZXN1bHRpbmcgdmVydGljZXMgYXJlIHJlb3JpZW50YXRlZCBhYm91dCB0aGVpciBjZW50cmUgb2YgbWFzcyxcbiAgICAgKiBhbmQgb2Zmc2V0IHN1Y2ggdGhhdCBgYm9keS5wb3NpdGlvbmAgY29ycmVzcG9uZHMgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBcbiAgICAgKiBUaGUgcmVzdWx0aW5nIG9mZnNldCBtYXkgYmUgZm91bmQgaWYgbmVlZGVkIGJ5IHN1YnRyYWN0aW5nIGBib2R5LmJvdW5kc2AgZnJvbSB0aGUgb3JpZ2luYWwgaW5wdXQgYm91bmRzLlxuICAgICAqIFRvIGxhdGVyIG1vdmUgdGhlIGNlbnRyZSBvZiBtYXNzIHNlZSBgQm9keS5zZXRDZW50cmVgLlxuICAgICAqIFxuICAgICAqIE5vdGUgdGhhdCBhdXRvbWF0aWMgY29uY29uY2F2ZSBkZWNvbXBvc2l0aW9uIHJlc3VsdHMgYXJlIG5vdCBhbHdheXMgb3B0aW1hbC4gXG4gICAgICogRm9yIGJlc3QgcmVzdWx0cywgc2ltcGxpZnkgdGhlIGlucHV0IHZlcnRpY2VzIGFzIG11Y2ggYXMgcG9zc2libGUgZmlyc3QuXG4gICAgICogQnkgZGVmYXVsdCB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgc29tZSBhZGR0aW9uYWwgc2ltcGxpZmljYXRpb24gdG8gaGVscC5cbiAgICAgKiBcbiAgICAgKiBTb21lIG91dHB1dHMgbWF5IGFsc28gcmVxdWlyZSBmdXJ0aGVyIG1hbnVhbCBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdG8gYmUgcm9idXN0LlxuICAgICAqIEluIHBhcnRpY3VsYXIgc29tZSBwYXJ0cyBtYXkgbmVlZCB0byBiZSBvdmVybGFwcGVkIHRvIGF2b2lkIGNvbGxpc2lvbiBnYXBzLlxuICAgICAqIFRoaW4gcGFydHMgYW5kIHNoYXJwIHBvaW50cyBzaG91bGQgYmUgYXZvaWRlZCBvciByZW1vdmVkIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9iamVjdCBzcGVjaWZpZXMgYW55IGBNYXR0ZXIuQm9keWAgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBmcm9tVmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHthcnJheX0gdmVydGV4U2V0cyBPbmUgb3IgbW9yZSBhcnJheXMgb2YgdmVydGV4IHBvaW50cyBlLmcuIGBbW3sgeDogMCwgeTogMCB9Li4uXSwgLi4uXWAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgYm9keSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW2ZsYWdJbnRlcm5hbD1mYWxzZV0gT3B0aW9uYWxseSBtYXJrcyBpbnRlcm5hbCBlZGdlcyB3aXRoIGBpc0ludGVybmFsYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JlbW92ZUNvbGxpbmVhcj0wLjAxXSBUaHJlc2hvbGQgd2hlbiBzaW1wbGlmeWluZyB2ZXJ0aWNlcyBhbG9uZyB0aGUgc2FtZSBlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluaW11bUFyZWE9MTBdIFRocmVzaG9sZCB3aGVuIHJlbW92aW5nIHNtYWxsIHBhcnRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtb3ZlRHVwbGljYXRlUG9pbnRzPTAuMDFdIFRocmVzaG9sZCB3aGVuIHNpbXBsaWZ5aW5nIG5lYXJieSB2ZXJ0aWNlcy5cbiAgICAgKiBAcmV0dXJuIHtib2R5fVxuICAgICAqL1xuICAgIEJvZGllcy5mcm9tVmVydGljZXMgPSBmdW5jdGlvbih4LCB5LCB2ZXJ0ZXhTZXRzLCBvcHRpb25zLCBmbGFnSW50ZXJuYWwsIHJlbW92ZUNvbGxpbmVhciwgbWluaW11bUFyZWEsIHJlbW92ZUR1cGxpY2F0ZVBvaW50cykge1xuICAgICAgICB2YXIgZGVjb21wID0gQ29tbW9uLmdldERlY29tcCgpLFxuICAgICAgICAgICAgY2FuRGVjb21wLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgaXNDb252ZXgsXG4gICAgICAgICAgICBpc0NvbmNhdmUsXG4gICAgICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICB6O1xuXG4gICAgICAgIC8vIGNoZWNrIGRlY29tcCBpcyBhcyBleHBlY3RlZFxuICAgICAgICBjYW5EZWNvbXAgPSBCb29sZWFuKGRlY29tcCAmJiBkZWNvbXAucXVpY2tEZWNvbXApO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBwYXJ0cyA9IFtdO1xuXG4gICAgICAgIGZsYWdJbnRlcm5hbCA9IHR5cGVvZiBmbGFnSW50ZXJuYWwgIT09ICd1bmRlZmluZWQnID8gZmxhZ0ludGVybmFsIDogZmFsc2U7XG4gICAgICAgIHJlbW92ZUNvbGxpbmVhciA9IHR5cGVvZiByZW1vdmVDb2xsaW5lYXIgIT09ICd1bmRlZmluZWQnID8gcmVtb3ZlQ29sbGluZWFyIDogMC4wMTtcbiAgICAgICAgbWluaW11bUFyZWEgPSB0eXBlb2YgbWluaW11bUFyZWEgIT09ICd1bmRlZmluZWQnID8gbWluaW11bUFyZWEgOiAxMDtcbiAgICAgICAgcmVtb3ZlRHVwbGljYXRlUG9pbnRzID0gdHlwZW9mIHJlbW92ZUR1cGxpY2F0ZVBvaW50cyAhPT0gJ3VuZGVmaW5lZCcgPyByZW1vdmVEdXBsaWNhdGVQb2ludHMgOiAwLjAxO1xuXG4gICAgICAgIC8vIGVuc3VyZSB2ZXJ0ZXhTZXRzIGlzIGFuIGFycmF5IG9mIGFycmF5c1xuICAgICAgICBpZiAoIUNvbW1vbi5pc0FycmF5KHZlcnRleFNldHNbMF0pKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhTZXRzID0gW3ZlcnRleFNldHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IHZlcnRleFNldHMubGVuZ3RoOyB2ICs9IDEpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzID0gdmVydGV4U2V0c1t2XTtcbiAgICAgICAgICAgIGlzQ29udmV4ID0gVmVydGljZXMuaXNDb252ZXgodmVydGljZXMpO1xuICAgICAgICAgICAgaXNDb25jYXZlID0gIWlzQ29udmV4O1xuXG4gICAgICAgICAgICBpZiAoaXNDb25jYXZlICYmICFjYW5EZWNvbXApIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgICAgICdCb2RpZXMuZnJvbVZlcnRpY2VzOiBJbnN0YWxsIHRoZSBcXCdwb2x5LWRlY29tcFxcJyBsaWJyYXJ5IGFuZCB1c2UgQ29tbW9uLnNldERlY29tcCBvciBwcm92aWRlIFxcJ2RlY29tcFxcJyBhcyBhIGdsb2JhbCB0byBkZWNvbXBvc2UgY29uY2F2ZSB2ZXJ0aWNlcy4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQ29udmV4IHx8ICFjYW5EZWNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb252ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5jbG9ja3dpc2VTb3J0KHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBjb252ZXggaHVsbCB3aGVuIGRlY29tcG9zaXRpb24gaXMgbm90IHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gVmVydGljZXMuaHVsbCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpc2UgYSBkZWNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGNvbmNhdmUgPSB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmVydGV4LngsIHZlcnRleC55XTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHZlcnRpY2VzIGFyZSBjb25jYXZlIGFuZCBzaW1wbGUsIHdlIGNhbiBkZWNvbXBvc2UgaW50byBwYXJ0c1xuICAgICAgICAgICAgICAgIGRlY29tcC5tYWtlQ0NXKGNvbmNhdmUpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDb2xsaW5lYXIgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBkZWNvbXAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKGNvbmNhdmUsIHJlbW92ZUNvbGxpbmVhcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUR1cGxpY2F0ZVBvaW50cyAhPT0gZmFsc2UgJiYgZGVjb21wLnJlbW92ZUR1cGxpY2F0ZVBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wLnJlbW92ZUR1cGxpY2F0ZVBvaW50cyhjb25jYXZlLCByZW1vdmVEdXBsaWNhdGVQb2ludHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBxdWljayBkZWNvbXBvc2l0aW9uIGFsZ29yaXRobSAoQmF5YXppdClcbiAgICAgICAgICAgICAgICB2YXIgZGVjb21wb3NlZCA9IGRlY29tcC5xdWlja0RlY29tcChjb25jYXZlKTtcblxuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGRlY29tcG9zZWQgY2h1bmtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVjb21wb3NlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmsgPSBkZWNvbXBvc2VkW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmVydGljZXMgaW50byB0aGUgY29ycmVjdCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rVmVydGljZXMgPSBjaHVuay5tYXAoZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdmVydGljZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogdmVydGljZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgc21hbGwgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5pbXVtQXJlYSA+IDAgJiYgVmVydGljZXMuYXJlYShjaHVua1ZlcnRpY2VzKSA8IG1pbmltdW1BcmVhKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29tcG91bmQgcGFydFxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBWZXJ0aWNlcy5jZW50cmUoY2h1bmtWZXJ0aWNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogY2h1bmtWZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYm9keSBwYXJ0c1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZChwYXJ0c1tpXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmxhZyBpbnRlcm5hbCBlZGdlcyAoY29pbmNpZGVudCBwYXJ0IGVkZ2VzKVxuICAgICAgICBpZiAoZmxhZ0ludGVybmFsKSB7XG4gICAgICAgICAgICB2YXIgY29pbmNpZGVudF9tYXhfZGlzdCA9IDU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0QSA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEIgPSBwYXJ0c1tqXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKHBhcnRBLmJvdW5kcywgcGFydEIuYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdiA9IHBhcnRBLnZlcnRpY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBidiA9IHBhcnRCLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIHZlcnRpY2VzIG9mIGJvdGggcGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBwYXJ0QS52ZXJ0aWNlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IDA7IHogPCBwYXJ0Qi52ZXJ0aWNlcy5sZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGEgPSBWZWN0b3IubWFnbml0dWRlU3F1YXJlZChWZWN0b3Iuc3ViKHBhdlsoayArIDEpICUgcGF2Lmxlbmd0aF0sIHBidlt6XSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIgPSBWZWN0b3IubWFnbml0dWRlU3F1YXJlZChWZWN0b3Iuc3ViKHBhdltrXSwgcGJ2Wyh6ICsgMSkgJSBwYnYubGVuZ3RoXSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGJvdGggdmVydGljZXMgYXJlIHZlcnkgY2xvc2UsIGNvbnNpZGVyIHRoZSBlZGdlIGNvbmNpZGVudCAoaW50ZXJuYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYSA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QgJiYgZGIgPCBjb2luY2lkZW50X21heF9kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXZba10uaXNJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYnZbel0uaXNJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBhcmVudCBib2R5IHRvIGJlIHJldHVybmVkLCB0aGF0IGNvbnRhaW5zIGdlbmVyYXRlZCBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgYm9keSA9IEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBwYXJ0czogcGFydHMuc2xpY2UoMCkgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAvLyBvZmZzZXQgc3VjaCB0aGF0IGJvZHkucG9zaXRpb24gaXMgYXQgdGhlIGNlbnRyZSBvZmYgbWFzc1xuICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB7IHg6IHgsIHk6IHkgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5EZXRlY3RvcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGVmZmljaWVudGx5IGRldGVjdGluZyBjb2xsaXNpb25zIGJldHdlZW4gYSBsaXN0IG9mIGJvZGllcyB1c2luZyBhIGJyb2FkcGhhc2UgYWxnb3JpdGhtLlxuKlxuKiBAY2xhc3MgRGV0ZWN0b3JcbiovXG5cbnZhciBEZXRlY3RvciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERldGVjdG9yO1xuXG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBDb2xsaXNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpc2lvbiBkZXRlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7ZGV0ZWN0b3J9IEEgbmV3IGNvbGxpc2lvbiBkZXRlY3RvclxuICAgICAqL1xuICAgIERldGVjdG9yLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgYm9kaWVzOiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnM6IFtdLFxuICAgICAgICAgICAgcGFpcnM6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgYm9kaWVzIGluIHRoZSBkZXRlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHNldEJvZGllc1xuICAgICAqIEBwYXJhbSB7ZGV0ZWN0b3J9IGRldGVjdG9yXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIERldGVjdG9yLnNldEJvZGllcyA9IGZ1bmN0aW9uKGRldGVjdG9yLCBib2RpZXMpIHtcbiAgICAgICAgZGV0ZWN0b3IuYm9kaWVzID0gYm9kaWVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGRldGVjdG9yIGluY2x1ZGluZyBpdHMgbGlzdCBvZiBib2RpZXMuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7ZGV0ZWN0b3J9IGRldGVjdG9yXG4gICAgICovXG4gICAgRGV0ZWN0b3IuY2xlYXIgPSBmdW5jdGlvbihkZXRlY3Rvcikge1xuICAgICAgICBkZXRlY3Rvci5ib2RpZXMgPSBbXTtcbiAgICAgICAgZGV0ZWN0b3IuY29sbGlzaW9ucyA9IFtdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnRseSBmaW5kcyBhbGwgY29sbGlzaW9ucyBhbW9uZyBhbGwgdGhlIGJvZGllcyBpbiBgZGV0ZWN0b3IuYm9kaWVzYCB1c2luZyBhIGJyb2FkcGhhc2UgYWxnb3JpdGhtLlxuICAgICAqIFxuICAgICAqIF9Ob3RlOl8gVGhlIHNwZWNpZmljIG9yZGVyaW5nIG9mIGNvbGxpc2lvbnMgcmV0dXJuZWQgaXMgbm90IGd1YXJhbnRlZWQgYmV0d2VlbiByZWxlYXNlcyBhbmQgbWF5IGNoYW5nZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgKiBJZiBhIHNwZWNpZmljIG9yZGVyaW5nIGlzIHJlcXVpcmVkIHRoZW4gYXBwbHkgYSBzb3J0IHRvIHRoZSByZXN1bHRpbmcgYXJyYXkuXG4gICAgICogQG1ldGhvZCBjb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtkZXRlY3Rvcn0gZGV0ZWN0b3JcbiAgICAgKiBAcmV0dXJuIHtjb2xsaXNpb25bXX0gY29sbGlzaW9uc1xuICAgICAqL1xuICAgIERldGVjdG9yLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihkZXRlY3Rvcikge1xuICAgICAgICB2YXIgcGFpcnMgPSBkZXRlY3Rvci5wYWlycyxcbiAgICAgICAgICAgIGJvZGllcyA9IGRldGVjdG9yLmJvZGllcyxcbiAgICAgICAgICAgIGJvZGllc0xlbmd0aCA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgICAgICBjYW5Db2xsaWRlID0gRGV0ZWN0b3IuY2FuQ29sbGlkZSxcbiAgICAgICAgICAgIGNvbGxpZGVzID0gQ29sbGlzaW9uLmNvbGxpZGVzLFxuICAgICAgICAgICAgY29sbGlzaW9ucyA9IGRldGVjdG9yLmNvbGxpc2lvbnMsXG4gICAgICAgICAgICBjb2xsaXNpb25JbmRleCA9IDAsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBib2RpZXMuc29ydChEZXRlY3Rvci5fY29tcGFyZUJvdW5kc1gpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGJvdW5kc0EgPSBib2R5QS5ib3VuZHMsXG4gICAgICAgICAgICAgICAgYm91bmRYTWF4ID0gYm9keUEuYm91bmRzLm1heC54LFxuICAgICAgICAgICAgICAgIGJvdW5kWU1heCA9IGJvZHlBLmJvdW5kcy5tYXgueSxcbiAgICAgICAgICAgICAgICBib3VuZFlNaW4gPSBib2R5QS5ib3VuZHMubWluLnksXG4gICAgICAgICAgICAgICAgYm9keUFTdGF0aWMgPSBib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nLFxuICAgICAgICAgICAgICAgIHBhcnRzQUxlbmd0aCA9IGJvZHlBLnBhcnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwYXJ0c0FTaW5nbGUgPSBwYXJ0c0FMZW5ndGggPT09IDE7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgYm9kaWVzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUIgPSBib2RpZXNbal0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kc0IgPSBib2R5Qi5ib3VuZHM7XG5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzQi5taW4ueCA+IGJvdW5kWE1heCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRZTWF4IDwgYm91bmRzQi5taW4ueSB8fCBib3VuZFlNaW4gPiBib3VuZHNCLm1heC55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChib2R5QVN0YXRpYyAmJiAoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5Db2xsaWRlKGJvZHlBLmNvbGxpc2lvbkZpbHRlciwgYm9keUIuY29sbGlzaW9uRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFydHNCTGVuZ3RoID0gYm9keUIucGFydHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzQVNpbmdsZSAmJiBwYXJ0c0JMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpZGVzKGJvZHlBLCBib2R5QiwgcGFpcnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnNbY29sbGlzaW9uSW5kZXgrK10gPSBjb2xsaXNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHNBU3RhcnQgPSBwYXJ0c0FMZW5ndGggPiAxID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c0JTdGFydCA9IHBhcnRzQkxlbmd0aCA+IDEgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBwYXJ0c0FTdGFydDsgayA8IHBhcnRzQUxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEEgPSBib2R5QS5wYXJ0c1trXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHNBID0gcGFydEEuYm91bmRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gcGFydHNCU3RhcnQ7IHogPCBwYXJ0c0JMZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IGJvZHlCLnBhcnRzW3pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHNCID0gcGFydEIuYm91bmRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kc0EubWluLnggPiBib3VuZHNCLm1heC54IHx8IGJvdW5kc0EubWF4LnggPCBib3VuZHNCLm1pbi54XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGJvdW5kc0EubWF4LnkgPCBib3VuZHNCLm1pbi55IHx8IGJvdW5kc0EubWluLnkgPiBib3VuZHNCLm1heC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaWRlcyhwYXJ0QSwgcGFydEIsIHBhaXJzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uc1tjb2xsaXNpb25JbmRleCsrXSA9IGNvbGxpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sbGlzaW9ucy5sZW5ndGggIT09IGNvbGxpc2lvbkluZGV4KSB7XG4gICAgICAgICAgICBjb2xsaXNpb25zLmxlbmd0aCA9IGNvbGxpc2lvbkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggc3VwcGxpZWQgY29sbGlzaW9uIGZpbHRlcnMgd2lsbCBhbGxvdyBhIGNvbGxpc2lvbiB0byBvY2N1ci5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAbWV0aG9kIGNhbkNvbGxpZGVcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQVxuICAgICAqIEBwYXJhbSB7fSBmaWx0ZXJCXG4gICAgICogQHJldHVybiB7Ym9vbH0gYHRydWVgIGlmIGNvbGxpc2lvbiBjYW4gb2NjdXJcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5jYW5Db2xsaWRlID0gZnVuY3Rpb24oZmlsdGVyQSwgZmlsdGVyQikge1xuICAgICAgICBpZiAoZmlsdGVyQS5ncm91cCA9PT0gZmlsdGVyQi5ncm91cCAmJiBmaWx0ZXJBLmdyb3VwICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckEuZ3JvdXAgPiAwO1xuXG4gICAgICAgIHJldHVybiAoZmlsdGVyQS5tYXNrICYgZmlsdGVyQi5jYXRlZ29yeSkgIT09IDAgJiYgKGZpbHRlckIubWFzayAmIGZpbHRlckEuY2F0ZWdvcnkpICE9PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiB1c2VkIGluIHRoZSBicm9hZHBoYXNlIGFsZ29yaXRobS5cbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduZWQgZGVsdGEgb2YgdGhlIGJvZGllcyBib3VuZHMgb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgX3NvcnRDb21wYXJlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaWduZWQgZGVsdGEgdXNlZCBmb3Igc29ydGluZ1xuICAgICAqL1xuICAgIERldGVjdG9yLl9jb21wYXJlQm91bmRzWCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICByZXR1cm4gYm9keUEuYm91bmRzLm1pbi54IC0gYm9keUIuYm91bmRzLm1pbi54O1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBgTWF0dGVyLkJvZHlgIGJldHdlZW4gd2hpY2ggdGhlIGRldGVjdG9yIGZpbmRzIGNvbGxpc2lvbnMuXG4gICAgICogXG4gICAgICogX05vdGU6XyBUaGUgb3JkZXIgb2YgYm9kaWVzIGluIHRoaXMgYXJyYXkgX2lzIG5vdCBmaXhlZF8gYW5kIHdpbGwgYmUgY29udGludWFsbHkgbWFuYWdlZCBieSB0aGUgZGV0ZWN0b3IuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIGJvZHlbXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgYE1hdHRlci5Db2xsaXNpb25gIGZvdW5kIGluIHRoZSBsYXN0IGNhbGwgdG8gYERldGVjdG9yLmNvbGxpc2lvbnNgIG9uIHRoaXMgZGV0ZWN0b3IuXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBjb2xsaXNpb25bXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gQSBgTWF0dGVyLlBhaXJzYCBvYmplY3QgZnJvbSB3aGljaCBwcmV2aW91cyBjb2xsaXNpb24gb2JqZWN0cyBtYXkgYmUgcmV1c2VkLiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgYE1hdHRlci5FbmdpbmVgIHVzYWdlLlxuICAgICAqIEBwcm9wZXJ0eSBwYWlyc1xuICAgICAqIEB0eXBlIHtwYWlyc3xudWxsfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Nb3VzZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgbW91c2UgaW5wdXRzLlxuKlxuKiBAY2xhc3MgTW91c2VcbiovXG5cbnZhciBNb3VzZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlO1xuXG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1vdXNlIGlucHV0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge21vdXNlfSBBIG5ldyBtb3VzZVxuICAgICAqL1xuICAgIE1vdXNlLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlID0ge307XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBDb21tb24ubG9nKCdNb3VzZS5jcmVhdGU6IGVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgZGVmYXVsdGluZyB0byBkb2N1bWVudC5ib2R5JywgJ3dhcm4nKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbW91c2UuZWxlbWVudCA9IGVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgbW91c2UuYWJzb2x1dGUgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UubW91c2V1cFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5zY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gMDtcbiAgICAgICAgbW91c2UuYnV0dG9uID0gLTE7XG4gICAgICAgIG1vdXNlLnBpeGVsUmF0aW8gPSBwYXJzZUludChtb3VzZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1waXhlbC1yYXRpbycpLCAxMCkgfHwgMTtcblxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMgPSB7XG4gICAgICAgICAgICBtb3VzZW1vdmU6IG51bGwsXG4gICAgICAgICAgICBtb3VzZWRvd246IG51bGwsXG4gICAgICAgICAgICBtb3VzZXVwOiBudWxsLFxuICAgICAgICAgICAgbW91c2V3aGVlbDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW91c2UubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHsgXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmUgPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgICAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gTW91c2UuX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbihldmVudCwgbW91c2UuZWxlbWVudCwgbW91c2UucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IC0xO1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueSA9IG1vdXNlLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IGV2ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIG1vdXNlLm1vdXNld2hlZWwgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V3aGVlbCA9IGV2ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIE1vdXNlLnNldEVsZW1lbnQobW91c2UsIG1vdXNlLmVsZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiBtb3VzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZWxlbWVudCB0aGUgbW91c2UgaXMgYm91bmQgdG8gKGFuZCByZWxhdGl2ZSB0bykuXG4gICAgICogQG1ldGhvZCBzZXRFbGVtZW50XG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgTW91c2Uuc2V0RWxlbWVudCA9IGZ1bmN0aW9uKG1vdXNlLCBlbGVtZW50KSB7XG4gICAgICAgIG1vdXNlLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2UubW91c2Vtb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2UubW91c2Vkb3duLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlLm1vdXNldXAsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBtb3VzZS5tb3VzZXdoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3VzZS5tb3VzZW1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG1vdXNlLm1vdXNlZG93biwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG1vdXNlLm1vdXNldXAsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2FwdHVyZWQgc291cmNlIGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIGNsZWFyU291cmNlRXZlbnRzXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcbiAgICAgKi9cbiAgICBNb3VzZS5jbGVhclNvdXJjZUV2ZW50cyA9IGZ1bmN0aW9uKG1vdXNlKSB7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmUgPSBudWxsO1xuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2Vkb3duID0gbnVsbDtcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNldXAgPSBudWxsO1xuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V3aGVlbCA9IG51bGw7XG4gICAgICAgIG1vdXNlLndoZWVsRGVsdGEgPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiBvZmZzZXQuXG4gICAgICogQG1ldGhvZCBzZXRPZmZzZXRcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBvZmZzZXRcbiAgICAgKi9cbiAgICBNb3VzZS5zZXRPZmZzZXQgPSBmdW5jdGlvbihtb3VzZSwgb2Zmc2V0KSB7XG4gICAgICAgIG1vdXNlLm9mZnNldC54ID0gb2Zmc2V0Lng7XG4gICAgICAgIG1vdXNlLm9mZnNldC55ID0gb2Zmc2V0Lnk7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW91c2UgcG9zaXRpb24gc2NhbGUuXG4gICAgICogQG1ldGhvZCBzZXRTY2FsZVxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHNjYWxlXG4gICAgICovXG4gICAgTW91c2Uuc2V0U2NhbGUgPSBmdW5jdGlvbihtb3VzZSwgc2NhbGUpIHtcbiAgICAgICAgbW91c2Uuc2NhbGUueCA9IHNjYWxlLng7XG4gICAgICAgIG1vdXNlLnNjYWxlLnkgPSBzY2FsZS55O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBhbiBlbGVtZW50IGdpdmVuIGEgc2NyZWVuIHBpeGVsIHJhdGlvLlxuICAgICAqIEBtZXRob2QgX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGV2ZW50XG4gICAgICogQHBhcmFtIHt9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpb1xuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQsIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgdmFyIGVsZW1lbnRCb3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgcm9vdE5vZGUgPSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5KSxcbiAgICAgICAgICAgIHNjcm9sbFggPSAod2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogcm9vdE5vZGUuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFkgPSAod2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQpID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogcm9vdE5vZGUuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgICAgeCwgeTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICB4ID0gdG91Y2hlc1swXS5wYWdlWCAtIGVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbFg7XG4gICAgICAgICAgICB5ID0gdG91Y2hlc1swXS5wYWdlWSAtIGVsZW1lbnRCb3VuZHMudG9wIC0gc2Nyb2xsWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBldmVudC5wYWdlWCAtIGVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbFg7XG4gICAgICAgICAgICB5ID0gZXZlbnQucGFnZVkgLSBlbGVtZW50Qm91bmRzLnRvcCAtIHNjcm9sbFk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIHg6IHggLyAoZWxlbWVudC5jbGllbnRXaWR0aCAvIChlbGVtZW50LndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGgpICogcGl4ZWxSYXRpbyksXG4gICAgICAgICAgICB5OiB5IC8gKGVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gKGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSAqIHBpeGVsUmF0aW8pXG4gICAgICAgIH07XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5QbHVnaW5gIG1vZHVsZSBjb250YWlucyBmdW5jdGlvbnMgZm9yIHJlZ2lzdGVyaW5nIGFuZCBpbnN0YWxsaW5nIHBsdWdpbnMgb24gbW9kdWxlcy5cbipcbiogQGNsYXNzIFBsdWdpblxuKi9cblxudmFyIFBsdWdpbiA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsdWdpbjtcblxudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIFBsdWdpbi5fcmVnaXN0cnkgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHBsdWdpbiBvYmplY3Qgc28gaXQgY2FuIGJlIHJlc29sdmVkIGxhdGVyIGJ5IG5hbWUuXG4gICAgICogQG1ldGhvZCByZWdpc3RlclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbiB0byByZWdpc3Rlci5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwbHVnaW4uXG4gICAgICovXG4gICAgUGx1Z2luLnJlZ2lzdGVyID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIGlmICghUGx1Z2luLmlzUGx1Z2luKHBsdWdpbikpIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdkb2VzIG5vdCBpbXBsZW1lbnQgYWxsIHJlcXVpcmVkIGZpZWxkcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbHVnaW4ubmFtZSBpbiBQbHVnaW4uX3JlZ2lzdHJ5KSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZCA9IFBsdWdpbi5fcmVnaXN0cnlbcGx1Z2luLm5hbWVdLFxuICAgICAgICAgICAgICAgIHBsdWdpblZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHBsdWdpbi52ZXJzaW9uKS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFZlcnNpb24gPSBQbHVnaW4udmVyc2lvblBhcnNlKHJlZ2lzdGVyZWQudmVyc2lvbikubnVtYmVyO1xuXG4gICAgICAgICAgICBpZiAocGx1Z2luVmVyc2lvbiA+IHJlZ2lzdGVyZWRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocmVnaXN0ZXJlZCksICd3YXMgdXBncmFkZWQgdG8nLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpblZlcnNpb24gPCByZWdpc3RlcmVkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHJlZ2lzdGVyZWQpLCAnY2FuIG5vdCBiZSBkb3duZ3JhZGVkIHRvJywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwbHVnaW4gIT09IHJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnJlZ2lzdGVyOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnaXMgYWxyZWFkeSByZWdpc3RlcmVkIHRvIGRpZmZlcmVudCBwbHVnaW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGEgZGVwZW5kZW5jeSB0byBhIHBsdWdpbiBvYmplY3QgZnJvbSB0aGUgcmVnaXN0cnkgaWYgaXQgZXhpc3RzLiBcbiAgICAgKiBUaGUgYGRlcGVuZGVuY3lgIG1heSBjb250YWluIGEgdmVyc2lvbiwgYnV0IG9ubHkgdGhlIG5hbWUgbWF0dGVycyB3aGVuIHJlc29sdmluZy5cbiAgICAgKiBAbWV0aG9kIHJlc29sdmVcbiAgICAgKiBAcGFyYW0gZGVwZW5kZW5jeSB7c3RyaW5nfSBUaGUgZGVwZW5kZW5jeS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwbHVnaW4gaWYgcmVzb2x2ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBQbHVnaW4ucmVzb2x2ZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbi5fcmVnaXN0cnlbUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KS5uYW1lXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByZXR0eSBwcmludGVkIHBsdWdpbiBuYW1lIGFuZCB2ZXJzaW9uLlxuICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgKiBAcGFyYW0gcGx1Z2luIHt9IFRoZSBwbHVnaW4uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBQcmV0dHkgcHJpbnRlZCBwbHVnaW4gbmFtZSBhbmQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBQbHVnaW4udG9TdHJpbmcgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gcGx1Z2luIDogKHBsdWdpbi5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICdAJyArIChwbHVnaW4udmVyc2lvbiB8fCBwbHVnaW4ucmFuZ2UgfHwgJzAuMC4wJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWVldHMgdGhlIG1pbmltdW0gc3RhbmRhcmQgdG8gYmUgY29uc2lkZXJlZCBhIHBsdWdpbi5cbiAgICAgKiBUaGlzIG1lYW5zIGl0IG11c3QgZGVmaW5lIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAtIGBuYW1lYFxuICAgICAqIC0gYHZlcnNpb25gXG4gICAgICogLSBgaW5zdGFsbGBcbiAgICAgKiBAbWV0aG9kIGlzUGx1Z2luXG4gICAgICogQHBhcmFtIG9iaiB7fSBUaGUgb2JqIHRvIHRlc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgY2FuIGJlIGNvbnNpZGVyZWQgYSBwbHVnaW4gb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLmlzUGx1Z2luID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqLm5hbWUgJiYgb2JqLnZlcnNpb24gJiYgb2JqLmluc3RhbGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYC5cbiAgICAgKiBAbWV0aG9kIGlzVXNlZFxuICAgICAqIEBwYXJhbSBtb2R1bGUge30gVGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBUaGUgcGx1Z2luIG5hbWUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgcGx1Z2luIHdpdGggdGhlIGdpdmVuIGBuYW1lYCBiZWVuIGluc3RhbGxlZCBvbiBgbW9kdWxlYCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgUGx1Z2luLmlzVXNlZCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnVzZWQuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgcGx1Z2luLmZvcmAgaXMgYXBwbGljYWJsZSB0byBgbW9kdWxlYCBieSBjb21wYXJpbmcgYWdhaW5zdCBgbW9kdWxlLm5hbWVgIGFuZCBgbW9kdWxlLnZlcnNpb25gLlxuICAgICAqIElmIGBwbHVnaW4uZm9yYCBpcyBub3Qgc3BlY2lmaWVkIHRoZW4gaXQgaXMgYXNzdW1lZCB0byBiZSBhcHBsaWNhYmxlLlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgcGx1Z2luLmZvcmAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXG4gICAgICogQG1ldGhvZCBpc0ZvclxuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbi5cbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGBwbHVnaW4uZm9yYCBpcyBhcHBsaWNhYmxlIHRvIGBtb2R1bGVgLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBQbHVnaW4uaXNGb3IgPSBmdW5jdGlvbihwbHVnaW4sIG1vZHVsZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGx1Z2luLmZvciAmJiBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKHBsdWdpbi5mb3IpO1xuICAgICAgICByZXR1cm4gIXBsdWdpbi5mb3IgfHwgKG1vZHVsZS5uYW1lID09PSBwYXJzZWQubmFtZSAmJiBQbHVnaW4udmVyc2lvblNhdGlzZmllcyhtb2R1bGUudmVyc2lvbiwgcGFyc2VkLnJhbmdlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc3RhbGxzIHRoZSBwbHVnaW5zIGJ5IGNhbGxpbmcgYHBsdWdpbi5pbnN0YWxsYCBvbiBlYWNoIHBsdWdpbiBzcGVjaWZpZWQgaW4gYHBsdWdpbnNgIGlmIHBhc3NlZCwgb3RoZXJ3aXNlIGBtb2R1bGUudXNlc2AuXG4gICAgICogRm9yIGluc3RhbGxpbmcgcGx1Z2lucyBvbiBgTWF0dGVyYCBzZWUgdGhlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGBNYXR0ZXIudXNlYC5cbiAgICAgKiBQbHVnaW5zIG1heSBiZSBzcGVjaWZpZWQgZWl0aGVyIGJ5IHRoZWlyIG5hbWUgb3IgYSByZWZlcmVuY2UgdG8gdGhlIHBsdWdpbiBvYmplY3QuXG4gICAgICogUGx1Z2lucyB0aGVtc2VsdmVzIG1heSBzcGVjaWZ5IGZ1cnRoZXIgZGVwZW5kZW5jaWVzLCBidXQgZWFjaCBwbHVnaW4gaXMgaW5zdGFsbGVkIG9ubHkgb25jZS5cbiAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnQsIGEgdG9wb2xvZ2ljYWwgc29ydCBpcyBwZXJmb3JtZWQgdG8gZmluZCB0aGUgYmVzdCByZXN1bHRpbmcgb3JkZXIgb2YgaW5zdGFsbGF0aW9uLlxuICAgICAqIFRoaXMgc29ydGluZyBhdHRlbXB0cyB0byBzYXRpc2Z5IGV2ZXJ5IGRlcGVuZGVuY3kncyByZXF1ZXN0ZWQgb3JkZXJpbmcsIGJ1dCBtYXkgbm90IGJlIGV4YWN0IGluIGFsbCBjYXNlcy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGxvZ3MgdGhlIHJlc3VsdGluZyBzdGF0dXMgb2YgZWFjaCBkZXBlbmRlbmN5IGluIHRoZSBjb25zb2xlLCBhbG9uZyB3aXRoIGFueSB3YXJuaW5ncy5cbiAgICAgKiAtIEEgZ3JlZW4gdGljayDinIUgaW5kaWNhdGVzIGEgZGVwZW5kZW5jeSB3YXMgcmVzb2x2ZWQgYW5kIGluc3RhbGxlZC5cbiAgICAgKiAtIEFuIG9yYW5nZSBkaWFtb25kIPCflLYgaW5kaWNhdGVzIGEgZGVwZW5kZW5jeSB3YXMgcmVzb2x2ZWQgYnV0IGEgd2FybmluZyB3YXMgdGhyb3duIGZvciBpdCBvciBvbmUgaWYgaXRzIGRlcGVuZGVuY2llcy5cbiAgICAgKiAtIEEgcmVkIGNyb3NzIOKdjCBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IGNvdWxkIG5vdCBiZSByZXNvbHZlZC5cbiAgICAgKiBBdm9pZCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgbW9kdWxlIHVubGVzcyB5b3UgaW50ZW5kIHRvIG1hbnVhbGx5IGNvbnRyb2wgaW5zdGFsbGF0aW9uIG9yZGVyLlxuICAgICAqIEBtZXRob2QgdXNlXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlIGluc3RhbGwgcGx1Z2lucyBvbi5cbiAgICAgKiBAcGFyYW0gW3BsdWdpbnM9bW9kdWxlLnVzZXNdIHt9IFRoZSBwbHVnaW5zIHRvIGluc3RhbGwgb24gbW9kdWxlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gYG1vZHVsZS51c2VzYCkuXG4gICAgICovXG4gICAgUGx1Z2luLnVzZSA9IGZ1bmN0aW9uKG1vZHVsZSwgcGx1Z2lucykge1xuICAgICAgICBtb2R1bGUudXNlcyA9IChtb2R1bGUudXNlcyB8fCBbXSkuY29uY2F0KHBsdWdpbnMgfHwgW10pO1xuXG4gICAgICAgIGlmIChtb2R1bGUudXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udXNlOicsIFBsdWdpbi50b1N0cmluZyhtb2R1bGUpLCAnZG9lcyBub3Qgc3BlY2lmeSBhbnkgZGVwZW5kZW5jaWVzIHRvIGluc3RhbGwuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gUGx1Z2luLmRlcGVuZGVuY2llcyhtb2R1bGUpLFxuICAgICAgICAgICAgc29ydGVkRGVwZW5kZW5jaWVzID0gQ29tbW9uLnRvcG9sb2dpY2FsU29ydChkZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICAgc3RhdHVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChzb3J0ZWREZXBlbmRlbmNpZXNbaV0gPT09IG1vZHVsZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSBQbHVnaW4ucmVzb2x2ZShzb3J0ZWREZXBlbmRlbmNpZXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoIXBsdWdpbikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5wdXNoKCfinYwgJyArIHNvcnRlZERlcGVuZGVuY2llc1tpXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChQbHVnaW4uaXNVc2VkKG1vZHVsZSwgcGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghUGx1Z2luLmlzRm9yKHBsdWdpbiwgbW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udXNlOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnaXMgZm9yJywgcGx1Z2luLmZvciwgJ2J1dCBpbnN0YWxsZWQgb24nLCBQbHVnaW4udG9TdHJpbmcobW9kdWxlKSArICcuJyk7XG4gICAgICAgICAgICAgICAgcGx1Z2luLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChtb2R1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnVzZTonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2RvZXMgbm90IHNwZWNpZnkgYW4gaW5zdGFsbCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICBwbHVnaW4uX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4uX3dhcm5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5wdXNoKCfwn5S2ICcgKyBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpbi5fd2FybmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMucHVzaCgn4pyFICcgKyBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZHVsZS51c2VkLnB1c2gocGx1Z2luLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXR1cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBDb21tb24uaW5mbyhzdGF0dXMuam9pbignICAnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmluZHMgYWxsIG9mIGEgbW9kdWxlJ3MgZGVwZW5kZW5jaWVzIGFuZCByZXR1cm5zIGEgZmxhdCBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBkZXBlbmRlbmN5IGdyYXBoLlxuICAgICAqL1xuICAgIFBsdWdpbi5kZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUsIHRyYWNrZWQpIHtcbiAgICAgICAgdmFyIHBhcnNlZEJhc2UgPSBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKG1vZHVsZSksXG4gICAgICAgICAgICBuYW1lID0gcGFyc2VkQmFzZS5uYW1lO1xuXG4gICAgICAgIHRyYWNrZWQgPSB0cmFja2VkIHx8IHt9O1xuXG4gICAgICAgIGlmIChuYW1lIGluIHRyYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZSA9IFBsdWdpbi5yZXNvbHZlKG1vZHVsZSkgfHwgbW9kdWxlO1xuXG4gICAgICAgIHRyYWNrZWRbbmFtZV0gPSBDb21tb24ubWFwKG1vZHVsZS51c2VzIHx8IFtdLCBmdW5jdGlvbihkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICBpZiAoUGx1Z2luLmlzUGx1Z2luKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgUGx1Z2luLnJlZ2lzdGVyKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gUGx1Z2luLmRlcGVuZGVuY3lQYXJzZShkZXBlbmRlbmN5KSxcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IFBsdWdpbi5yZXNvbHZlKGRlcGVuZGVuY3kpO1xuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgJiYgIVBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzKHJlc29sdmVkLnZlcnNpb24sIHBhcnNlZC5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ1BsdWdpbi5kZXBlbmRlbmNpZXM6JywgUGx1Z2luLnRvU3RyaW5nKHJlc29sdmVkKSwgJ2RvZXMgbm90IHNhdGlzZnknLFxuICAgICAgICAgICAgICAgICAgICBQbHVnaW4udG9TdHJpbmcocGFyc2VkKSwgJ3VzZWQgYnknLCBQbHVnaW4udG9TdHJpbmcocGFyc2VkQmFzZSkgKyAnLidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQuX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW9kdWxlLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ1BsdWdpbi5kZXBlbmRlbmNpZXM6JywgUGx1Z2luLnRvU3RyaW5nKGRlcGVuZGVuY3kpLCAndXNlZCBieScsXG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b1N0cmluZyhwYXJzZWRCYXNlKSwgJ2NvdWxkIG5vdCBiZSByZXNvbHZlZC4nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIG1vZHVsZS5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5uYW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrZWRbbmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIFBsdWdpbi5kZXBlbmRlbmNpZXModHJhY2tlZFtuYW1lXVtpXSwgdHJhY2tlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhY2tlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgZGVwZW5kZW5jeSBzdHJpbmcgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICAgKiBUaGUgYGRlcGVuZGVuY3lgIGlzIGEgc3RyaW5nIG9mIHRoZSBmb3JtYXQgYCdtb2R1bGUtbmFtZSdgIG9yIGAnbW9kdWxlLW5hbWVAdmVyc2lvbidgLlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGhhbmRsZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgYWxyZWFkeSByZXNvbHZlZCAoZS5nLiBhIG1vZHVsZSBvYmplY3QpLlxuICAgICAqIEBtZXRob2QgZGVwZW5kZW5jeVBhcnNlXG4gICAgICogQHBhcmFtIGRlcGVuZGVuY3kge3N0cmluZ30gVGhlIGRlcGVuZGVuY3kgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZGVwZW5kZW5jeSBwYXJzZWQgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzU3RyaW5nKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IC9eW1xcdy1dKyhAKFxcKnxbXFxefl0/XFxkK1xcLlxcZCtcXC5cXGQrKC1bMC05QS1aYS16LStdKyk/KSk/JC87XG5cbiAgICAgICAgICAgIGlmICghcGF0dGVybi50ZXN0KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5kZXBlbmRlbmN5UGFyc2U6JywgZGVwZW5kZW5jeSwgJ2lzIG5vdCBhIHZhbGlkIGRlcGVuZGVuY3kgc3RyaW5nLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kuc3BsaXQoJ0AnKVswXSxcbiAgICAgICAgICAgICAgICByYW5nZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzFdIHx8ICcqJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBkZXBlbmRlbmN5Lm5hbWUsXG4gICAgICAgICAgICByYW5nZTogZGVwZW5kZW5jeS5yYW5nZSB8fCBkZXBlbmRlbmN5LnZlcnNpb25cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgdmVyc2lvbiBzdHJpbmcgaW50byBpdHMgY29tcG9uZW50cy4gIFxuICAgICAqIFZlcnNpb25zIGFyZSBzdHJpY3RseSBvZiB0aGUgZm9ybWF0IGB4LnkuemAgKGFzIGluIFtzZW12ZXJdKGh0dHA6Ly9zZW12ZXIub3JnLykpLlxuICAgICAqIFZlcnNpb25zIG1heSBvcHRpb25hbGx5IGhhdmUgYSBwcmVyZWxlYXNlIHRhZyBpbiB0aGUgZm9ybWF0IGB4Lnkuei1hbHBoYWAuXG4gICAgICogUmFuZ2VzIGFyZSBhIHN0cmljdCBzdWJzZXQgb2YgW25wbSByYW5nZXNdKGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vbWlzYy9zZW12ZXIjYWR2YW5jZWQtcmFuZ2Utc3ludGF4KS5cbiAgICAgKiBPbmx5IHRoZSBmb2xsb3dpbmcgcmFuZ2UgdHlwZXMgYXJlIHN1cHBvcnRlZDpcbiAgICAgKiAtIFRpbGRlIHJhbmdlcyBlLmcuIGB+MS4yLjNgXG4gICAgICogLSBDYXJldCByYW5nZXMgZS5nLiBgXjEuMi4zYFxuICAgICAqIC0gR3JlYXRlciB0aGFuIHJhbmdlcyBlLmcuIGA+MS4yLjNgXG4gICAgICogLSBHcmVhdGVyIHRoYW4gb3IgZXF1YWwgcmFuZ2VzIGUuZy4gYD49MS4yLjNgXG4gICAgICogLSBFeGFjdCB2ZXJzaW9uIGUuZy4gYDEuMi4zYFxuICAgICAqIC0gQW55IHZlcnNpb24gYCpgXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uUGFyc2VcbiAgICAgKiBAcGFyYW0gcmFuZ2Uge3N0cmluZ30gVGhlIHZlcnNpb24gc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHZlcnNpb24gcmFuZ2UgcGFyc2VkIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgUGx1Z2luLnZlcnNpb25QYXJzZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gL14oXFwqKXwoXFxefH58Pj18Pik/XFxzKigoXFxkKylcXC4oXFxkKylcXC4oXFxkKykpKC1bMC05QS1aYS16LStdKyk/JC87XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QocmFuZ2UpKSB7XG4gICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnZlcnNpb25QYXJzZTonLCByYW5nZSwgJ2lzIG5vdCBhIHZhbGlkIHZlcnNpb24gb3IgcmFuZ2UuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydHMgPSBwYXR0ZXJuLmV4ZWMocmFuZ2UpO1xuICAgICAgICB2YXIgbWFqb3IgPSBOdW1iZXIocGFydHNbNF0pO1xuICAgICAgICB2YXIgbWlub3IgPSBOdW1iZXIocGFydHNbNV0pO1xuICAgICAgICB2YXIgcGF0Y2ggPSBOdW1iZXIocGFydHNbNl0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1JhbmdlOiBCb29sZWFuKHBhcnRzWzFdIHx8IHBhcnRzWzJdKSxcbiAgICAgICAgICAgIHZlcnNpb246IHBhcnRzWzNdLFxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgb3BlcmF0b3I6IHBhcnRzWzFdIHx8IHBhcnRzWzJdIHx8ICcnLFxuICAgICAgICAgICAgbWFqb3I6IG1ham9yLFxuICAgICAgICAgICAgbWlub3I6IG1pbm9yLFxuICAgICAgICAgICAgcGF0Y2g6IHBhdGNoLFxuICAgICAgICAgICAgcGFydHM6IFttYWpvciwgbWlub3IsIHBhdGNoXSxcbiAgICAgICAgICAgIHByZXJlbGVhc2U6IHBhcnRzWzddLFxuICAgICAgICAgICAgbnVtYmVyOiBtYWpvciAqIDFlOCArIG1pbm9yICogMWU0ICsgcGF0Y2hcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYHZlcnNpb25gIHNhdGlzZmllcyB0aGUgZ2l2ZW4gYHJhbmdlYC5cbiAgICAgKiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgYFBsdWdpbi52ZXJzaW9uUGFyc2VgIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBmb3JtYXQuXG4gICAgICogSWYgYSB2ZXJzaW9uIG9yIHJhbmdlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gYW55IHZlcnNpb24gKGAqYCkgaXMgYXNzdW1lZCB0byBzYXRpc2Z5LlxuICAgICAqIEBtZXRob2QgdmVyc2lvblNhdGlzZmllc1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHtzdHJpbmd9IFRoZSB2ZXJzaW9uIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gcmFuZ2Uge3N0cmluZ30gVGhlIHJhbmdlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHZlcnNpb25gIHNhdGlzZmllcyBgcmFuZ2VgLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBQbHVnaW4udmVyc2lvblNhdGlzZmllcyA9IGZ1bmN0aW9uKHZlcnNpb24sIHJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gcmFuZ2UgfHwgJyonO1xuXG4gICAgICAgIHZhciByID0gUGx1Z2luLnZlcnNpb25QYXJzZShyYW5nZSksXG4gICAgICAgICAgICB2ID0gUGx1Z2luLnZlcnNpb25QYXJzZSh2ZXJzaW9uKTtcblxuICAgICAgICBpZiAoci5pc1JhbmdlKSB7XG4gICAgICAgICAgICBpZiAoci5vcGVyYXRvciA9PT0gJyonIHx8IHZlcnNpb24gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoci5vcGVyYXRvciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYubnVtYmVyID4gci5udW1iZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYubnVtYmVyID49IHIubnVtYmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoci5vcGVyYXRvciA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYubWFqb3IgPT09IHIubWFqb3IgJiYgdi5taW5vciA9PT0gci5taW5vciAmJiB2LnBhdGNoID49IHIucGF0Y2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLm9wZXJhdG9yID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICBpZiAoci5tYWpvciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubWFqb3IgPT09IHIubWFqb3IgJiYgdi5udW1iZXIgPj0gci5udW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHIubWlub3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2Lm1pbm9yID09PSByLm1pbm9yICYmIHYucGF0Y2ggPj0gci5wYXRjaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdi5wYXRjaCA9PT0gci5wYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZXJzaW9uID09PSByYW5nZSB8fCB2ZXJzaW9uID09PSAnKic7XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Db250YWN0YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gY29udGFjdHMuXG4qXG4qIEBjbGFzcyBDb250YWN0XG4qL1xuXG52YXIgQ29udGFjdCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3Q7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29udGFjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGV4fSBbdmVydGV4XVxuICAgICAqIEByZXR1cm4ge2NvbnRhY3R9IEEgbmV3IGNvbnRhY3RcbiAgICAgKi9cbiAgICBDb250YWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVydGV4OiB2ZXJ0ZXgsXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlOiAwLFxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2U6IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkVuZ2luZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgZW5naW5lcy5cbiogQW4gZW5naW5lIGlzIGEgY29udHJvbGxlciB0aGF0IG1hbmFnZXMgdXBkYXRpbmcgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHdvcmxkLlxuKiBTZWUgYE1hdHRlci5SdW5uZXJgIGZvciBhbiBvcHRpb25hbCBnYW1lIGxvb3AgdXRpbGl0eS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIEVuZ2luZVxuKi9cblxudmFyIEVuZ2luZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcblxudmFyIFNsZWVwaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBSZXNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIERldGVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUGFpcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbXBvc2l0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgQ29uc3RyYWludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm9keSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIEVuZ2luZS5fZGVsdGFNYXggPSAxMDAwIC8gNjA7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGVuZ2luZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge2VuZ2luZX0gZW5naW5lXG4gICAgICovXG4gICAgRW5naW5lLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgcG9zaXRpb25JdGVyYXRpb25zOiA2LFxuICAgICAgICAgICAgdmVsb2NpdHlJdGVyYXRpb25zOiA0LFxuICAgICAgICAgICAgY29uc3RyYWludEl0ZXJhdGlvbnM6IDIsXG4gICAgICAgICAgICBlbmFibGVTbGVlcGluZzogZmFsc2UsXG4gICAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcbiAgICAgICAgICAgIGdyYXZpdHk6IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDEsXG4gICAgICAgICAgICAgICAgc2NhbGU6IDAuMDAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltaW5nOiB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBsYXN0RGVsdGE6IDAsXG4gICAgICAgICAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgICAgICAgICAgbGFzdFVwZGF0ZXNQZXJGcmFtZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlbmdpbmUgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBlbmdpbmUud29ybGQgPSBvcHRpb25zLndvcmxkIHx8IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ1dvcmxkJyB9KTtcbiAgICAgICAgZW5naW5lLnBhaXJzID0gb3B0aW9ucy5wYWlycyB8fCBQYWlycy5jcmVhdGUoKTtcbiAgICAgICAgZW5naW5lLmRldGVjdG9yID0gb3B0aW9ucy5kZXRlY3RvciB8fCBEZXRlY3Rvci5jcmVhdGUoKTtcbiAgICAgICAgZW5naW5lLmRldGVjdG9yLnBhaXJzID0gZW5naW5lLnBhaXJzO1xuXG4gICAgICAgIC8vIGZvciB0ZW1wb3JhcnkgYmFjayBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgICAgZW5naW5lLmdyaWQgPSB7IGJ1Y2tldHM6IFtdIH07XG4gICAgICAgIGVuZ2luZS53b3JsZC5ncmF2aXR5ID0gZW5naW5lLmdyYXZpdHk7XG4gICAgICAgIGVuZ2luZS5icm9hZHBoYXNlID0gZW5naW5lLmdyaWQ7XG4gICAgICAgIGVuZ2luZS5tZXRyaWNzID0ge307XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgc2ltdWxhdGlvbiBmb3J3YXJkIGluIHRpbWUgYnkgYGRlbHRhYCBtaWxsaXNlY29uZHMuXG4gICAgICogVHJpZ2dlcnMgYGJlZm9yZVVwZGF0ZWAsIGBiZWZvcmVTb2x2ZWAgYW5kIGBhZnRlclVwZGF0ZWAgZXZlbnRzLlxuICAgICAqIFRyaWdnZXJzIGBjb2xsaXNpb25TdGFydGAsIGBjb2xsaXNpb25BY3RpdmVgIGFuZCBgY29sbGlzaW9uRW5kYCBldmVudHMuXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YT0xNi42NjZdXG4gICAgICovXG4gICAgRW5naW5lLnVwZGF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgZGVsdGEpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IENvbW1vbi5ub3coKTtcblxuICAgICAgICB2YXIgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBkZXRlY3RvciA9IGVuZ2luZS5kZXRlY3RvcixcbiAgICAgICAgICAgIHBhaXJzID0gZW5naW5lLnBhaXJzLFxuICAgICAgICAgICAgdGltaW5nID0gZW5naW5lLnRpbWluZyxcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpbWluZy50aW1lc3RhbXAsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIHdhcm4gaWYgaGlnaCBkZWx0YVxuICAgICAgICBpZiAoZGVsdGEgPiBFbmdpbmUuX2RlbHRhTWF4KSB7XG4gICAgICAgICAgICBDb21tb24ud2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgJ01hdHRlci5FbmdpbmUudXBkYXRlOiBkZWx0YSBhcmd1bWVudCBpcyByZWNvbW1lbmRlZCB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8nLCBFbmdpbmUuX2RlbHRhTWF4LnRvRml4ZWQoMyksICdtcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsdGEgPSB0eXBlb2YgZGVsdGEgIT09ICd1bmRlZmluZWQnID8gZGVsdGEgOiBDb21tb24uX2Jhc2VEZWx0YTtcbiAgICAgICAgZGVsdGEgKj0gdGltaW5nLnRpbWVTY2FsZTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgdGltZXN0YW1wXG4gICAgICAgIHRpbWluZy50aW1lc3RhbXAgKz0gZGVsdGE7XG4gICAgICAgIHRpbWluZy5sYXN0RGVsdGEgPSBkZWx0YTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gZXZlbnQgb2JqZWN0XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIGRlbHRhOiBkZWx0YVxuICAgICAgICB9O1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2JlZm9yZVVwZGF0ZScsIGV2ZW50KTtcblxuICAgICAgICAvLyBnZXQgYWxsIGJvZGllcyBhbmQgYWxsIGNvbnN0cmFpbnRzIGluIHRoZSB3b3JsZFxuICAgICAgICB2YXIgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHdvcmxkIGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmICh3b3JsZC5pc01vZGlmaWVkKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGRldGVjdG9yIGJvZGllc1xuICAgICAgICAgICAgRGV0ZWN0b3Iuc2V0Qm9kaWVzKGRldGVjdG9yLCBhbGxCb2RpZXMpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBhbGwgY29tcG9zaXRlIG1vZGlmaWVkIGZsYWdzXG4gICAgICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQod29ybGQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgc2xlZXBpbmcgaWYgZW5hYmxlZFxuICAgICAgICBpZiAoZW5naW5lLmVuYWJsZVNsZWVwaW5nKVxuICAgICAgICAgICAgU2xlZXBpbmcudXBkYXRlKGFsbEJvZGllcywgZGVsdGEpO1xuXG4gICAgICAgIC8vIGFwcGx5IGdyYXZpdHkgdG8gYWxsIGJvZGllc1xuICAgICAgICBFbmdpbmUuX2JvZGllc0FwcGx5R3Jhdml0eShhbGxCb2RpZXMsIGVuZ2luZS5ncmF2aXR5KTtcblxuICAgICAgICAvLyB1cGRhdGUgYWxsIGJvZHkgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGJ5IGludGVncmF0aW9uXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlKGFsbEJvZGllcywgZGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlU29sdmUnLCBldmVudCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFsbCBjb25zdHJhaW50cyAoZmlyc3QgcGFzcylcbiAgICAgICAgQ29uc3RyYWludC5wcmVTb2x2ZUFsbChhbGxCb2RpZXMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5naW5lLmNvbnN0cmFpbnRJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmVBbGwoYWxsQ29uc3RyYWludHMsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBDb25zdHJhaW50LnBvc3RTb2x2ZUFsbChhbGxCb2RpZXMpO1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIGNvbGxpc2lvbnNcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBEZXRlY3Rvci5jb2xsaXNpb25zKGRldGVjdG9yKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXG4gICAgICAgIFBhaXJzLnVwZGF0ZShwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKTtcblxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXG4gICAgICAgIGlmIChlbmdpbmUuZW5hYmxlU2xlZXBpbmcpXG4gICAgICAgICAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMocGFpcnMubGlzdCk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjb2xsaXNpb24gZXZlbnRzXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25TdGFydCcsIHsgXG4gICAgICAgICAgICAgICAgcGFpcnM6IHBhaXJzLmNvbGxpc2lvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBkZWx0YTogZGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXRlcmF0aXZlbHkgcmVzb2x2ZSBwb3NpdGlvbiBiZXR3ZWVuIGNvbGxpc2lvbnNcbiAgICAgICAgdmFyIHBvc2l0aW9uRGFtcGluZyA9IENvbW1vbi5jbGFtcCgyMCAvIGVuZ2luZS5wb3NpdGlvbkl0ZXJhdGlvbnMsIDAsIDEpO1xuICAgICAgICBcbiAgICAgICAgUmVzb2x2ZXIucHJlU29sdmVQb3NpdGlvbihwYWlycy5saXN0KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5wb3NpdGlvbkl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgUmVzb2x2ZXIuc29sdmVQb3NpdGlvbihwYWlycy5saXN0LCBkZWx0YSwgcG9zaXRpb25EYW1waW5nKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvbHZlci5wb3N0U29sdmVQb3NpdGlvbihhbGxCb2RpZXMpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBhbGwgY29uc3RyYWludHMgKHNlY29uZCBwYXNzKVxuICAgICAgICBDb25zdHJhaW50LnByZVNvbHZlQWxsKGFsbEJvZGllcyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUuY29uc3RyYWludEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgQ29uc3RyYWludC5zb2x2ZUFsbChhbGxDb25zdHJhaW50cywgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIENvbnN0cmFpbnQucG9zdFNvbHZlQWxsKGFsbEJvZGllcyk7XG5cbiAgICAgICAgLy8gaXRlcmF0aXZlbHkgcmVzb2x2ZSB2ZWxvY2l0eSBiZXR3ZWVuIGNvbGxpc2lvbnNcbiAgICAgICAgUmVzb2x2ZXIucHJlU29sdmVWZWxvY2l0eShwYWlycy5saXN0KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS52ZWxvY2l0eUl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgUmVzb2x2ZXIuc29sdmVWZWxvY2l0eShwYWlycy5saXN0LCBkZWx0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgYm9keSBzcGVlZCBhbmQgdmVsb2NpdHkgcHJvcGVydGllc1xuICAgICAgICBFbmdpbmUuX2JvZGllc1VwZGF0ZVZlbG9jaXRpZXMoYWxsQm9kaWVzKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGNvbGxpc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25BY3RpdmUnLCB7IFxuICAgICAgICAgICAgICAgIHBhaXJzOiBwYWlycy5jb2xsaXNpb25BY3RpdmUsIFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltaW5nLnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBkZWx0YTogZGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvbkVuZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25FbmQnLCB7XG4gICAgICAgICAgICAgICAgcGFpcnM6IHBhaXJzLmNvbGxpc2lvbkVuZCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWluZy50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZGVsdGE6IGRlbHRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGZvcmNlIGJ1ZmZlcnNcbiAgICAgICAgRW5naW5lLl9ib2RpZXNDbGVhckZvcmNlcyhhbGxCb2RpZXMpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGxvZyB0aGUgdGltZSBlbGFwc2VkIGNvbXB1dGluZyB0aGlzIHVwZGF0ZVxuICAgICAgICBlbmdpbmUudGltaW5nLmxhc3RFbGFwc2VkID0gQ29tbW9uLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdHdvIGVuZ2luZXMgYnkga2VlcGluZyB0aGUgY29uZmlndXJhdGlvbiBvZiBgZW5naW5lQWAgYnV0IHJlcGxhY2luZyB0aGUgd29ybGQgd2l0aCB0aGUgb25lIGZyb20gYGVuZ2luZUJgLlxuICAgICAqIEBtZXRob2QgbWVyZ2VcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVCXG4gICAgICovXG4gICAgRW5naW5lLm1lcmdlID0gZnVuY3Rpb24oZW5naW5lQSwgZW5naW5lQikge1xuICAgICAgICBDb21tb24uZXh0ZW5kKGVuZ2luZUEsIGVuZ2luZUIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVuZ2luZUIud29ybGQpIHtcbiAgICAgICAgICAgIGVuZ2luZUEud29ybGQgPSBlbmdpbmVCLndvcmxkO1xuXG4gICAgICAgICAgICBFbmdpbmUuY2xlYXIoZW5naW5lQSk7XG5cbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZUEud29ybGQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYm9keS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGVuZ2luZSBwYWlycyBhbmQgZGV0ZWN0b3IuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBFbmdpbmUuY2xlYXIgPSBmdW5jdGlvbihlbmdpbmUpIHtcbiAgICAgICAgUGFpcnMuY2xlYXIoZW5naW5lLnBhaXJzKTtcbiAgICAgICAgRGV0ZWN0b3IuY2xlYXIoZW5naW5lLmRldGVjdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWmVyb2VzIHRoZSBgYm9keS5mb3JjZWAgYW5kIGBib2R5LnRvcnF1ZWAgZm9yY2UgYnVmZmVycy5cbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNDbGVhckZvcmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzQ2xlYXJGb3JjZXMgPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgdmFyIGJvZGllc0xlbmd0aCA9IGJvZGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueCA9IDA7XG4gICAgICAgICAgICBib2R5LmZvcmNlLnkgPSAwO1xuICAgICAgICAgICAgYm9keS50b3JxdWUgPSAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZ3Jhdml0YXRpb25hbCBhY2NlbGVyYXRpb24gdG8gYWxsIGBib2RpZXNgLlxuICAgICAqIFRoaXMgbW9kZWxzIGEgW3VuaWZvcm0gZ3Jhdml0YXRpb25hbCBmaWVsZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3Jhdml0eV9vZl9FYXJ0aCksIHNpbWlsYXIgdG8gbmVhciB0aGUgc3VyZmFjZSBvZiBhIHBsYW5ldC5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNBcHBseUdyYXZpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZ3Jhdml0eVxuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzQXBwbHlHcmF2aXR5ID0gZnVuY3Rpb24oYm9kaWVzLCBncmF2aXR5KSB7XG4gICAgICAgIHZhciBncmF2aXR5U2NhbGUgPSB0eXBlb2YgZ3Jhdml0eS5zY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBncmF2aXR5LnNjYWxlIDogMC4wMDEsXG4gICAgICAgICAgICBib2RpZXNMZW5ndGggPSBib2RpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICgoZ3Jhdml0eS54ID09PSAwICYmIGdyYXZpdHkueSA9PT0gMCkgfHwgZ3Jhdml0eVNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcmVzdWx0YW50IGZvcmNlIG9mIGdyYXZpdHlcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueSArPSBib2R5Lm1hc3MgKiBncmF2aXR5LnkgKiBncmF2aXR5U2NhbGU7XG4gICAgICAgICAgICBib2R5LmZvcmNlLnggKz0gYm9keS5tYXNzICogZ3Jhdml0eS54ICogZ3Jhdml0eVNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYEJvZHkudXBkYXRlYCB0byBhbGwgZ2l2ZW4gYGJvZGllc2AuXG4gICAgICogQG1ldGhvZCBfYm9kaWVzVXBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFRoZSBhbW91bnQgb2YgdGltZSBlbGFwc2VkIGJldHdlZW4gdXBkYXRlc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlID0gZnVuY3Rpb24oYm9kaWVzLCBkZWx0YSkge1xuICAgICAgICB2YXIgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgYm9keS5pc1NsZWVwaW5nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBCb2R5LnVwZGF0ZShib2R5LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBgQm9keS51cGRhdGVWZWxvY2l0aWVzYCB0byBhbGwgZ2l2ZW4gYGJvZGllc2AuXG4gICAgICogQG1ldGhvZCBfYm9kaWVzVXBkYXRlVmVsb2NpdGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlVmVsb2NpdGllcyA9IGZ1bmN0aW9uKGJvZGllcykge1xuICAgICAgICB2YXIgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBCb2R5LnVwZGF0ZVZlbG9jaXRpZXMoYm9kaWVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGRlcHJlY2F0ZWQgYWxpYXMgZm9yIGBSdW5uZXIucnVuYCwgdXNlIGBNYXR0ZXIuUnVubmVyLnJ1bihlbmdpbmUpYCBpbnN0ZWFkIGFuZCBzZWUgYE1hdHRlci5SdW5uZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBNYXR0ZXIuUnVubmVyLnJ1bihlbmdpbmUpIGluc3RlYWRcbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQganVzdCBiZWZvcmUgYW4gdXBkYXRlXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxuICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZGVsdGEgVGhlIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHZhbHVlIHVzZWQgaW4gdGhlIHVwZGF0ZVxuICAgICogQHBhcmFtIHtlbmdpbmV9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGJvZGllcyB1cGRhdGVkIGJhc2VkIG9uIHRoZWlyIHZlbG9jaXR5IGFuZCBmb3JjZXMsIGJ1dCBiZWZvcmUgYW55IGNvbGxpc2lvbiBkZXRlY3Rpb24sIGNvbnN0cmFpbnRzIGFuZCByZXNvbHZpbmcgZXRjLlxuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVTb2x2ZVxuICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZGVsdGEgVGhlIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHZhbHVlIHVzZWQgaW4gdGhlIHVwZGF0ZVxuICAgICogQHBhcmFtIHtlbmdpbmV9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB1cGRhdGUgYW5kIGFsbCBjb2xsaXNpb24gZXZlbnRzXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyVXBkYXRlXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgc3RhcnRlZCB0byBjb2xsaWRlIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcbiAgICAqXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uU3RhcnRcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7cGFpcltdfSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGFyZSBjb2xsaWRpbmcgaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxuICAgICpcbiAgICAqIEBldmVudCBjb2xsaXNpb25BY3RpdmVcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7cGFpcltdfSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgZW5kZWQgY29sbGlzaW9uIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcbiAgICAqXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uRW5kXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge3BhaXJbXX0gZXZlbnQucGFpcnMgTGlzdCBvZiBhZmZlY3RlZCBwYWlyc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZGVsdGEgVGhlIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHZhbHVlIHVzZWQgaW4gdGhlIHVwZGF0ZVxuICAgICogQHBhcmFtIHtlbmdpbmV9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uSXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDZcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjb25zdHJhaW50IGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGhpZ2hlciBxdWFsaXR5IHRoZSBzaW11bGF0aW9uIHdpbGwgYmUgYXQgdGhlIGV4cGVuc2Ugb2YgcGVyZm9ybWFuY2UuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDJgIGlzIHVzdWFsbHkgdmVyeSBhZGVxdWF0ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBlbmdpbmUgc2hvdWxkIGFsbG93IHNsZWVwaW5nIHZpYSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlLlxuICAgICAqIFNsZWVwaW5nIGNhbiBpbXByb3ZlIHN0YWJpbGl0eSBhbmQgcGVyZm9ybWFuY2UsIGJ1dCBvZnRlbiBhdCB0aGUgZXhwZW5zZSBvZiBhY2N1cmFjeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVTbGVlcGluZ1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgY29udGFpbmluZyBwcm9wZXJ0aWVzIHJlZ2FyZGluZyB0aGUgdGltaW5nIHN5c3RlbXMgb2YgdGhlIGVuZ2luZS4gXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBnbG9iYWwgc2NhbGluZyBmYWN0b3Igb2YgdGltZSBmb3IgYWxsIGJvZGllcy5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBmcmVlemVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMWAgZ2l2ZXMgYSBzbG93LW1vdGlvbiBlZmZlY3QuXG4gICAgICogQSB2YWx1ZSBvZiBgMS4yYCBnaXZlcyBhIHNwZWVkLXVwIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCBzaW11bGF0aW9uLXRpbWUgaW4gbWlsbGlzZWNvbmRzIHN0YXJ0aW5nIGZyb20gYDBgLiBcbiAgICAgKiBJdCBpcyBpbmNyZW1lbnRlZCBvbiBldmVyeSBgRW5naW5lLnVwZGF0ZWAgYnkgdGhlIGdpdmVuIGBkZWx0YWAgYXJndW1lbnQuIFxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZXN0YW1wXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHJlcHJlc2VudHMgdGhlIHRvdGFsIGV4ZWN1dGlvbiB0aW1lIGVsYXBzZWQgZHVyaW5nIHRoZSBsYXN0IGBFbmdpbmUudXBkYXRlYCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogSXQgaXMgdXBkYXRlZCBieSB0aW1pbmcgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgYEVuZ2luZS51cGRhdGVgIGNhbGwgdW50aWwgaXQgZW5kcy5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBhbHNvIGluY2x1ZGUgdGhlIHRvdGFsIGV4ZWN1dGlvbiB0aW1lIG9mIGFsbCBldmVudCBoYW5kbGVycyBkaXJlY3RseSBvciBpbmRpcmVjdGx5IHRyaWdnZXJlZCBieSB0aGUgZW5naW5lIHVwZGF0ZS5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nLmxhc3RFbGFwc2VkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHJlcHJlc2VudHMgdGhlIGBkZWx0YWAgdmFsdWUgdXNlZCBpbiB0aGUgbGFzdCBlbmdpbmUgdXBkYXRlLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcubGFzdERlbHRhXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTWF0dGVyLkRldGVjdG9yYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkZXRlY3RvclxuICAgICAqIEB0eXBlIGRldGVjdG9yXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuRGV0ZWN0b3IgaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE1hdHRlci5HcmlkYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IGBlbmdpbmUuZGV0ZWN0b3JgXG4gICAgICogQHByb3BlcnR5IGdyaWRcbiAgICAgKiBAdHlwZSBncmlkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZWQgYnkgYW5kIG5vdyBhbGlhcyBmb3IgYGVuZ2luZS5ncmlkYC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IGBlbmdpbmUuZGV0ZWN0b3JgXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSBncmlkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgYE1hdHRlci5Db21wb3NpdGVgIGluc3RhbmNlIHRoYXQgd2lsbCBjb250YWluIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBvdGhlciBjb21wb3NpdGVzIHRvIGJlIHNpbXVsYXRlZCBieSB0aGlzIGVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIGNvbXBvc2l0ZVxuICAgICAqIEBkZWZhdWx0IGEgTWF0dGVyLkNvbXBvc2l0ZSBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBncmF2aXRhdGlvbmFsIGFjY2VsZXJhdGlvbiBhcHBsaWVkIHRvIGFsbCBib2RpZXMgaW4gYGVuZ2luZS53b3JsZGAgb24gZXZlcnkgdXBkYXRlLlxuICAgICAqIFxuICAgICAqIFRoaXMgbW9kZWxzIGEgW3VuaWZvcm0gZ3Jhdml0YXRpb25hbCBmaWVsZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3Jhdml0eV9vZl9FYXJ0aCksIHNpbWlsYXIgdG8gbmVhciB0aGUgc3VyZmFjZSBvZiBhIHBsYW5ldC4gRm9yIGdyYXZpdHkgaW4gb3RoZXIgY29udGV4dHMsIGRpc2FibGUgdGhpcyBhbmQgYXBwbHkgZm9yY2VzIGFzIG5lZWRlZC5cbiAgICAgKiBcbiAgICAgKiBUbyBkaXNhYmxlIHNldCB0aGUgYHNjYWxlYCBjb21wb25lbnQgdG8gYDBgLlxuICAgICAqIFxuICAgICAqIFRoaXMgaXMgc3BsaXQgaW50byB0aHJlZSBjb21wb25lbnRzIGZvciBlYXNlIG9mIHVzZTogIFxuICAgICAqIGEgbm9ybWFsaXNlZCBkaXJlY3Rpb24gKGB4YCBhbmQgYHlgKSBhbmQgbWFnbml0dWRlIChgc2NhbGVgKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0YXRpb25hbCBkaXJlY3Rpb24gbm9ybWFsIGB4YCBjb21wb25lbnQsIHRvIGJlIG11bHRpcGxpZWQgYnkgYGdyYXZpdHkuc2NhbGVgLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnhcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0YXRpb25hbCBkaXJlY3Rpb24gbm9ybWFsIGB5YCBjb21wb25lbnQsIHRvIGJlIG11bHRpcGxpZWQgYnkgYGdyYXZpdHkuc2NhbGVgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIGdyYXZpdGF0aW9uYWwgYWNjZWxlcmF0aW9uLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnNjYWxlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5SZXNvbHZlcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHJlc29sdmluZyBjb2xsaXNpb24gcGFpcnMuXG4qXG4qIEBjbGFzcyBSZXNvbHZlclxuKi9cblxudmFyIFJlc29sdmVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb2x2ZXI7XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBCb3VuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBSZXNvbHZlci5fcmVzdGluZ1RocmVzaCA9IDI7XG4gICAgUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2hUYW5nZW50ID0gTWF0aC5zcXJ0KDYpO1xuICAgIFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiA9IDAuOTtcbiAgICBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nID0gMC44O1xuICAgIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIgPSA1O1xuICAgIFJlc29sdmVyLl9mcmljdGlvbk1heFN0YXRpYyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciBwb3NpdGlvbiBzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcHJlU29sdmVQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb250YWN0Q291bnQsXG4gICAgICAgICAgICBwYWlyc0xlbmd0aCA9IHBhaXJzLmxlbmd0aDtcblxuICAgICAgICAvLyBmaW5kIHRvdGFsIGNvbnRhY3RzIG9uIGVhY2ggYm9keVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnRhY3RDb3VudCA9IHBhaXIuY29udGFjdENvdW50O1xuICAgICAgICAgICAgcGFpci5jb2xsaXNpb24ucGFyZW50QS50b3RhbENvbnRhY3RzICs9IGNvbnRhY3RDb3VudDtcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEIudG90YWxDb250YWN0cyArPSBjb250YWN0Q291bnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHNvbHV0aW9uIGZvciBwYWlyIHBvc2l0aW9ucy5cbiAgICAgKiBAbWV0aG9kIHNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RhbXBpbmc9MV1cbiAgICAgKi9cbiAgICBSZXNvbHZlci5zb2x2ZVBvc2l0aW9uID0gZnVuY3Rpb24ocGFpcnMsIGRlbHRhLCBkYW1waW5nKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBjb250YWN0U2hhcmUsXG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbkRhbXBlbiA9IFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiAqIChkYW1waW5nIHx8IDEpLFxuICAgICAgICAgICAgc2xvcERhbXBlbiA9IENvbW1vbi5jbGFtcChkZWx0YSAvIENvbW1vbi5fYmFzZURlbHRhLCAwLCAxKSxcbiAgICAgICAgICAgIHBhaXJzTGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGZpbmQgaW1wdWxzZXMgcmVxdWlyZWQgdG8gcmVzb2x2ZSBwZW5ldHJhdGlvblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG5cbiAgICAgICAgICAgIC8vIGdldCBjdXJyZW50IHNlcGFyYXRpb24gYmV0d2VlbiBib2R5IGVkZ2VzIGludm9sdmVkIGluIGNvbGxpc2lvblxuICAgICAgICAgICAgcGFpci5zZXBhcmF0aW9uID0gXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uLmRlcHRoICsgbm9ybWFsLnggKiAoYm9keUIucG9zaXRpb25JbXB1bHNlLnggLSBib2R5QS5wb3NpdGlvbkltcHVsc2UueClcbiAgICAgICAgICAgICAgICArIG5vcm1hbC55ICogKGJvZHlCLnBvc2l0aW9uSW1wdWxzZS55IC0gYm9keUEucG9zaXRpb25JbXB1bHNlLnkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgPSBwYWlyLnNlcGFyYXRpb24gLSBwYWlyLnNsb3AgKiBzbG9wRGFtcGVuO1xuXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXG4gICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlICo9IDI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gcG9zaXRpb25EYW1wZW4gLyBib2R5QS50b3RhbENvbnRhY3RzO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uSW1wdWxzZS54ICs9IG5vcm1hbC54ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uSW1wdWxzZS55ICs9IG5vcm1hbC55ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IHBvc2l0aW9uRGFtcGVuIC8gYm9keUIudG90YWxDb250YWN0cztcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueCAtPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueSAtPSBub3JtYWwueSAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwb3NpdGlvbiByZXNvbHV0aW9uLlxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uV2FybWluZyA9IFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmcsXG4gICAgICAgICAgICBib2RpZXNMZW5ndGggPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICAgICAgdmVydGljZXNUcmFuc2xhdGUgPSBWZXJ0aWNlcy50cmFuc2xhdGUsXG4gICAgICAgICAgICBib3VuZHNVcGRhdGUgPSBCb3VuZHMudXBkYXRlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSA9IGJvZHkucG9zaXRpb25JbXB1bHNlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZVggPSBwb3NpdGlvbkltcHVsc2UueCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkltcHVsc2VZID0gcG9zaXRpb25JbXB1bHNlLnksXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgPSBib2R5LnZlbG9jaXR5O1xuXG4gICAgICAgICAgICAvLyByZXNldCBjb250YWN0IGNvdW50XG4gICAgICAgICAgICBib2R5LnRvdGFsQ29udGFjdHMgPSAwO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25JbXB1bHNlWCAhPT0gMCB8fCBwb3NpdGlvbkltcHVsc2VZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1RyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBwb3NpdGlvbkltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBib3VuZHNVcGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIHZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IHBvc2l0aW9uSW1wdWxzZVg7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBwb3NpdGlvbkltcHVsc2VZO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGJvZHkgd2l0aG91dCBjaGFuZ2luZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gcG9zaXRpb25JbXB1bHNlWDtcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IHBvc2l0aW9uSW1wdWxzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JbXB1bHNlWCAqIHZlbG9jaXR5LnggKyBwb3NpdGlvbkltcHVsc2VZICogdmVsb2NpdHkueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgY2FjaGVkIGltcHVsc2UgaWYgdGhlIGJvZHkgaGFzIHZlbG9jaXR5IGFsb25nIGl0XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlLnkgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm0gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZS54ICo9IHBvc2l0aW9uV2FybWluZztcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlLnkgKj0gcG9zaXRpb25XYXJtaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciB2ZWxvY2l0eSBzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcHJlU29sdmVWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFJlc29sdmVyLnByZVNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICB2YXIgcGFpcnNMZW5ndGggPSBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnRhY3RzID0gcGFpci5jb250YWN0cyxcbiAgICAgICAgICAgICAgICBjb250YWN0Q291bnQgPSBwYWlyLmNvbnRhY3RDb3VudCxcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEIsXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbCxcbiAgICAgICAgICAgICAgICB0YW5nZW50ID0gY29sbGlzaW9uLnRhbmdlbnQ7XG4gICAgXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBjb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4LFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlLFxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2U7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbEltcHVsc2UgIT09IDAgfHwgdGFuZ2VudEltcHVsc2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG90YWwgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcHVsc2VYID0gbm9ybWFsLnggKiBub3JtYWxJbXB1bHNlICsgdGFuZ2VudC54ICogdGFuZ2VudEltcHVsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlWSA9IG5vcm1hbC55ICogbm9ybWFsSW1wdWxzZSArIHRhbmdlbnQueSAqIHRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYm9keUEuaXNTdGF0aWMgfHwgYm9keUEuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2VYICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueSArPSBpbXB1bHNlWSAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuYW5nbGVQcmV2ICs9IGJvZHlBLmludmVyc2VJbmVydGlhICogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb250YWN0VmVydGV4LnggLSBib2R5QS5wb3NpdGlvbi54KSAqIGltcHVsc2VZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoY29udGFjdFZlcnRleC55IC0gYm9keUEucG9zaXRpb24ueSkgKiBpbXB1bHNlWFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZVggKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2VZICogYm9keUIuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hbmdsZVByZXYgLT0gYm9keUIuaW52ZXJzZUluZXJ0aWEgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRhY3RWZXJ0ZXgueCAtIGJvZHlCLnBvc2l0aW9uLngpICogaW1wdWxzZVkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSAoY29udGFjdFZlcnRleC55IC0gYm9keUIucG9zaXRpb24ueSkgKiBpbXB1bHNlWFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgc29sdXRpb24gZm9yIHBhaXIgdmVsb2NpdGllcy5cbiAgICAgKiBAbWV0aG9kIHNvbHZlVmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFcbiAgICAgKi9cbiAgICBSZXNvbHZlci5zb2x2ZVZlbG9jaXR5ID0gZnVuY3Rpb24ocGFpcnMsIGRlbHRhKSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBkZWx0YSAvIENvbW1vbi5fYmFzZURlbHRhLFxuICAgICAgICAgICAgdGltZVNjYWxlU3F1YXJlZCA9IHRpbWVTY2FsZSAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIHRpbWVTY2FsZUN1YmVkID0gdGltZVNjYWxlU3F1YXJlZCAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIHJlc3RpbmdUaHJlc2ggPSAtUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2ggKiB0aW1lU2NhbGUsXG4gICAgICAgICAgICByZXN0aW5nVGhyZXNoVGFuZ2VudCA9IFJlc29sdmVyLl9yZXN0aW5nVGhyZXNoVGFuZ2VudCxcbiAgICAgICAgICAgIGZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciA9IFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIgKiB0aW1lU2NhbGUsXG4gICAgICAgICAgICBmcmljdGlvbk1heFN0YXRpYyA9IFJlc29sdmVyLl9mcmljdGlvbk1heFN0YXRpYyxcbiAgICAgICAgICAgIHBhaXJzTGVuZ3RoID0gcGFpcnMubGVuZ3RoLFxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UsXG4gICAgICAgICAgICBtYXhGcmljdGlvbixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IHBhaXIuY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEEsXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QixcbiAgICAgICAgICAgICAgICBub3JtYWxYID0gY29sbGlzaW9uLm5vcm1hbC54LFxuICAgICAgICAgICAgICAgIG5vcm1hbFkgPSBjb2xsaXNpb24ubm9ybWFsLnksXG4gICAgICAgICAgICAgICAgdGFuZ2VudFggPSBjb2xsaXNpb24udGFuZ2VudC54LFxuICAgICAgICAgICAgICAgIHRhbmdlbnRZID0gY29sbGlzaW9uLnRhbmdlbnQueSxcbiAgICAgICAgICAgICAgICBpbnZlcnNlTWFzc1RvdGFsID0gcGFpci5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgICAgICBmcmljdGlvbiA9IHBhaXIuZnJpY3Rpb24gKiBwYWlyLmZyaWN0aW9uU3RhdGljICogZnJpY3Rpb25Ob3JtYWxNdWx0aXBsaWVyLFxuICAgICAgICAgICAgICAgIGNvbnRhY3RzID0gcGFpci5jb250YWN0cyxcbiAgICAgICAgICAgICAgICBjb250YWN0Q291bnQgPSBwYWlyLmNvbnRhY3RDb3VudCxcbiAgICAgICAgICAgICAgICBjb250YWN0U2hhcmUgPSAxIC8gY29udGFjdENvdW50O1xuXG4gICAgICAgICAgICAvLyBnZXQgYm9keSB2ZWxvY2l0aWVzXG4gICAgICAgICAgICB2YXIgYm9keUFWZWxvY2l0eVggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2LngsXG4gICAgICAgICAgICAgICAgYm9keUFWZWxvY2l0eVkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2LnksXG4gICAgICAgICAgICAgICAgYm9keUFBbmd1bGFyVmVsb2NpdHkgPSBib2R5QS5hbmdsZSAtIGJvZHlBLmFuZ2xlUHJldixcbiAgICAgICAgICAgICAgICBib2R5QlZlbG9jaXR5WCA9IGJvZHlCLnBvc2l0aW9uLnggLSBib2R5Qi5wb3NpdGlvblByZXYueCxcbiAgICAgICAgICAgICAgICBib2R5QlZlbG9jaXR5WSA9IGJvZHlCLnBvc2l0aW9uLnkgLSBib2R5Qi5wb3NpdGlvblByZXYueSxcbiAgICAgICAgICAgICAgICBib2R5QkFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlCLmFuZ2xlIC0gYm9keUIuYW5nbGVQcmV2O1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBjb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFZlcnRleCA9IGNvbnRhY3QudmVydGV4O1xuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldEFYID0gY29udGFjdFZlcnRleC54IC0gYm9keUEucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QVkgPSBjb250YWN0VmVydGV4LnkgLSBib2R5QS5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRCWCA9IGNvbnRhY3RWZXJ0ZXgueCAtIGJvZHlCLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJZID0gY29udGFjdFZlcnRleC55IC0gYm9keUIucG9zaXRpb24ueTtcbiBcbiAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHlQb2ludEFYID0gYm9keUFWZWxvY2l0eVggLSBvZmZzZXRBWSAqIGJvZHlBQW5ndWxhclZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eVBvaW50QVkgPSBib2R5QVZlbG9jaXR5WSArIG9mZnNldEFYICogYm9keUFBbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCWCA9IGJvZHlCVmVsb2NpdHlYIC0gb2Zmc2V0QlkgKiBib2R5QkFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHlQb2ludEJZID0gYm9keUJWZWxvY2l0eVkgKyBvZmZzZXRCWCAqIGJvZHlCQW5ndWxhclZlbG9jaXR5O1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlVmVsb2NpdHlYID0gdmVsb2NpdHlQb2ludEFYIC0gdmVsb2NpdHlQb2ludEJYLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVZlbG9jaXR5WSA9IHZlbG9jaXR5UG9pbnRBWSAtIHZlbG9jaXR5UG9pbnRCWTtcblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxWZWxvY2l0eSA9IG5vcm1hbFggKiByZWxhdGl2ZVZlbG9jaXR5WCArIG5vcm1hbFkgKiByZWxhdGl2ZVZlbG9jaXR5WSxcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudFZlbG9jaXR5ID0gdGFuZ2VudFggKiByZWxhdGl2ZVZlbG9jaXR5WCArIHRhbmdlbnRZICogcmVsYXRpdmVWZWxvY2l0eVk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb3Vsb21iIGZyaWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbE92ZXJsYXAgPSBwYWlyLnNlcGFyYXRpb24gKyBub3JtYWxWZWxvY2l0eTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsRm9yY2UgPSBNYXRoLm1pbihub3JtYWxPdmVybGFwLCAxKTtcbiAgICAgICAgICAgICAgICBub3JtYWxGb3JjZSA9IG5vcm1hbE92ZXJsYXAgPCAwID8gMCA6IG5vcm1hbEZvcmNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZyaWN0aW9uTGltaXQgPSBub3JtYWxGb3JjZSAqIGZyaWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRWZWxvY2l0eSA8IC1mcmljdGlvbkxpbWl0IHx8IHRhbmdlbnRWZWxvY2l0eSA+IGZyaWN0aW9uTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSAodGFuZ2VudFZlbG9jaXR5ID4gMCA/IHRhbmdlbnRWZWxvY2l0eSA6IC10YW5nZW50VmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IHBhaXIuZnJpY3Rpb24gKiAodGFuZ2VudFZlbG9jaXR5ID4gMCA/IDEgOiAtMSkgKiB0aW1lU2NhbGVDdWJlZDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YW5nZW50SW1wdWxzZSA8IC1tYXhGcmljdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgPSAtbWF4RnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFuZ2VudEltcHVsc2UgPiBtYXhGcmljdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgPSBtYXhGcmljdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gdGFuZ2VudFZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICBtYXhGcmljdGlvbiA9IGZyaWN0aW9uTWF4U3RhdGljO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIG1hc3MsIGluZXJ0aWEgYW5kIGNvbnRhY3Qgb2Zmc2V0XG4gICAgICAgICAgICAgICAgdmFyIG9BY04gPSBvZmZzZXRBWCAqIG5vcm1hbFkgLSBvZmZzZXRBWSAqIG5vcm1hbFgsXG4gICAgICAgICAgICAgICAgICAgIG9CY04gPSBvZmZzZXRCWCAqIG5vcm1hbFkgLSBvZmZzZXRCWSAqIG5vcm1hbFgsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlID0gY29udGFjdFNoYXJlIC8gKGludmVyc2VNYXNzVG90YWwgKyBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIG9BY04gKiBvQWNOICsgYm9keUIuaW52ZXJzZUluZXJ0aWEgKiBvQmNOICogb0JjTik7XG5cbiAgICAgICAgICAgICAgICAvLyByYXcgaW1wdWxzZXNcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsSW1wdWxzZSA9ICgxICsgcGFpci5yZXN0aXR1dGlvbikgKiBub3JtYWxWZWxvY2l0eSAqIHNoYXJlO1xuICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlICo9IHNoYXJlO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGhpZ2ggdmVsb2NpdHkgYW5kIHJlc3RpbmcgY29sbGlzaW9ucyBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbFZlbG9jaXR5IDwgcmVzdGluZ1RocmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWdoIG5vcm1hbCB2ZWxvY2l0eSBzbyBjbGVhciBjYWNoZWQgY29udGFjdCBub3JtYWwgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlIHJlc3RpbmcgY29sbGlzaW9uIGNvbnN0cmFpbnRzIHVzaW5nIEVyaW4gQ2F0dG8ncyBtZXRob2QgKEdEQzA4KVxuICAgICAgICAgICAgICAgICAgICAvLyBpbXB1bHNlIGNvbnN0cmFpbnQgdGVuZHMgdG8gMFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdE5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3Qubm9ybWFsSW1wdWxzZSArPSBub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5ub3JtYWxJbXB1bHNlID4gMCkgY29udGFjdC5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW1wdWxzZSA9IGNvbnRhY3Qubm9ybWFsSW1wdWxzZSAtIGNvbnRhY3ROb3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIGlmICh0YW5nZW50VmVsb2NpdHkgPCAtcmVzdGluZ1RocmVzaFRhbmdlbnQgfHwgdGFuZ2VudFZlbG9jaXR5ID4gcmVzdGluZ1RocmVzaFRhbmdlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCB0YW5nZW50IHZlbG9jaXR5IHNvIGNsZWFyIGNhY2hlZCBjb250YWN0IHRhbmdlbnQgaW1wdWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZSByZXN0aW5nIGNvbGxpc2lvbiBjb25zdHJhaW50cyB1c2luZyBFcmluIENhdHRvJ3MgbWV0aG9kIChHREMwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gdGFuZ2VudCBpbXB1bHNlIHRlbmRzIHRvIC10YW5nZW50U3BlZWQgb3IgK3RhbmdlbnRTcGVlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFjdFRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50SW1wdWxzZSArPSB0YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QudGFuZ2VudEltcHVsc2UgPCAtbWF4RnJpY3Rpb24pIGNvbnRhY3QudGFuZ2VudEltcHVsc2UgPSAtbWF4RnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LnRhbmdlbnRJbXB1bHNlID4gbWF4RnJpY3Rpb24pIGNvbnRhY3QudGFuZ2VudEltcHVsc2UgPSBtYXhGcmljdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgPSBjb250YWN0LnRhbmdlbnRJbXB1bHNlIC0gY29udGFjdFRhbmdlbnRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRvdGFsIGltcHVsc2UgZnJvbSBjb250YWN0XG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2VYID0gbm9ybWFsWCAqIG5vcm1hbEltcHVsc2UgKyB0YW5nZW50WCAqIHRhbmdlbnRJbXB1bHNlLFxuICAgICAgICAgICAgICAgICAgICBpbXB1bHNlWSA9IG5vcm1hbFkgKiBub3JtYWxJbXB1bHNlICsgdGFuZ2VudFkgKiB0YW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBpbXB1bHNlIGZyb20gY29udGFjdFxuICAgICAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi54ICs9IGltcHVsc2VYICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2VZICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLmFuZ2xlUHJldiArPSAob2Zmc2V0QVggKiBpbXB1bHNlWSAtIG9mZnNldEFZICogaW1wdWxzZVgpICogYm9keUEuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEoYm9keUIuaXNTdGF0aWMgfHwgYm9keUIuaXNTbGVlcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnggLT0gaW1wdWxzZVggKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnkgLT0gaW1wdWxzZVkgKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuYW5nbGVQcmV2IC09IChvZmZzZXRCWCAqIGltcHVsc2VZIC0gb2Zmc2V0QlkgKiBpbXB1bHNlWCkgKiBib2R5Qi5pbnZlcnNlSW5lcnRpYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLlBhaXJzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpciBzZXRzLlxuKlxuKiBAY2xhc3MgUGFpcnNcbiovXG5cbnZhciBQYWlycyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhaXJzO1xuXG52YXIgUGFpciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYWlycyBzdHJ1Y3R1cmUuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge3BhaXJzfSBBIG5ldyBwYWlycyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBQYWlycy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICB0YWJsZToge30sXG4gICAgICAgICAgICBsaXN0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0OiBbXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZTogW10sXG4gICAgICAgICAgICBjb2xsaXNpb25FbmQ6IFtdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBhaXJzIGdpdmVuIGEgbGlzdCBvZiBjb2xsaXNpb25zLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhaXJzXG4gICAgICogQHBhcmFtIHtjb2xsaXNpb25bXX0gY29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBQYWlycy51cGRhdGUgPSBmdW5jdGlvbihwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBwYWlyVXBkYXRlID0gUGFpci51cGRhdGUsXG4gICAgICAgICAgICBwYWlyQ3JlYXRlID0gUGFpci5jcmVhdGUsXG4gICAgICAgICAgICBwYWlyU2V0QWN0aXZlID0gUGFpci5zZXRBY3RpdmUsXG4gICAgICAgICAgICBwYWlyc1RhYmxlID0gcGFpcnMudGFibGUsXG4gICAgICAgICAgICBwYWlyc0xpc3QgPSBwYWlycy5saXN0LFxuICAgICAgICAgICAgcGFpcnNMaXN0TGVuZ3RoID0gcGFpcnNMaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgIHBhaXJzTGlzdEluZGV4ID0gcGFpcnNMaXN0TGVuZ3RoLFxuICAgICAgICAgICAgY29sbGlzaW9uU3RhcnQgPSBwYWlycy5jb2xsaXNpb25TdGFydCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkVuZCA9IHBhaXJzLmNvbGxpc2lvbkVuZCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZSA9IHBhaXJzLmNvbGxpc2lvbkFjdGl2ZSxcbiAgICAgICAgICAgIGNvbGxpc2lvbnNMZW5ndGggPSBjb2xsaXNpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbGxpc2lvblN0YXJ0SW5kZXggPSAwLFxuICAgICAgICAgICAgY29sbGlzaW9uRW5kSW5kZXggPSAwLFxuICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlSW5kZXggPSAwLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbGxpc2lvbnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcbiAgICAgICAgICAgIHBhaXIgPSBjb2xsaXNpb24ucGFpcjtcblxuICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWlyIGFscmVhZHkgZXhpc3RzIChidXQgbWF5IG9yIG1heSBub3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgZXhpc3RzIGFuZCBpcyBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlW2NvbGxpc2lvbkFjdGl2ZUluZGV4KytdID0gcGFpcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhaXJcbiAgICAgICAgICAgICAgICBwYWlyVXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGFpciBkaWQgbm90IGV4aXN0LCBjcmVhdGUgYSBuZXcgcGFpclxuICAgICAgICAgICAgICAgIHBhaXIgPSBwYWlyQ3JlYXRlKGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBwYWlyc1RhYmxlW3BhaXIuaWRdID0gcGFpcjtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgbmV3IHBhaXJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25TdGFydFtjb2xsaXNpb25TdGFydEluZGV4KytdID0gcGFpcjtcbiAgICAgICAgICAgICAgICBwYWlyc0xpc3RbcGFpcnNMaXN0SW5kZXgrK10gPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBwYWlycyB0aGF0IGFyZSBubyBsb25nZXIgYWN0aXZlXG4gICAgICAgIHBhaXJzTGlzdEluZGV4ID0gMDtcbiAgICAgICAgcGFpcnNMaXN0TGVuZ3RoID0gcGFpcnNMaXN0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHBhaXIgaXMgYWN0aXZlIGlmIHVwZGF0ZWQgdGhpcyB0aW1lc3RlcFxuICAgICAgICAgICAgaWYgKHBhaXIudGltZVVwZGF0ZWQgPj0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBhY3RpdmUgcGFpcnNcbiAgICAgICAgICAgICAgICBwYWlyc0xpc3RbcGFpcnNMaXN0SW5kZXgrK10gPSBwYWlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWlyU2V0QWN0aXZlKHBhaXIsIGZhbHNlLCB0aW1lc3RhbXApO1xuXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBpbmFjdGl2ZSBwYWlycyBpZiBib3RoIGJvZGllcyBtYXkgYmUgc2xlZXBpbmdcbiAgICAgICAgICAgICAgICBpZiAocGFpci5jb2xsaXNpb24uYm9keUEuc2xlZXBDb3VudGVyID4gMCAmJiBwYWlyLmNvbGxpc2lvbi5ib2R5Qi5zbGVlcENvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzTGlzdFtwYWlyc0xpc3RJbmRleCsrXSA9IHBhaXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGluYWN0aXZlIHBhaXJzIGlmIGVpdGhlciBib2R5IGF3YWtlXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbkVuZFtjb2xsaXNpb25FbmRJbmRleCsrXSA9IHBhaXI7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYWlyc1RhYmxlW3BhaXIuaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBhcnJheSBsZW5ndGhzIGlmIGNoYW5nZWRcbiAgICAgICAgaWYgKHBhaXJzTGlzdC5sZW5ndGggIT09IHBhaXJzTGlzdEluZGV4KSB7XG4gICAgICAgICAgICBwYWlyc0xpc3QubGVuZ3RoID0gcGFpcnNMaXN0SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sbGlzaW9uU3RhcnQubGVuZ3RoICE9PSBjb2xsaXNpb25TdGFydEluZGV4KSB7XG4gICAgICAgICAgICBjb2xsaXNpb25TdGFydC5sZW5ndGggPSBjb2xsaXNpb25TdGFydEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbGxpc2lvbkVuZC5sZW5ndGggIT09IGNvbGxpc2lvbkVuZEluZGV4KSB7XG4gICAgICAgICAgICBjb2xsaXNpb25FbmQubGVuZ3RoID0gY29sbGlzaW9uRW5kSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sbGlzaW9uQWN0aXZlLmxlbmd0aCAhPT0gY29sbGlzaW9uQWN0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSBjb2xsaXNpb25BY3RpdmVJbmRleDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdpdmVuIHBhaXJzIHN0cnVjdHVyZS5cbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtwYWlyc30gcGFpcnNcbiAgICAgKiBAcmV0dXJuIHtwYWlyc30gcGFpcnNcbiAgICAgKi9cbiAgICBQYWlycy5jbGVhciA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgICAgIHBhaXJzLnRhYmxlID0ge307XG4gICAgICAgIHBhaXJzLmxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgcGFpcnMuY29sbGlzaW9uU3RhcnQubGVuZ3RoID0gMDtcbiAgICAgICAgcGFpcnMuY29sbGlzaW9uQWN0aXZlLmxlbmd0aCA9IDA7XG4gICAgICAgIHBhaXJzLmNvbGxpc2lvbkVuZC5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gcGFpcnM7XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXR0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5cclxuTWF0dGVyLkF4ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuTWF0dGVyLkJvZGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5NYXR0ZXIuQm9keSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbk1hdHRlci5Cb3VuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5NYXR0ZXIuQ29sbGlzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuTWF0dGVyLkNvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbk1hdHRlci5Db21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5NYXR0ZXIuQ29tcG9zaXRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG5NYXR0ZXIuQ29uc3RyYWludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5NYXR0ZXIuQ29udGFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5NYXR0ZXIuRGV0ZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuTWF0dGVyLkVuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5NYXR0ZXIuRXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuTWF0dGVyLkdyaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuTWF0dGVyLk1vdXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbk1hdHRlci5Nb3VzZUNvbnN0cmFpbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuTWF0dGVyLlBhaXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5NYXR0ZXIuUGFpcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuTWF0dGVyLlBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5NYXR0ZXIuUXVlcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuTWF0dGVyLlJlbmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG5NYXR0ZXIuUmVzb2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuTWF0dGVyLlJ1bm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5NYXR0ZXIuU0FUID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcbk1hdHRlci5TbGVlcGluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbk1hdHRlci5TdmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxuTWF0dGVyLlZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbk1hdHRlci5WZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbk1hdHRlci5Xb3JsZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG5cclxuLy8gdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eVxyXG5NYXR0ZXIuRW5naW5lLnJ1biA9IE1hdHRlci5SdW5uZXIucnVuO1xyXG5NYXR0ZXIuQ29tbW9uLmRlcHJlY2F0ZWQoTWF0dGVyLkVuZ2luZSwgJ3J1bicsICdFbmdpbmUucnVuIOKepCB1c2UgTWF0dGVyLlJ1bm5lci5ydW4oZW5naW5lKSBpbnN0ZWFkJyk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxyXG4qIFRoZSBgTWF0dGVyYCBtb2R1bGUgaXMgdGhlIHRvcCBsZXZlbCBuYW1lc3BhY2UuIEl0IGFsc28gaW5jbHVkZXMgYSBmdW5jdGlvbiBmb3IgaW5zdGFsbGluZyBwbHVnaW5zIG9uIHRvcCBvZiB0aGUgbGlicmFyeS5cclxuKlxyXG4qIEBjbGFzcyBNYXR0ZXJcclxuKi9cclxuXHJcbnZhciBNYXR0ZXIgPSB7fTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTWF0dGVyO1xyXG5cclxudmFyIFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaWJyYXJ5IG5hbWUuXHJcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIubmFtZSA9ICdtYXR0ZXItanMnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpYnJhcnkgdmVyc2lvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB2ZXJzaW9uXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci52ZXJzaW9uID0gIHRydWUgPyBcIjAuMjAuMFwiIDogdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIHBsdWdpbiBkZXBlbmRlbmNpZXMgdG8gYmUgaW5zdGFsbGVkLiBUaGVzZSBhcmUgbm9ybWFsbHkgc2V0IGFuZCBpbnN0YWxsZWQgdGhyb3VnaCBgTWF0dGVyLnVzZWAuXHJcbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgc2V0IGBNYXR0ZXIudXNlc2AgbWFudWFsbHkgYW5kIGluc3RhbGwgdGhlbSBieSBjYWxsaW5nIGBQbHVnaW4udXNlKE1hdHRlcilgLlxyXG4gICAgICogQHByb3BlcnR5IHVzZXNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLnVzZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbHVnaW5zIHRoYXQgaGF2ZSBiZWVuIGluc3RhbGxlZCB0aHJvdWdoIGBNYXR0ZXIuUGx1Z2luLmluc3RhbGxgLiBSZWFkIG9ubHkuXHJcbiAgICAgKiBAcHJvcGVydHkgdXNlZFxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci51c2VkID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnN0YWxscyB0aGUgZ2l2ZW4gcGx1Z2lucyBvbiB0aGUgYE1hdHRlcmAgbmFtZXNwYWNlLlxyXG4gICAgICogVGhpcyBpcyBhIHNob3J0LWhhbmQgZm9yIGBQbHVnaW4udXNlYCwgc2VlIGl0IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQ2FsbCB0aGlzIGZ1bmN0aW9uIG9uY2UgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgY29kZSwgd2l0aCBhbGwgb2YgdGhlIHBsdWdpbnMgeW91IHdpc2ggdG8gaW5zdGFsbCBhcyBhcmd1bWVudHMuXHJcbiAgICAgKiBBdm9pZCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdW5sZXNzIHlvdSBpbnRlbmQgdG8gbWFudWFsbHkgY29udHJvbCBpbnN0YWxsYXRpb24gb3JkZXIuXHJcbiAgICAgKiBAbWV0aG9kIHVzZVxyXG4gICAgICogQHBhcmFtIC4uLnBsdWdpbiB7RnVuY3Rpb259IFRoZSBwbHVnaW4ocykgdG8gaW5zdGFsbCBvbiBgYmFzZWAgKG11bHRpLWFyZ3VtZW50KS5cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLnVzZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFBsdWdpbi51c2UoTWF0dGVyLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYmVmb3JlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBNYXR0ZXJgLlxyXG4gICAgICogU2VlIGFsc28gZG9jcyBmb3IgYENvbW1vbi5jaGFpbmAuXHJcbiAgICAgKiBAbWV0aG9kIGJlZm9yZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYE1hdHRlcmBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGJlZm9yZSB0aGUgb3JpZ2luYWxcclxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIuYmVmb3JlID0gZnVuY3Rpb24ocGF0aCwgZnVuYykge1xyXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15NYXR0ZXIuLywgJycpO1xyXG4gICAgICAgIHJldHVybiBDb21tb24uY2hhaW5QYXRoQmVmb3JlKE1hdHRlciwgcGF0aCwgZnVuYyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGFmdGVyIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBNYXR0ZXJgLlxyXG4gICAgICogU2VlIGFsc28gZG9jcyBmb3IgYENvbW1vbi5jaGFpbmAuXHJcbiAgICAgKiBAbWV0aG9kIGFmdGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgTWF0dGVyYFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYWZ0ZXIgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcclxuICAgICAqL1xyXG4gICAgTWF0dGVyLmFmdGVyID0gZnVuY3Rpb24ocGF0aCwgZnVuYykge1xyXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15NYXR0ZXIuLywgJycpO1xyXG4gICAgICAgIHJldHVybiBDb21tb24uY2hhaW5QYXRoQWZ0ZXIoTWF0dGVyLCBwYXRoLCBmdW5jKTtcclxuICAgIH07XHJcblxyXG59KSgpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQ29tcG9zaXRlc2AgbW9kdWxlIGNvbnRhaW5zIGZhY3RvcnkgbWV0aG9kcyBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGJvZGllc1xuKiB3aXRoIGNvbW1vbmx5IHVzZWQgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgc3RhY2tzIGFuZCBjaGFpbnMpLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgQ29tcG9zaXRlc1xuKi9cblxudmFyIENvbXBvc2l0ZXMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGVzO1xuXG52YXIgQ29tcG9zaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBDb25zdHJhaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBCb2R5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBCb2RpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBkZXByZWNhdGVkID0gQ29tbW9uLmRlcHJlY2F0ZWQ7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBib2RpZXMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2sgaW4gYSBncmlkIGFycmFuZ2VtZW50LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYm9keSdzIGJvdW5kcyB0byBwcmV2ZW50IG92ZXJsYXBzLlxuICAgICAqIEBtZXRob2Qgc3RhY2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBTdGFydGluZyBwb3NpdGlvbiBpbiBYLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFN0YXJ0aW5nIHBvc2l0aW9uIGluIFkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5HYXBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93R2FwXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLnN0YWNrID0gZnVuY3Rpb24oeCwgeSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdGFjayA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ1N0YWNrJyB9KSxcbiAgICAgICAgICAgIGN1cnJlbnRYID0geCxcbiAgICAgICAgICAgIGN1cnJlbnRZID0geSxcbiAgICAgICAgICAgIGxhc3RCb2R5LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gY2FsbGJhY2soY3VycmVudFgsIGN1cnJlbnRZLCBjb2x1bW4sIHJvdywgbGFzdEJvZHksIGkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keUhlaWdodCA9IGJvZHkuYm91bmRzLm1heC55IC0gYm9keS5ib3VuZHMubWluLnksXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5V2lkdGggPSBib2R5LmJvdW5kcy5tYXgueCAtIGJvZHkuYm91bmRzLm1pbi54OyBcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUhlaWdodCA+IG1heEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGJvZHlIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShib2R5LCB7IHg6IGJvZHlXaWR0aCAqIDAuNSwgeTogYm9keUhlaWdodCAqIDAuNSB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50WCA9IGJvZHkuYm91bmRzLm1heC54ICsgY29sdW1uR2FwO1xuXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KHN0YWNrLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxhc3RCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IGNvbHVtbkdhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGN1cnJlbnRZICs9IG1heEhlaWdodCArIHJvd0dhcDtcbiAgICAgICAgICAgIGN1cnJlbnRYID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENoYWlucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUgdG9nZXRoZXIgdXNpbmcgY29uc3RyYWludHMuXG4gICAgICogQG1ldGhvZCBjaGFpblxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldEFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geE9mZnNldEJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geU9mZnNldEJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjaGFpbmVkIHRvZ2V0aGVyIHdpdGggY29uc3RyYWludHNcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLmNoYWluID0gZnVuY3Rpb24oY29tcG9zaXRlLCB4T2Zmc2V0QSwgeU9mZnNldEEsIHhPZmZzZXRCLCB5T2Zmc2V0Qiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcztcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaSAtIDFdLFxuICAgICAgICAgICAgICAgIGJvZHlCID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGJvZHlBSGVpZ2h0ID0gYm9keUEuYm91bmRzLm1heC55IC0gYm9keUEuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlBV2lkdGggPSBib2R5QS5ib3VuZHMubWF4LnggLSBib2R5QS5ib3VuZHMubWluLngsIFxuICAgICAgICAgICAgICAgIGJvZHlCSGVpZ2h0ID0gYm9keUIuYm91bmRzLm1heC55IC0gYm9keUIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvZHlCV2lkdGggPSBib2R5Qi5ib3VuZHMubWF4LnggLSBib2R5Qi5ib3VuZHMubWluLng7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgICAgIGJvZHlBOiBib2R5QSxcbiAgICAgICAgICAgICAgICBwb2ludEE6IHsgeDogYm9keUFXaWR0aCAqIHhPZmZzZXRBLCB5OiBib2R5QUhlaWdodCAqIHlPZmZzZXRBIH0sXG4gICAgICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxuICAgICAgICAgICAgICAgIHBvaW50QjogeyB4OiBib2R5QldpZHRoICogeE9mZnNldEIsIHk6IGJvZHlCSGVpZ2h0ICogeU9mZnNldEIgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKGNvbnN0cmFpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5sYWJlbCArPSAnIENoYWluJztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGJvZGllcyBpbiB0aGUgY29tcG9zaXRlIHdpdGggY29uc3RyYWludHMgaW4gYSBncmlkIHBhdHRlcm4sIHdpdGggb3B0aW9uYWwgY3Jvc3MgYnJhY2VzLlxuICAgICAqIEBtZXRob2QgbWVzaFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcm9zc0JyYWNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIG1lc2hlZCB0b2dldGhlciB3aXRoIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5tZXNoID0gZnVuY3Rpb24oY29tcG9zaXRlLCBjb2x1bW5zLCByb3dzLCBjcm9zc0JyYWNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBib2RpZXMgPSBjb21wb3NpdGUuYm9kaWVzLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIGJvZHlDO1xuICAgICAgICBcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChjb2wgPSAxOyBjb2wgPCBjb2x1bW5zOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGJvZHlBID0gYm9kaWVzWyhjb2wgLSAxKSArIChyb3cgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjb21wb3NpdGUsIENvbnN0cmFpbnQuY3JlYXRlKENvbW1vbi5leHRlbmQoeyBib2R5QTogYm9keUEsIGJvZHlCOiBib2R5QiB9LCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm93ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgY29sdW1uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSBib2RpZXNbY29sICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSBib2RpZXNbY29sICsgKHJvdyAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlBLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NCcmFjZSAmJiBjb2wgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QyA9IGJvZGllc1soY29sIC0gMSkgKyAoKHJvdyAtIDEpICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc0JyYWNlICYmIGNvbCA8IGNvbHVtbnMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QyA9IGJvZGllc1soY29sICsgMSkgKyAoKHJvdyAtIDEpICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlDLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBvc2l0ZS5sYWJlbCArPSAnIE1lc2gnO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBib2RpZXMgY3JlYXRlZCBpbiB0aGUgY2FsbGJhY2sgaW4gYSBweXJhbWlkIGFycmFuZ2VtZW50LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYm9keSdzIGJvdW5kcyB0byBwcmV2ZW50IG92ZXJsYXBzLlxuICAgICAqIEBtZXRob2QgcHlyYW1pZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFN0YXJ0aW5nIHBvc2l0aW9uIGluIFguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU3RhcnRpbmcgcG9zaXRpb24gaW4gWS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dHYXBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjcmVhdGVkIGluIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIENvbXBvc2l0ZXMucHlyYW1pZCA9IGZ1bmN0aW9uKHgsIHksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gQ29tcG9zaXRlcy5zdGFjayh4LCB5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgZnVuY3Rpb24oc3RhY2tYLCBzdGFja1ksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbFJvd3MgPSBNYXRoLm1pbihyb3dzLCBNYXRoLmNlaWwoY29sdW1ucyAvIDIpKSxcbiAgICAgICAgICAgICAgICBsYXN0Qm9keVdpZHRoID0gbGFzdEJvZHkgPyBsYXN0Qm9keS5ib3VuZHMubWF4LnggLSBsYXN0Qm9keS5ib3VuZHMubWluLnggOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocm93ID4gYWN0dWFsUm93cylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldmVyc2Ugcm93IG9yZGVyXG4gICAgICAgICAgICByb3cgPSBhY3R1YWxSb3dzIC0gcm93O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByb3csXG4gICAgICAgICAgICAgICAgZW5kID0gY29sdW1ucyAtIDEgLSByb3c7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCBzdGFydCB8fCBjb2x1bW4gPiBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZXRyb2FjdGl2ZWx5IGZpeCB0aGUgZmlyc3QgYm9keSdzIHBvc2l0aW9uLCBzaW5jZSB3aWR0aCB3YXMgdW5rbm93blxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShsYXN0Qm9keSwgeyB4OiAoY29sdW1uICsgKGNvbHVtbnMgJSAyID09PSAxID8gMSA6IC0xKSkgKiBsYXN0Qm9keVdpZHRoLCB5OiAwIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeE9mZnNldCA9IGxhc3RCb2R5ID8gY29sdW1uICogbGFzdEJvZHlXaWR0aCA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh4ICsgeE9mZnNldCArIGNvbHVtbiAqIGNvbHVtbkdhcCwgc3RhY2tZLCBjb2x1bW4sIHJvdywgbGFzdEJvZHksIGkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYXMgbm93IG1vdmVkIHRvIHRoZSBbbmV3dG9uc0NyYWRsZSBleGFtcGxlXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy9ibG9iL21hc3Rlci9leGFtcGxlcy9uZXd0b25zQ3JhZGxlLmpzKSwgZm9sbG93IHRoYXQgaW5zdGVhZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQgaGVyZS5cbiAgICAgKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBuZXd0b25zQ3JhZGxlIGV4YW1wbGVcbiAgICAgKiBAbWV0aG9kIG5ld3RvbnNDcmFkbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBTdGFydGluZyBwb3NpdGlvbiBpbiBYLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFN0YXJ0aW5nIHBvc2l0aW9uIGluIFkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIG5ld3RvbnNDcmFkbGUgYm9keVxuICAgICAqL1xuICAgIENvbXBvc2l0ZXMubmV3dG9uc0NyYWRsZSA9IGZ1bmN0aW9uKHgsIHksIG51bWJlciwgc2l6ZSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXd0b25zQ3JhZGxlID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnTmV3dG9ucyBDcmFkbGUnIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gMS45LFxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IEJvZGllcy5jaXJjbGUoeCArIGkgKiAoc2l6ZSAqIHNlcGFyYXRpb24pLCB5ICsgbGVuZ3RoLCBzaXplLCBcbiAgICAgICAgICAgICAgICAgICAgeyBpbmVydGlhOiBJbmZpbml0eSwgcmVzdGl0dXRpb246IDEsIGZyaWN0aW9uOiAwLCBmcmljdGlvbkFpcjogMC4wMDAxLCBzbG9wOiAxIH0pLFxuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSBDb25zdHJhaW50LmNyZWF0ZSh7IHBvaW50QTogeyB4OiB4ICsgaSAqIChzaXplICogc2VwYXJhdGlvbiksIHk6IHkgfSwgYm9keUI6IGNpcmNsZSB9KTtcblxuICAgICAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkobmV3dG9uc0NyYWRsZSwgY2lyY2xlKTtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KG5ld3RvbnNDcmFkbGUsIGNvbnN0cmFpbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld3RvbnNDcmFkbGU7XG4gICAgfTtcblxuICAgIGRlcHJlY2F0ZWQoQ29tcG9zaXRlcywgJ25ld3RvbnNDcmFkbGUnLCAnQ29tcG9zaXRlcy5uZXd0b25zQ3JhZGxlIOKepCBtb3ZlZCB0byBuZXd0b25zQ3JhZGxlIGV4YW1wbGUnKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIGhhcyBub3cgbW92ZWQgdG8gdGhlIFtjYXIgZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvY2FyLmpzKSwgZm9sbG93IHRoYXQgaW5zdGVhZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQgaGVyZS5cbiAgICAgKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBjYXIgZXhhbXBsZVxuICAgICAqIEBtZXRob2QgY2FyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU3RhcnRpbmcgcG9zaXRpb24gaW4gWC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTdGFydGluZyBwb3NpdGlvbiBpbiBZLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2hlZWxTaXplXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY2FyIGJvZHlcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLmNhciA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHdoZWVsU2l6ZSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBCb2R5Lm5leHRHcm91cCh0cnVlKSxcbiAgICAgICAgICAgIHdoZWVsQmFzZSA9IDIwLFxuICAgICAgICAgICAgd2hlZWxBT2Zmc2V0ID0gLXdpZHRoICogMC41ICsgd2hlZWxCYXNlLFxuICAgICAgICAgICAgd2hlZWxCT2Zmc2V0ID0gd2lkdGggKiAwLjUgLSB3aGVlbEJhc2UsXG4gICAgICAgICAgICB3aGVlbFlPZmZzZXQgPSAwO1xuICAgIFxuICAgICAgICB2YXIgY2FyID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnQ2FyJyB9KSxcbiAgICAgICAgICAgIGJvZHkgPSBCb2RpZXMucmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHsgXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhbWZlcjoge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IGhlaWdodCAqIDAuNVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVuc2l0eTogMC4wMDAyXG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgdmFyIHdoZWVsQSA9IEJvZGllcy5jaXJjbGUoeCArIHdoZWVsQU9mZnNldCwgeSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuOFxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciB3aGVlbEIgPSBCb2RpZXMuY2lyY2xlKHggKyB3aGVlbEJPZmZzZXQsIHkgKyB3aGVlbFlPZmZzZXQsIHdoZWVsU2l6ZSwgeyBcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXhlbEEgPSBDb25zdHJhaW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBib2R5QjogYm9keSxcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiB3aGVlbEFPZmZzZXQsIHk6IHdoZWVsWU9mZnNldCB9LFxuICAgICAgICAgICAgYm9keUE6IHdoZWVsQSxcbiAgICAgICAgICAgIHN0aWZmbmVzczogMSxcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXhlbEIgPSBDb25zdHJhaW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBib2R5QjogYm9keSxcbiAgICAgICAgICAgIHBvaW50QjogeyB4OiB3aGVlbEJPZmZzZXQsIHk6IHdoZWVsWU9mZnNldCB9LFxuICAgICAgICAgICAgYm9keUE6IHdoZWVsQixcbiAgICAgICAgICAgIHN0aWZmbmVzczogMSxcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNhciwgYm9keSk7XG4gICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNhciwgd2hlZWxBKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEIpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjYXIsIGF4ZWxBKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY2FyLCBheGVsQik7XG5cbiAgICAgICAgcmV0dXJuIGNhcjtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChDb21wb3NpdGVzLCAnY2FyJywgJ0NvbXBvc2l0ZXMuY2FyIOKepCBtb3ZlZCB0byBjYXIgZXhhbXBsZScpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBoYXMgbm93IG1vdmVkIHRvIHRoZSBbc29mdEJvZHkgZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvc29mdEJvZHkuanMpXG4gICAgICogYW5kIHRoZSBbY2xvdGggZXhhbXBsZV0oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvY2xvdGguanMpLCBmb2xsb3cgdGhvc2UgaW5zdGVhZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQgaGVyZS5cbiAgICAgKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBzb2Z0Qm9keSBhbmQgY2xvdGggZXhhbXBsZXNcbiAgICAgKiBAbWV0aG9kIHNvZnRCb2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU3RhcnRpbmcgcG9zaXRpb24gaW4gWC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBTdGFydGluZyBwb3NpdGlvbiBpbiBZLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3Jvc3NCcmFjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0aWNsZVJhZGl1c1xuICAgICAqIEBwYXJhbSB7fSBwYXJ0aWNsZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge30gY29uc3RyYWludE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBzb2Z0Qm9keVxuICAgICAqL1xuICAgIENvbXBvc2l0ZXMuc29mdEJvZHkgPSBmdW5jdGlvbih4LCB5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgY3Jvc3NCcmFjZSwgcGFydGljbGVSYWRpdXMsIHBhcnRpY2xlT3B0aW9ucywgY29uc3RyYWludE9wdGlvbnMpIHtcbiAgICAgICAgcGFydGljbGVPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IGluZXJ0aWE6IEluZmluaXR5IH0sIHBhcnRpY2xlT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0cmFpbnRPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IHN0aWZmbmVzczogMC4yLCByZW5kZXI6IHsgdHlwZTogJ2xpbmUnLCBhbmNob3JzOiBmYWxzZSB9IH0sIGNvbnN0cmFpbnRPcHRpb25zKTtcblxuICAgICAgICB2YXIgc29mdEJvZHkgPSBDb21wb3NpdGVzLnN0YWNrKHgsIHksIGNvbHVtbnMsIHJvd3MsIGNvbHVtbkdhcCwgcm93R2FwLCBmdW5jdGlvbihzdGFja1gsIHN0YWNrWSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvZGllcy5jaXJjbGUoc3RhY2tYLCBzdGFja1ksIHBhcnRpY2xlUmFkaXVzLCBwYXJ0aWNsZU9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb3NpdGVzLm1lc2goc29mdEJvZHksIGNvbHVtbnMsIHJvd3MsIGNyb3NzQnJhY2UsIGNvbnN0cmFpbnRPcHRpb25zKTtcblxuICAgICAgICBzb2Z0Qm9keS5sYWJlbCA9ICdTb2Z0IEJvZHknO1xuXG4gICAgICAgIHJldHVybiBzb2Z0Qm9keTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChDb21wb3NpdGVzLCAnc29mdEJvZHknLCAnQ29tcG9zaXRlcy5zb2Z0Qm9keSDinqQgbW92ZWQgdG8gc29mdEJvZHkgYW5kIGNsb3RoIGV4YW1wbGVzJyk7XG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoaXMgbW9kdWxlIGhhcyBub3cgYmVlbiByZXBsYWNlZCBieSBgTWF0dGVyLkRldGVjdG9yYC5cbipcbiogQWxsIHVzYWdlIHNob3VsZCBiZSBtaWdyYXRlZCB0byBgTWF0dGVyLkRldGVjdG9yYCBvciBhbm90aGVyIGFsdGVybmF0aXZlLlxuKiBGb3IgYmFjay1jb21wYXRpYmlsaXR5IHB1cnBvc2VzIHRoaXMgbW9kdWxlIHdpbGwgcmVtYWluIGZvciBhIHNob3J0IHRlcm0gYW5kIHRoZW4gbGF0ZXIgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuKlxuKiBUaGUgYE1hdHRlci5HcmlkYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gYnJvYWRwaGFzZSBncmlkIHN0cnVjdHVyZXMuXG4qXG4qIEBjbGFzcyBHcmlkXG4qIEBkZXByZWNhdGVkXG4qL1xuXG52YXIgR3JpZCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cbnZhciBQYWlyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGRlcHJlY2F0ZWQgPSBDb21tb24uZGVwcmVjYXRlZDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBncmlkLlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtncmlkfSBBIG5ldyBncmlkXG4gICAgICovXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IHt9LFxuICAgICAgICAgICAgcGFpcnM6IHt9LFxuICAgICAgICAgICAgcGFpcnNMaXN0OiBbXSxcbiAgICAgICAgICAgIGJ1Y2tldFdpZHRoOiA0OCxcbiAgICAgICAgICAgIGJ1Y2tldEhlaWdodDogNDhcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRXaWR0aFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGdyaWQgYnVja2V0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJ1Y2tldEhlaWdodFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBncmlkLlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlXG4gICAgICovXG4gICAgR3JpZC51cGRhdGUgPSBmdW5jdGlvbihncmlkLCBib2RpZXMsIGVuZ2luZSwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIGksIGNvbCwgcm93LFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBidWNrZXRzID0gZ3JpZC5idWNrZXRzLFxuICAgICAgICAgICAgYnVja2V0LFxuICAgICAgICAgICAgYnVja2V0SWQsXG4gICAgICAgICAgICBncmlkQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1NsZWVwaW5nICYmICFmb3JjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eSBib3VuZHMgY2hlY2tcbiAgICAgICAgICAgIGlmICh3b3JsZC5ib3VuZHMgJiYgKGJvZHkuYm91bmRzLm1heC54IDwgd29ybGQuYm91bmRzLm1pbi54IHx8IGJvZHkuYm91bmRzLm1pbi54ID4gd29ybGQuYm91bmRzLm1heC54XG4gICAgICAgICAgICAgICAgfHwgYm9keS5ib3VuZHMubWF4LnkgPCB3b3JsZC5ib3VuZHMubWluLnkgfHwgYm9keS5ib3VuZHMubWluLnkgPiB3b3JsZC5ib3VuZHMubWF4LnkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgbmV3UmVnaW9uID0gR3JpZC5fZ2V0UmVnaW9uKGdyaWQsIGJvZHkpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgYm9keSBoYXMgY2hhbmdlZCBncmlkIHJlZ2lvblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlZ2lvbiB8fCBuZXdSZWdpb24uaWQgIT09IGJvZHkucmVnaW9uLmlkIHx8IGZvcmNlVXBkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IGZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBib2R5LnJlZ2lvbiA9IG5ld1JlZ2lvbjtcblxuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IEdyaWQuX3JlZ2lvblVuaW9uKG5ld1JlZ2lvbiwgYm9keS5yZWdpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGdyaWQgYnVja2V0cyBhZmZlY3RlZCBieSByZWdpb24gY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSB1bmlvbiBvZiBib3RoIHJlZ2lvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IHVuaW9uLnN0YXJ0Q29sOyBjb2wgPD0gdW5pb24uZW5kQ29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IHVuaW9uLnN0YXJ0Um93OyByb3cgPD0gdW5pb24uZW5kUm93OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQgPSBHcmlkLl9nZXRCdWNrZXRJZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5zaWRlTmV3UmVnaW9uID0gKGNvbCA+PSBuZXdSZWdpb24uc3RhcnRDb2wgJiYgY29sIDw9IG5ld1JlZ2lvbi5lbmRDb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBuZXdSZWdpb24uc3RhcnRSb3cgJiYgcm93IDw9IG5ld1JlZ2lvbi5lbmRSb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJbnNpZGVPbGRSZWdpb24gPSAoY29sID49IGJvZHkucmVnaW9uLnN0YXJ0Q29sICYmIGNvbCA8PSBib2R5LnJlZ2lvbi5lbmRDb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBib2R5LnJlZ2lvbi5zdGFydFJvdyAmJiByb3cgPD0gYm9keS5yZWdpb24uZW5kUm93KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gb2xkIHJlZ2lvbiBidWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zaWRlTmV3UmVnaW9uICYmIGlzSW5zaWRlT2xkUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5zaWRlT2xkUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLl9idWNrZXRSZW1vdmVCb2R5KGdyaWQsIGJ1Y2tldCwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gbmV3IHJlZ2lvbiBidWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5yZWdpb24gPT09IG5ld1JlZ2lvbiB8fCAoaXNJbnNpZGVOZXdSZWdpb24gJiYgIWlzSW5zaWRlT2xkUmVnaW9uKSB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVja2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBHcmlkLl9jcmVhdGVCdWNrZXQoYnVja2V0cywgYnVja2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyaWQuX2J1Y2tldEFkZEJvZHkoZ3JpZCwgYnVja2V0LCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbmV3IHJlZ2lvblxuICAgICAgICAgICAgICAgIGJvZHkucmVnaW9uID0gbmV3UmVnaW9uO1xuXG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGFuZ2VzIHNvIHdlIGNhbiB1cGRhdGUgcGFpcnNcbiAgICAgICAgICAgICAgICBncmlkQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcGFpcnMgbGlzdCBvbmx5IGlmIHBhaXJzIGNoYW5nZWQgKGkuZS4gYSBib2R5IGNoYW5nZWQgcmVnaW9uKVxuICAgICAgICBpZiAoZ3JpZENoYW5nZWQpXG4gICAgICAgICAgICBncmlkLnBhaXJzTGlzdCA9IEdyaWQuX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdChncmlkKTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChHcmlkLCAndXBkYXRlJywgJ0dyaWQudXBkYXRlIOKepCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JpZC5cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICovXG4gICAgR3JpZC5jbGVhciA9IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5idWNrZXRzID0ge307XG4gICAgICAgIGdyaWQucGFpcnMgPSB7fTtcbiAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChHcmlkLCAnY2xlYXInLCAnR3JpZC5jbGVhciDinqQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgdW5pb24gb2YgdHdvIHJlZ2lvbnMuXG4gICAgICogQG1ldGhvZCBfcmVnaW9uVW5pb25cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSByZWdpb25BXG4gICAgICogQHBhcmFtIHt9IHJlZ2lvbkJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxuICAgICAqL1xuICAgIEdyaWQuX3JlZ2lvblVuaW9uID0gZnVuY3Rpb24ocmVnaW9uQSwgcmVnaW9uQikge1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBNYXRoLm1pbihyZWdpb25BLnN0YXJ0Q29sLCByZWdpb25CLnN0YXJ0Q29sKSxcbiAgICAgICAgICAgIGVuZENvbCA9IE1hdGgubWF4KHJlZ2lvbkEuZW5kQ29sLCByZWdpb25CLmVuZENvbCksXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgubWluKHJlZ2lvbkEuc3RhcnRSb3csIHJlZ2lvbkIuc3RhcnRSb3cpLFxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5tYXgocmVnaW9uQS5lbmRSb3csIHJlZ2lvbkIuZW5kUm93KTtcblxuICAgICAgICByZXR1cm4gR3JpZC5fY3JlYXRlUmVnaW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZWdpb24gYSBnaXZlbiBib2R5IGZhbGxzIGluIGZvciBhIGdpdmVuIGdyaWQuXG4gICAgICogQG1ldGhvZCBfZ2V0UmVnaW9uXG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBib2R5XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICBHcmlkLl9nZXRSZWdpb24gPSBmdW5jdGlvbihncmlkLCBib2R5KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBib2R5LmJvdW5kcyxcbiAgICAgICAgICAgIHN0YXJ0Q29sID0gTWF0aC5mbG9vcihib3VuZHMubWluLnggLyBncmlkLmJ1Y2tldFdpZHRoKSxcbiAgICAgICAgICAgIGVuZENvbCA9IE1hdGguZmxvb3IoYm91bmRzLm1heC54IC8gZ3JpZC5idWNrZXRXaWR0aCksXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC8gZ3JpZC5idWNrZXRIZWlnaHQpLFxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLyBncmlkLmJ1Y2tldEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIEdyaWQuX2NyZWF0ZVJlZ2lvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlZ2lvbi5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVSZWdpb25cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBzdGFydENvbFxuICAgICAqIEBwYXJhbSB7fSBlbmRDb2xcbiAgICAgKiBAcGFyYW0ge30gc3RhcnRSb3dcbiAgICAgKiBAcGFyYW0ge30gZW5kUm93XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICBHcmlkLl9jcmVhdGVSZWdpb24gPSBmdW5jdGlvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KSB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgaWQ6IHN0YXJ0Q29sICsgJywnICsgZW5kQ29sICsgJywnICsgc3RhcnRSb3cgKyAnLCcgKyBlbmRSb3csXG4gICAgICAgICAgICBzdGFydENvbDogc3RhcnRDb2wsIFxuICAgICAgICAgICAgZW5kQ29sOiBlbmRDb2wsIFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93LCBcbiAgICAgICAgICAgIGVuZFJvdzogZW5kUm93IFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBidWNrZXQgaWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2QgX2dldEJ1Y2tldElkXG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gY29sdW1uXG4gICAgICogQHBhcmFtIHt9IHJvd1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gYnVja2V0IGlkXG4gICAgICovXG4gICAgR3JpZC5fZ2V0QnVja2V0SWQgPSBmdW5jdGlvbihjb2x1bW4sIHJvdykge1xuICAgICAgICByZXR1cm4gJ0MnICsgY29sdW1uICsgJ1InICsgcm93O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYnVja2V0LlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUJ1Y2tldFxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldHNcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0SWRcbiAgICAgKiBAcmV0dXJuIHt9IGJ1Y2tldFxuICAgICAqL1xuICAgIEdyaWQuX2NyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uKGJ1Y2tldHMsIGJ1Y2tldElkKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXSA9IFtdO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYm9keSB0byBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRBZGRCb2R5XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIEdyaWQuX2J1Y2tldEFkZEJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgdmFyIGdyaWRQYWlycyA9IGdyaWQucGFpcnMsXG4gICAgICAgICAgICBwYWlySWQgPSBQYWlyLmlkLFxuICAgICAgICAgICAgYnVja2V0TGVuZ3RoID0gYnVja2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBwYWlyc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnVja2V0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGJ1Y2tldFtpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaWQgPT09IGJvZHlCLmlkIHx8IChib2R5LmlzU3RhdGljICYmIGJvZHlCLmlzU3RhdGljKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGJ1Y2tldHMgdGhlIHBhaXIgZXhpc3RzIGluXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIEdyaWQudXBkYXRlIHRvIHdvcmtcbiAgICAgICAgICAgIHZhciBpZCA9IHBhaXJJZChib2R5LCBib2R5QiksXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWRQYWlyc1tpZF07XG5cbiAgICAgICAgICAgIGlmIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgcGFpclsyXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkUGFpcnNbaWRdID0gW2JvZHksIGJvZHlCLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBib2RpZXMgKGFmdGVyIHBhaXJzLCBvdGhlcndpc2UgcGFpcnMgd2l0aCBzZWxmKVxuICAgICAgICBidWNrZXQucHVzaChib2R5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRSZW1vdmVCb2R5XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIEdyaWQuX2J1Y2tldFJlbW92ZUJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgdmFyIGdyaWRQYWlycyA9IGdyaWQucGFpcnMsXG4gICAgICAgICAgICBwYWlySWQgPSBQYWlyLmlkLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyByZW1vdmUgZnJvbSBidWNrZXRcbiAgICAgICAgYnVja2V0LnNwbGljZShDb21tb24uaW5kZXhPZihidWNrZXQsIGJvZHkpLCAxKTtcblxuICAgICAgICB2YXIgYnVja2V0TGVuZ3RoID0gYnVja2V0Lmxlbmd0aDtcblxuICAgICAgICAvLyB1cGRhdGUgcGFpciBjb3VudHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1Y2tldExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCB0byB3b3JrXG4gICAgICAgICAgICB2YXIgcGFpciA9IGdyaWRQYWlyc1twYWlySWQoYm9keSwgYnVja2V0W2ldKV07XG5cbiAgICAgICAgICAgIGlmIChwYWlyKVxuICAgICAgICAgICAgICAgIHBhaXJbMl0gLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHRoZSBhY3RpdmUgcGFpcnMgaW4gdGhlIGdyaWQuXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEByZXR1cm4gW10gcGFpcnNcbiAgICAgKi9cbiAgICBHcmlkLl9jcmVhdGVBY3RpdmVQYWlyc0xpc3QgPSBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBwYWlyLFxuICAgICAgICAgICAgZ3JpZFBhaXJzID0gZ3JpZC5wYWlycyxcbiAgICAgICAgICAgIHBhaXJLZXlzID0gQ29tbW9uLmtleXMoZ3JpZFBhaXJzKSxcbiAgICAgICAgICAgIHBhaXJLZXlzTGVuZ3RoID0gcGFpcktleXMubGVuZ3RoLFxuICAgICAgICAgICAgcGFpcnMgPSBbXSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGdyaWQucGFpcnNcbiAgICAgICAgZm9yIChrID0gMDsgayA8IHBhaXJLZXlzTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBncmlkUGFpcnNbcGFpcktleXNba11dO1xuXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGV4aXN0cyBpbiBhdCBsZWFzdCBvbmUgYnVja2V0XG4gICAgICAgICAgICAvLyBpdCBpcyBhIHBhaXIgdGhhdCBuZWVkcyBmdXJ0aGVyIGNvbGxpc2lvbiB0ZXN0aW5nIHNvIHB1c2ggaXRcbiAgICAgICAgICAgIGlmIChwYWlyWzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBncmlkUGFpcnNbcGFpcktleXNba11dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG4gICAgXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLk1vdXNlQ29uc3RyYWludGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIG1vdXNlIGNvbnN0cmFpbnRzLlxuKiBNb3VzZSBjb25zdHJhaW50cyBhcmUgdXNlZCBmb3IgYWxsb3dpbmcgdXNlciBpbnRlcmFjdGlvbiwgcHJvdmlkaW5nIHRoZSBhYmlsaXR5IHRvIG1vdmUgYm9kaWVzIHZpYSB0aGUgbW91c2Ugb3IgdG91Y2guXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBNb3VzZUNvbnN0cmFpbnRcbiovXG5cbnZhciBNb3VzZUNvbnN0cmFpbnQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUNvbnN0cmFpbnQ7XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgU2xlZXBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIE1vdXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgRXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEZXRlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIENvbnN0cmFpbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBDb21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtb3VzZSBjb25zdHJhaW50LlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge01vdXNlQ29uc3RyYWludH0gQSBuZXcgTW91c2VDb25zdHJhaW50XG4gICAgICovXG4gICAgTW91c2VDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW91c2UgPSAoZW5naW5lID8gZW5naW5lLm1vdXNlIDogbnVsbCkgfHwgKG9wdGlvbnMgPyBvcHRpb25zLm1vdXNlIDogbnVsbCk7XG5cbiAgICAgICAgaWYgKCFtb3VzZSkge1xuICAgICAgICAgICAgaWYgKGVuZ2luZSAmJiBlbmdpbmUucmVuZGVyICYmIGVuZ2luZS5yZW5kZXIuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUoZW5naW5lLnJlbmRlci5jYW52YXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKG9wdGlvbnMuZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ01vdXNlQ29uc3RyYWludC5jcmVhdGU6IG9wdGlvbnMubW91c2Ugd2FzIHVuZGVmaW5lZCwgb3B0aW9ucy5lbGVtZW50IHdhcyB1bmRlZmluZWQsIG1heSBub3QgZnVuY3Rpb24gYXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29uc3RyYWludC5jcmVhdGUoeyBcbiAgICAgICAgICAgIGxhYmVsOiAnTW91c2UgQ29uc3RyYWludCcsXG4gICAgICAgICAgICBwb2ludEE6IG1vdXNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9pbnRCOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogMC4wMSwgXG4gICAgICAgICAgICBzdGlmZm5lc3M6IDAuMSxcbiAgICAgICAgICAgIGFuZ3VsYXJTdGlmZm5lc3M6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJyM5MEVFOTAnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogM1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnbW91c2VDb25zdHJhaW50JyxcbiAgICAgICAgICAgIG1vdXNlOiBtb3VzZSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3VzZUNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBFdmVudHMub24oZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhlbmdpbmUud29ybGQpO1xuICAgICAgICAgICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZShtb3VzZUNvbnN0cmFpbnQsIGFsbEJvZGllcyk7XG4gICAgICAgICAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMobW91c2VDb25zdHJhaW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vdXNlQ29uc3RyYWludDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gbW91c2UgY29uc3RyYWludC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUNvbnN0cmFpbnR9IG1vdXNlQ29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQudXBkYXRlID0gZnVuY3Rpb24obW91c2VDb25zdHJhaW50LCBib2RpZXMpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgY29uc3RyYWludCA9IG1vdXNlQ29uc3RyYWludC5jb25zdHJhaW50LFxuICAgICAgICAgICAgYm9keSA9IG1vdXNlQ29uc3RyYWludC5ib2R5O1xuXG4gICAgICAgIGlmIChtb3VzZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghY29uc3RyYWludC5ib2R5Qikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMoYm9keS5ib3VuZHMsIG1vdXNlLnBvc2l0aW9uKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHkuY29sbGlzaW9uRmlsdGVyLCBtb3VzZUNvbnN0cmFpbnQuY29sbGlzaW9uRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gbW91c2UucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiBtb3VzZS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBtb3VzZS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYW5nbGVCID0gYm9keS5hbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdzdGFydGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChjb25zdHJhaW50LmJvZHlCLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBtb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ2VuZGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBtb3VzZSBjb25zdHJhaW50IGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIF90cmlnZ2VyRXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZUNvbnN0cmFpbnRcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihtb3VzZUNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgbW91c2VFdmVudHMgPSBtb3VzZS5zb3VyY2VFdmVudHM7XG5cbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNlbW92ZSlcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNlbW92ZScsIHsgbW91c2U6IG1vdXNlIH0pO1xuXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZWRvd24pXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZWRvd24nLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2V1cClcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNldXAnLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICAvLyByZXNldCB0aGUgbW91c2Ugc3RhdGUgcmVhZHkgZm9yIHRoZSBuZXh0IHN0ZXBcbiAgICAgICAgTW91c2UuY2xlYXJTb3VyY2VFdmVudHMobW91c2UpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBoYXMgbW92ZWQgKG9yIGEgdG91Y2ggbW92ZXMpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNlbW92ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgZG93biAob3IgYSB0b3VjaCBoYXMgc3RhcnRlZCkgZHVyaW5nIHRoZSBsYXN0IHN0ZXBcbiAgICAqXG4gICAgKiBAZXZlbnQgbW91c2Vkb3duXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyB1cCAob3IgYSB0b3VjaCBoYXMgZW5kZWQpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNldXBcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGEgYm9keVxuICAgICpcbiAgICAqIEBldmVudCBzdGFydGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IGJlaW5nIGRyYWdnZWRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGVuZHMgZHJhZ2dpbmcgYSBib2R5XG4gICAgKlxuICAgICogQGV2ZW50IGVuZGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IHRoYXQgaGFzIHN0b3BwZWQgYmVpbmcgZHJhZ2dlZFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgZGVub3RpbmcgdGhlIHR5cGUgb2Ygb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcImNvbnN0cmFpbnRcIlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBNb3VzZWAgaW5zdGFuY2UgaW4gdXNlLiBJZiBub3Qgc3VwcGxpZWQgaW4gYE1vdXNlQ29uc3RyYWludC5jcmVhdGVgLCBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgbW91c2VcbiAgICAgKiBAZGVmYXVsdCBtb3VzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBCb2R5YCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBtb3ZlZCBieSB0aGUgdXNlciwgb3IgYG51bGxgIGlmIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9keVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYENvbnN0cmFpbnRgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gbW92ZSB0aGUgYm9keSBkdXJpbmcgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludFxuICAgICAqIEB0eXBlIGNvbnN0cmFpbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyIHByb3BlcnRpZXMuXG4gICAgICogVGhlIGNvbGxpc2lvbiBmaWx0ZXIgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB3aGljaCB0eXBlcyBvZiBib2R5IHRoaXMgbW91c2UgY29uc3RyYWludCBjYW4gaW50ZXJhY3Qgd2l0aC5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5RdWVyeWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgY29sbGlzaW9uIHF1ZXJpZXMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBRdWVyeVxuKi9cblxudmFyIFF1ZXJ5ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbnZhciBWZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIENvbGxpc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBCb2RpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbGxpc2lvbnMgYmV0d2VlbiBgYm9keWAgYW5kIGBib2RpZXNgLlxuICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9uW119IENvbGxpc2lvbnNcbiAgICAgKi9cbiAgICBRdWVyeS5jb2xsaWRlcyA9IGZ1bmN0aW9uKGJvZHksIGJvZGllcykge1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICAgICAgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGJvdW5kcyA9IGJvZHkuYm91bmRzLFxuICAgICAgICAgICAgY29sbGlkZXMgPSBDb2xsaXNpb24uY29sbGlkZXMsXG4gICAgICAgICAgICBvdmVybGFwcyA9IEJvdW5kcy5vdmVybGFwcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgcGFydHNBTGVuZ3RoID0gYm9keUEucGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhcnRzQVN0YXJ0ID0gcGFydHNBTGVuZ3RoID09PSAxID8gMCA6IDE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvdmVybGFwcyhib2R5QS5ib3VuZHMsIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcGFydHNBU3RhcnQ7IGogPCBwYXJ0c0FMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHlBLnBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhwYXJ0LmJvdW5kcywgYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpZGVzKHBhcnQsIGJvZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGlzaW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYSByYXkgc2VnbWVudCBhZ2FpbnN0IGEgc2V0IG9mIGJvZGllcyBhbmQgcmV0dXJucyBhbGwgY29sbGlzaW9ucywgcmF5IHdpZHRoIGlzIG9wdGlvbmFsLiBJbnRlcnNlY3Rpb24gcG9pbnRzIGFyZSBub3QgcHJvdmlkZWQuXG4gICAgICogQG1ldGhvZCByYXlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JheVdpZHRoXVxuICAgICAqIEByZXR1cm4ge2NvbGxpc2lvbltdfSBDb2xsaXNpb25zXG4gICAgICovXG4gICAgUXVlcnkucmF5ID0gZnVuY3Rpb24oYm9kaWVzLCBzdGFydFBvaW50LCBlbmRQb2ludCwgcmF5V2lkdGgpIHtcbiAgICAgICAgcmF5V2lkdGggPSByYXlXaWR0aCB8fCAxZS0xMDA7XG5cbiAgICAgICAgdmFyIHJheUFuZ2xlID0gVmVjdG9yLmFuZ2xlKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSxcbiAgICAgICAgICAgIHJheUxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1YihzdGFydFBvaW50LCBlbmRQb2ludCkpLFxuICAgICAgICAgICAgcmF5WCA9IChlbmRQb2ludC54ICsgc3RhcnRQb2ludC54KSAqIDAuNSxcbiAgICAgICAgICAgIHJheVkgPSAoZW5kUG9pbnQueSArIHN0YXJ0UG9pbnQueSkgKiAwLjUsXG4gICAgICAgICAgICByYXkgPSBCb2RpZXMucmVjdGFuZ2xlKHJheVgsIHJheVksIHJheUxlbmd0aCwgcmF5V2lkdGgsIHsgYW5nbGU6IHJheUFuZ2xlIH0pLFxuICAgICAgICAgICAgY29sbGlzaW9ucyA9IFF1ZXJ5LmNvbGxpZGVzKHJheSwgYm9kaWVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxpc2lvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xuICAgICAgICAgICAgY29sbGlzaW9uLmJvZHkgPSBjb2xsaXNpb24uYm9keUIgPSBjb2xsaXNpb24uYm9keUE7ICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGlzaW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIGJvdW5kcyBhcmUgaW5zaWRlIChvciBvdXRzaWRlIGlmIHNldCkgdGhlIGdpdmVuIHNldCBvZiBib3VuZHMsIGZyb20gdGhlIGdpdmVuIHNldCBvZiBib2RpZXMuXG4gICAgICogQG1ldGhvZCByZWdpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW291dHNpZGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBUaGUgYm9kaWVzIG1hdGNoaW5nIHRoZSBxdWVyeVxuICAgICAqL1xuICAgIFF1ZXJ5LnJlZ2lvbiA9IGZ1bmN0aW9uKGJvZGllcywgYm91bmRzLCBvdXRzaWRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIGJvdW5kcyk7XG4gICAgICAgICAgICBpZiAoKG92ZXJsYXBzICYmICFvdXRzaWRlKSB8fCAoIW92ZXJsYXBzICYmIG91dHNpZGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIHZlcnRpY2VzIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LCBmcm9tIHRoZSBnaXZlbiBzZXQgb2YgYm9kaWVzLlxuICAgICAqIEBtZXRob2QgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7Ym9keVtdfSBUaGUgYm9kaWVzIG1hdGNoaW5nIHRoZSBxdWVyeVxuICAgICAqL1xuICAgIFF1ZXJ5LnBvaW50ID0gZnVuY3Rpb24oYm9kaWVzLCBwb2ludCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBwb2ludCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gYm9keS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocGFydC5ib3VuZHMsIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLlJlbmRlcmAgbW9kdWxlIGlzIGEgbGlnaHR3ZWlnaHQsIG9wdGlvbmFsIHV0aWxpdHkgd2hpY2ggcHJvdmlkZXMgYSBzaW1wbGUgY2FudmFzIGJhc2VkIHJlbmRlcmVyIGZvciB2aXN1YWxpc2luZyBpbnN0YW5jZXMgb2YgYE1hdHRlci5FbmdpbmVgLlxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXG4qIEl0IGluY2x1ZGVzIGEgbnVtYmVyIG9mIGRyYXdpbmcgb3B0aW9ucyBpbmNsdWRpbmcgd2lyZWZyYW1lLCB2ZWN0b3Igd2l0aCBzdXBwb3J0IGZvciBzcHJpdGVzIGFuZCB2aWV3cG9ydHMuXG4qXG4qIEBjbGFzcyBSZW5kZXJcbiovXG5cbnZhciBSZW5kZXIgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXI7XG5cbnZhciBCb2R5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIENvbXBvc2l0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgTW91c2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKXsgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKENvbW1vbi5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XG5cbiAgICAgICAgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgUmVuZGVyLl9nb29kRnBzID0gMzA7XG4gICAgUmVuZGVyLl9nb29kRGVsdGEgPSAxMDAwIC8gNjA7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlcmVyLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7cmVuZGVyfSBBIG5ldyByZW5kZXJlclxuICAgICAqL1xuICAgIFJlbmRlci5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGVuZ2luZTogbnVsbCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBjYW52YXM6IG51bGwsXG4gICAgICAgICAgICBtb3VzZTogbnVsbCxcbiAgICAgICAgICAgIGZyYW1lUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgdGltaW5nOiB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVNpemU6IDYwLFxuICAgICAgICAgICAgICAgIGRlbHRhOiAwLFxuICAgICAgICAgICAgICAgIGRlbHRhSGlzdG9yeTogW10sXG4gICAgICAgICAgICAgICAgbGFzdFRpbWU6IDAsXG4gICAgICAgICAgICAgICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgICAgICBsYXN0RWxhcHNlZDogMCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBFbGFwc2VkOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgICAgICBlbmdpbmVEZWx0YUhpc3Rvcnk6IFtdLFxuICAgICAgICAgICAgICAgIGVuZ2luZUVsYXBzZWRIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgICAgICBlbmdpbmVVcGRhdGVzSGlzdG9yeTogW10sXG4gICAgICAgICAgICAgICAgZWxhcHNlZEhpc3Rvcnk6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzE0MTUxZicsXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lQmFja2dyb3VuZDogJyMxNDE1MWYnLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZVN0cm9rZVN0eWxlOiAnI2JiYicsXG4gICAgICAgICAgICAgICAgaGFzQm91bmRzOiAhIW9wdGlvbnMuYm91bmRzLFxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93U2xlZXBpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd0RlYnVnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93U3RhdHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dQZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0JvdW5kczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1ZlbG9jaXR5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93Q29sbGlzaW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1NlcGFyYXRpb25zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QXhlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1Bvc2l0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0FuZ2xlSW5kaWNhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93SWRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VmVydGV4TnVtYmVyczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0NvbnZleEh1bGxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd01vdXNlUG9zaXRpb246IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbmRlciA9IENvbW1vbi5leHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZW5kZXIuY2FudmFzKSB7XG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLndpZHRoID0gcmVuZGVyLm9wdGlvbnMud2lkdGggfHwgcmVuZGVyLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHJlbmRlci5jYW52YXMuaGVpZ2h0ID0gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0IHx8IHJlbmRlci5jYW52YXMuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyLm1vdXNlID0gb3B0aW9ucy5tb3VzZTtcbiAgICAgICAgcmVuZGVyLmVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xuICAgICAgICByZW5kZXIuY2FudmFzID0gcmVuZGVyLmNhbnZhcyB8fCBfY3JlYXRlQ2FudmFzKHJlbmRlci5vcHRpb25zLndpZHRoLCByZW5kZXIub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICByZW5kZXIuY29udGV4dCA9IHJlbmRlci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgcmVuZGVyLnRleHR1cmVzID0ge307XG5cbiAgICAgICAgcmVuZGVyLmJvdW5kcyA9IHJlbmRlci5ib3VuZHMgfHwge1xuICAgICAgICAgICAgbWluOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICAgICAgeDogcmVuZGVyLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZvciB0ZW1wb3JhcnkgYmFjayBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgICAgcmVuZGVyLmNvbnRyb2xsZXIgPSBSZW5kZXI7XG4gICAgICAgIHJlbmRlci5vcHRpb25zLnNob3dCcm9hZHBoYXNlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgIFJlbmRlci5zZXRQaXhlbFJhdGlvKHJlbmRlciwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tbW9uLmlzRWxlbWVudChyZW5kZXIuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJlbmRlci5lbGVtZW50LmFwcGVuZENoaWxkKHJlbmRlci5jYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGludW91c2x5IHVwZGF0ZXMgdGhlIHJlbmRlciBjYW52YXMgb24gdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGV2ZW50LlxuICAgICAqIEBtZXRob2QgcnVuXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5ydW4gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3AodGltZSl7XG4gICAgICAgICAgICByZW5kZXIuZnJhbWVSZXF1ZXN0SWQgPSBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBfdXBkYXRlVGltaW5nKHJlbmRlciwgdGltZSk7XG5cbiAgICAgICAgICAgIFJlbmRlci53b3JsZChyZW5kZXIsIHRpbWUpO1xuXG4gICAgICAgICAgICByZW5kZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0ocmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5zaG93U3RhdHMgfHwgcmVuZGVyLm9wdGlvbnMuc2hvd0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyLnN0YXRzKHJlbmRlciwgcmVuZGVyLmNvbnRleHQsIHRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyLm9wdGlvbnMuc2hvd1BlcmZvcm1hbmNlIHx8IHJlbmRlci5vcHRpb25zLnNob3dEZWJ1Zykge1xuICAgICAgICAgICAgICAgIFJlbmRlci5wZXJmb3JtYW5jZShyZW5kZXIsIHJlbmRlci5jb250ZXh0LCB0aW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB9KSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXIuZnJhbWVSZXF1ZXN0SWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIgYW5kIHVwZGF0ZXMgdGhlIGNhbnZhcy5cbiAgICAgKiBUbyBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgY29ycmVjdCByYXRpbywgcGFzcyB0aGUgc3RyaW5nIGAnYXV0bydgIGZvciBgcGl4ZWxSYXRpb2AuXG4gICAgICogQG1ldGhvZCBzZXRQaXhlbFJhdGlvXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAgICovXG4gICAgUmVuZGVyLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihyZW5kZXIsIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlci5jYW52YXM7XG5cbiAgICAgICAgaWYgKHBpeGVsUmF0aW8gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IF9nZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVuZGVyIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxuICAgICAqIFxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBhY2NvdW50aW5nIGZvciBgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpb2AuICBcbiAgICAgKiBcbiAgICAgKiBVcGRhdGVzIHRoZSBib3R0b20gcmlnaHQgcmVuZGVyIGJvdW5kIGByZW5kZXIuYm91bmRzLm1heGAgcmVsYXRpdmUgdG8gdGhlIHByb3ZpZGVkIGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxuICAgICAqIFRoZSB0b3AgbGVmdCByZW5kZXIgYm91bmQgYHJlbmRlci5ib3VuZHMubWluYCBpc24ndCBjaGFuZ2VkLlxuICAgICAqIFxuICAgICAqIEZvbGxvdyB0aGlzIGNhbGwgd2l0aCBgUmVuZGVyLmxvb2tBdGAgaWYgeW91IG5lZWQgdG8gY2hhbmdlIHRoZSByZW5kZXIgYm91bmRzLlxuICAgICAqIFxuICAgICAqIFNlZSBhbHNvIGBSZW5kZXIuc2V0UGl4ZWxSYXRpb2AuXG4gICAgICogQG1ldGhvZCBzZXRTaXplXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggKGluIENTUyBwaXhlbHMpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IChpbiBDU1MgcGl4ZWxzKVxuICAgICAqL1xuICAgIFJlbmRlci5zZXRTaXplID0gZnVuY3Rpb24ocmVuZGVyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlci5vcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlbmRlci5vcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueCA9IHJlbmRlci5ib3VuZHMubWluLnggKyB3aWR0aDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSA9IHJlbmRlci5ib3VuZHMubWluLnkgKyBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8gIT09IDEpIHtcbiAgICAgICAgICAgIFJlbmRlci5zZXRQaXhlbFJhdGlvKHJlbmRlciwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbnMgYW5kIHNpemVzIHRoZSB2aWV3cG9ydCBhcm91bmQgdGhlIGdpdmVuIG9iamVjdCBib3VuZHMuXG4gICAgICogT2JqZWN0cyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAtIGBvYmplY3QuYm91bmRzYFxuICAgICAqIC0gYG9iamVjdC5wb3NpdGlvbmBcbiAgICAgKiAtIGBvYmplY3QubWluYCBhbmQgYG9iamVjdC5tYXhgXG4gICAgICogLSBgb2JqZWN0LnhgIGFuZCBgb2JqZWN0LnlgXG4gICAgICogQG1ldGhvZCBsb29rQXRcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBbcGFkZGluZ11cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtjZW50ZXI9dHJ1ZV1cbiAgICAgKi9cbiAgICBSZW5kZXIubG9va0F0ID0gZnVuY3Rpb24ocmVuZGVyLCBvYmplY3RzLCBwYWRkaW5nLCBjZW50ZXIpIHtcbiAgICAgICAgY2VudGVyID0gdHlwZW9mIGNlbnRlciAhPT0gJ3VuZGVmaW5lZCcgPyBjZW50ZXIgOiB0cnVlO1xuICAgICAgICBvYmplY3RzID0gQ29tbW9uLmlzQXJyYXkob2JqZWN0cykgPyBvYmplY3RzIDogW29iamVjdHNdO1xuICAgICAgICBwYWRkaW5nID0gcGFkZGluZyB8fCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZpbmQgYm91bmRzIG9mIGFsbCBvYmplY3RzXG4gICAgICAgIHZhciBib3VuZHMgPSB7XG4gICAgICAgICAgICBtaW46IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5IH0sXG4gICAgICAgICAgICBtYXg6IHsgeDogLUluZmluaXR5LCB5OiAtSW5maW5pdHkgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNbaV0sXG4gICAgICAgICAgICAgICAgbWluID0gb2JqZWN0LmJvdW5kcyA/IG9iamVjdC5ib3VuZHMubWluIDogKG9iamVjdC5taW4gfHwgb2JqZWN0LnBvc2l0aW9uIHx8IG9iamVjdCksXG4gICAgICAgICAgICAgICAgbWF4ID0gb2JqZWN0LmJvdW5kcyA/IG9iamVjdC5ib3VuZHMubWF4IDogKG9iamVjdC5tYXggfHwgb2JqZWN0LnBvc2l0aW9uIHx8IG9iamVjdCk7XG5cbiAgICAgICAgICAgIGlmIChtaW4gJiYgbWF4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbi54IDwgYm91bmRzLm1pbi54KVxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWluLnggPSBtaW4ueDtcblxuICAgICAgICAgICAgICAgIGlmIChtYXgueCA+IGJvdW5kcy5tYXgueClcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1heC54ID0gbWF4Lng7XG5cbiAgICAgICAgICAgICAgICBpZiAobWluLnkgPCBib3VuZHMubWluLnkpXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5taW4ueSA9IG1pbi55O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heC55ID4gYm91bmRzLm1heC55KVxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWF4LnkgPSBtYXgueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgcmF0aW9zXG4gICAgICAgIHZhciB3aWR0aCA9IChib3VuZHMubWF4LnggLSBib3VuZHMubWluLngpICsgMiAqIHBhZGRpbmcueCxcbiAgICAgICAgICAgIGhlaWdodCA9IChib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkpICsgMiAqIHBhZGRpbmcueSxcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSByZW5kZXIuY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IHJlbmRlci5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICBvdXRlclJhdGlvID0gdmlld1dpZHRoIC8gdmlld0hlaWdodCxcbiAgICAgICAgICAgIGlubmVyUmF0aW8gPSB3aWR0aCAvIGhlaWdodCxcbiAgICAgICAgICAgIHNjYWxlWCA9IDEsXG4gICAgICAgICAgICBzY2FsZVkgPSAxO1xuXG4gICAgICAgIC8vIGZpbmQgc2NhbGUgZmFjdG9yXG4gICAgICAgIGlmIChpbm5lclJhdGlvID4gb3V0ZXJSYXRpbykge1xuICAgICAgICAgICAgc2NhbGVZID0gaW5uZXJSYXRpbyAvIG91dGVyUmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVggPSBvdXRlclJhdGlvIC8gaW5uZXJSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuYWJsZSBib3VuZHNcbiAgICAgICAgcmVuZGVyLm9wdGlvbnMuaGFzQm91bmRzID0gdHJ1ZTtcblxuICAgICAgICAvLyBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54ID0gYm91bmRzLm1pbi54O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1heC54ID0gYm91bmRzLm1pbi54ICsgd2lkdGggKiBzY2FsZVg7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnkgPSBib3VuZHMubWluLnk7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgPSBib3VuZHMubWluLnkgKyBoZWlnaHQgKiBzY2FsZVk7XG5cbiAgICAgICAgLy8gY2VudGVyXG4gICAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggKz0gd2lkdGggKiAwLjUgLSAod2lkdGggKiBzY2FsZVgpICogMC41O1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueCArPSB3aWR0aCAqIDAuNSAtICh3aWR0aCAqIHNjYWxlWCkgKiAwLjU7XG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55ICs9IGhlaWdodCAqIDAuNSAtIChoZWlnaHQgKiBzY2FsZVkpICogMC41O1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSArPSBoZWlnaHQgKiAwLjUgLSAoaGVpZ2h0ICogc2NhbGVZKSAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCAtPSBwYWRkaW5nLng7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggLT0gcGFkZGluZy54O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55IC09IHBhZGRpbmcueTtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueSAtPSBwYWRkaW5nLnk7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1vdXNlXG4gICAgICAgIGlmIChyZW5kZXIubW91c2UpIHtcbiAgICAgICAgICAgIE1vdXNlLnNldFNjYWxlKHJlbmRlci5tb3VzZSwge1xuICAgICAgICAgICAgICAgIHg6IChyZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCkgLyByZW5kZXIuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgIHk6IChyZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSkgLyByZW5kZXIuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE1vdXNlLnNldE9mZnNldChyZW5kZXIubW91c2UsIHJlbmRlci5ib3VuZHMubWluKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHZpZXdwb3J0IHRyYW5zZm9ybXMgYmFzZWQgb24gYHJlbmRlci5ib3VuZHNgIHRvIGEgcmVuZGVyIGNvbnRleHQuXG4gICAgICogQG1ldGhvZCBzdGFydFZpZXdUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLnN0YXJ0Vmlld1RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgYm91bmRzU2NhbGVYID0gYm91bmRzV2lkdGggLyByZW5kZXIub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcblxuICAgICAgICByZW5kZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0oXG4gICAgICAgICAgICByZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvIC8gYm91bmRzU2NhbGVYLCAwLCAwLCBcbiAgICAgICAgICAgIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8gLyBib3VuZHNTY2FsZVksIDAsIDBcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJlbmRlci5jb250ZXh0LnRyYW5zbGF0ZSgtcmVuZGVyLmJvdW5kcy5taW4ueCwgLXJlbmRlci5ib3VuZHMubWluLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIHRyYW5zZm9ybXMgb24gdGhlIHJlbmRlciBjb250ZXh0LlxuICAgICAqIEBtZXRob2QgZW5kVmlld1RyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKi9cbiAgICBSZW5kZXIuZW5kVmlld1RyYW5zZm9ybSA9IGZ1bmN0aW9uKHJlbmRlcikge1xuICAgICAgICByZW5kZXIuY29udGV4dC5zZXRUcmFuc2Zvcm0ocmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCwgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGdpdmVuIGBlbmdpbmVgJ3MgYE1hdHRlci5Xb3JsZGAgb2JqZWN0LlxuICAgICAqIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBhbGwgcmVuZGVyaW5nIGFuZCBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHNjZW5lIGNoYW5nZXMuXG4gICAgICogQG1ldGhvZCB3b3JsZFxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKi9cbiAgICBSZW5kZXIud29ybGQgPSBmdW5jdGlvbihyZW5kZXIsIHRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IENvbW1vbi5ub3coKSxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICB3b3JsZCA9IGVuZ2luZS53b3JsZCxcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlci5jYW52YXMsXG4gICAgICAgICAgICBjb250ZXh0ID0gcmVuZGVyLmNvbnRleHQsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICB0aW1pbmcgPSByZW5kZXIudGltaW5nO1xuXG4gICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcbiAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKHdvcmxkKSxcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBvcHRpb25zLndpcmVmcmFtZXMgPyBvcHRpb25zLndpcmVmcmFtZUJhY2tncm91bmQgOiBvcHRpb25zLmJhY2tncm91bmQsXG4gICAgICAgICAgICBib2RpZXMgPSBbXSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gW10sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZW5naW5lLnRpbWluZy50aW1lc3RhbXBcbiAgICAgICAgfTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihyZW5kZXIsICdiZWZvcmVSZW5kZXInLCBldmVudCk7XG5cbiAgICAgICAgLy8gYXBwbHkgYmFja2dyb3VuZCBpZiBpdCBoYXMgY2hhbmdlZFxuICAgICAgICBpZiAocmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kKVxuICAgICAgICAgICAgX2FwcGx5QmFja2dyb3VuZChyZW5kZXIsIGJhY2tncm91bmQpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXMgd2l0aCBhIHRyYW5zcGFyZW50IGZpbGwsIHRvIGFsbG93IHRoZSBjYW52YXMgYmFja2dyb3VuZCB0byBzaG93XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1pbic7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgICAgICAvLyBoYW5kbGUgYm91bmRzXG4gICAgICAgIGlmIChvcHRpb25zLmhhc0JvdW5kcykge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBib2RpZXMgdGhhdCBhcmUgbm90IGluIHZpZXdcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxCb2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGFsbEJvZGllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoQm91bmRzLm92ZXJsYXBzKGJvZHkuYm91bmRzLCByZW5kZXIuYm91bmRzKSlcbiAgICAgICAgICAgICAgICAgICAgYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY29uc3RyYWludHMgdGhhdCBhcmUgbm90IGluIHZpZXdcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gYWxsQ29uc3RyYWludHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxuICAgICAgICAgICAgICAgICAgICBwb2ludEFXb3JsZCA9IGNvbnN0cmFpbnQucG9pbnRBLFxuICAgICAgICAgICAgICAgICAgICBwb2ludEJXb3JsZCA9IGNvbnN0cmFpbnQucG9pbnRCO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBKSBwb2ludEFXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keUIpIHBvaW50QldvcmxkID0gVmVjdG9yLmFkZChib2R5Qi5wb3NpdGlvbiwgY29uc3RyYWludC5wb2ludEIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludEFXb3JsZCB8fCAhcG9pbnRCV29ybGQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEFXb3JsZCkgfHwgQm91bmRzLmNvbnRhaW5zKHJlbmRlci5ib3VuZHMsIHBvaW50QldvcmxkKSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIHRoZSB2aWV3XG4gICAgICAgICAgICBSZW5kZXIuc3RhcnRWaWV3VHJhbnNmb3JtKHJlbmRlcik7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtb3VzZVxuICAgICAgICAgICAgaWYgKHJlbmRlci5tb3VzZSkge1xuICAgICAgICAgICAgICAgIE1vdXNlLnNldFNjYWxlKHJlbmRlci5tb3VzZSwge1xuICAgICAgICAgICAgICAgICAgICB4OiAocmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngpIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHk6IChyZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSkgLyByZW5kZXIub3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIE1vdXNlLnNldE9mZnNldChyZW5kZXIubW91c2UsIHJlbmRlci5ib3VuZHMubWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gYWxsQ29uc3RyYWludHM7XG4gICAgICAgICAgICBib2RpZXMgPSBhbGxCb2RpZXM7XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDAsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLndpcmVmcmFtZXMgfHwgKGVuZ2luZS5lbmFibGVTbGVlcGluZyAmJiBvcHRpb25zLnNob3dTbGVlcGluZykpIHtcbiAgICAgICAgICAgIC8vIGZ1bGx5IGZlYXR1cmVkIHJlbmRlcmluZyBvZiBib2RpZXNcbiAgICAgICAgICAgIFJlbmRlci5ib2RpZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0NvbnZleEh1bGxzKVxuICAgICAgICAgICAgICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAvLyBvcHRpbWlzZWQgbWV0aG9kIGZvciB3aXJlZnJhbWVzIG9ubHlcbiAgICAgICAgICAgIFJlbmRlci5ib2R5V2lyZWZyYW1lcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Qm91bmRzKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlCb3VuZHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dBeGVzIHx8IG9wdGlvbnMuc2hvd0FuZ2xlSW5kaWNhdG9yKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlBeGVzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93UG9zaXRpb25zKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlQb3NpdGlvbnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dWZWxvY2l0eSlcbiAgICAgICAgICAgIFJlbmRlci5ib2R5VmVsb2NpdHkocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dJZHMpXG4gICAgICAgICAgICBSZW5kZXIuYm9keUlkcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1NlcGFyYXRpb25zKVxuICAgICAgICAgICAgUmVuZGVyLnNlcGFyYXRpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dDb2xsaXNpb25zKVxuICAgICAgICAgICAgUmVuZGVyLmNvbGxpc2lvbnMocmVuZGVyLCBlbmdpbmUucGFpcnMubGlzdCwgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1ZlcnRleE51bWJlcnMpXG4gICAgICAgICAgICBSZW5kZXIudmVydGV4TnVtYmVycyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd01vdXNlUG9zaXRpb24pXG4gICAgICAgICAgICBSZW5kZXIubW91c2VQb3NpdGlvbihyZW5kZXIsIHJlbmRlci5tb3VzZSwgY29udGV4dCk7XG5cbiAgICAgICAgUmVuZGVyLmNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIC8vIHJldmVydCB2aWV3IHRyYW5zZm9ybXNcbiAgICAgICAgICAgIFJlbmRlci5lbmRWaWV3VHJhbnNmb3JtKHJlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihyZW5kZXIsICdhZnRlclJlbmRlcicsIGV2ZW50KTtcblxuICAgICAgICAvLyBsb2cgdGhlIHRpbWUgZWxhcHNlZCBjb21wdXRpbmcgdGhpcyB1cGRhdGVcbiAgICAgICAgdGltaW5nLmxhc3RFbGFwc2VkID0gQ29tbW9uLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHN0YXRpc3RpY3MgYWJvdXQgdGhlIGVuZ2luZSBhbmQgd29ybGQgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHN0YXRzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gICAgICovXG4gICAgUmVuZGVyLnN0YXRzID0gZnVuY3Rpb24ocmVuZGVyLCBjb250ZXh0LCB0aW1lKSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcbiAgICAgICAgICAgIHBhcnRzID0gMCxcbiAgICAgICAgICAgIHdpZHRoID0gNTUsXG4gICAgICAgICAgICBoZWlnaHQgPSA0NCxcbiAgICAgICAgICAgIHggPSAwLFxuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBjb3VudCBwYXJ0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFydHMgKz0gYm9kaWVzW2ldLnBhcnRzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlY3Rpb25zXG4gICAgICAgIHZhciBzZWN0aW9ucyA9IHtcbiAgICAgICAgICAgICdQYXJ0JzogcGFydHMsXG4gICAgICAgICAgICAnQm9keSc6IGJvZGllcy5sZW5ndGgsXG4gICAgICAgICAgICAnQ29ucyc6IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCkubGVuZ3RoLFxuICAgICAgICAgICAgJ0NvbXAnOiBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyh3b3JsZCkubGVuZ3RoLFxuICAgICAgICAgICAgJ1BhaXInOiBlbmdpbmUucGFpcnMubGlzdC5sZW5ndGhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwZTBmMTknO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoICogNS41LCBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9ICcxMnB4IEFyaWFsJztcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuXG4gICAgICAgIC8vIHNlY3Rpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWN0aW9uc1trZXldO1xuICAgICAgICAgICAgLy8gbGFiZWxcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNhYWEnO1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChrZXksIHggKyB3aWR0aCwgeSArIDgpO1xuXG4gICAgICAgICAgICAvLyB2YWx1ZVxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2VlZSc7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHNlY3Rpb24sIHggKyB3aWR0aCwgeSArIDI2KTtcblxuICAgICAgICAgICAgeCArPSB3aWR0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGVuZ2luZSBhbmQgcmVuZGVyIHBlcmZvcm1hbmNlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBwZXJmb3JtYW5jZVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIucGVyZm9ybWFuY2UgPSBmdW5jdGlvbihyZW5kZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICB0aW1pbmcgPSByZW5kZXIudGltaW5nLFxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5ID0gdGltaW5nLmRlbHRhSGlzdG9yeSxcbiAgICAgICAgICAgIGVsYXBzZWRIaXN0b3J5ID0gdGltaW5nLmVsYXBzZWRIaXN0b3J5LFxuICAgICAgICAgICAgdGltZXN0YW1wRWxhcHNlZEhpc3RvcnkgPSB0aW1pbmcudGltZXN0YW1wRWxhcHNlZEhpc3RvcnksXG4gICAgICAgICAgICBlbmdpbmVEZWx0YUhpc3RvcnkgPSB0aW1pbmcuZW5naW5lRGVsdGFIaXN0b3J5LFxuICAgICAgICAgICAgZW5naW5lVXBkYXRlc0hpc3RvcnkgPSB0aW1pbmcuZW5naW5lVXBkYXRlc0hpc3RvcnksXG4gICAgICAgICAgICBlbmdpbmVFbGFwc2VkSGlzdG9yeSA9IHRpbWluZy5lbmdpbmVFbGFwc2VkSGlzdG9yeSxcbiAgICAgICAgICAgIGxhc3RFbmdpbmVVcGRhdGVzUGVyRnJhbWUgPSBlbmdpbmUudGltaW5nLmxhc3RVcGRhdGVzUGVyRnJhbWUsXG4gICAgICAgICAgICBsYXN0RW5naW5lRGVsdGEgPSBlbmdpbmUudGltaW5nLmxhc3REZWx0YTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkZWx0YU1lYW4gPSBfbWVhbihkZWx0YUhpc3RvcnkpLFxuICAgICAgICAgICAgZWxhcHNlZE1lYW4gPSBfbWVhbihlbGFwc2VkSGlzdG9yeSksXG4gICAgICAgICAgICBlbmdpbmVEZWx0YU1lYW4gPSBfbWVhbihlbmdpbmVEZWx0YUhpc3RvcnkpLFxuICAgICAgICAgICAgZW5naW5lVXBkYXRlc01lYW4gPSBfbWVhbihlbmdpbmVVcGRhdGVzSGlzdG9yeSksXG4gICAgICAgICAgICBlbmdpbmVFbGFwc2VkTWVhbiA9IF9tZWFuKGVuZ2luZUVsYXBzZWRIaXN0b3J5KSxcbiAgICAgICAgICAgIHRpbWVzdGFtcEVsYXBzZWRNZWFuID0gX21lYW4odGltZXN0YW1wRWxhcHNlZEhpc3RvcnkpLFxuICAgICAgICAgICAgcmF0ZU1lYW4gPSAodGltZXN0YW1wRWxhcHNlZE1lYW4gLyBkZWx0YU1lYW4pIHx8IDAsXG4gICAgICAgICAgICBuZWVkZWRVcGRhdGVzUGVyRnJhbWUgPSBNYXRoLnJvdW5kKGRlbHRhTWVhbiAvIGxhc3RFbmdpbmVEZWx0YSksXG4gICAgICAgICAgICBmcHMgPSAoMTAwMCAvIGRlbHRhTWVhbikgfHwgMDtcblxuICAgICAgICB2YXIgZ3JhcGhIZWlnaHQgPSA0LFxuICAgICAgICAgICAgZ2FwID0gMTIsXG4gICAgICAgICAgICB3aWR0aCA9IDYwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gMzQsXG4gICAgICAgICAgICB4ID0gMTAsXG4gICAgICAgICAgICB5ID0gNjk7XG5cbiAgICAgICAgLy8gYmFja2dyb3VuZFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMGUwZjE5JztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCA1MCwgZ2FwICogNSArIHdpZHRoICogNiArIDIyLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIHNob3cgRlBTXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgZ3JhcGhIZWlnaHQsIGRlbHRhSGlzdG9yeS5sZW5ndGgsIFxuICAgICAgICAgICAgTWF0aC5yb3VuZChmcHMpICsgJyBmcHMnLCBcbiAgICAgICAgICAgIGZwcyAvIFJlbmRlci5fZ29vZEZwcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIChkZWx0YUhpc3RvcnlbaV0gLyBkZWx0YU1lYW4pIC0gMTsgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgZW5naW5lIGRlbHRhXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4ICsgZ2FwICsgd2lkdGgsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgZW5naW5lRGVsdGFIaXN0b3J5Lmxlbmd0aCxcbiAgICAgICAgICAgIGxhc3RFbmdpbmVEZWx0YS50b0ZpeGVkKDIpICsgJyBkdCcsIFxuICAgICAgICAgICAgUmVuZGVyLl9nb29kRGVsdGEgLyBsYXN0RW5naW5lRGVsdGEsXG4gICAgICAgICAgICBmdW5jdGlvbihpKSB7IHJldHVybiAoZW5naW5lRGVsdGFIaXN0b3J5W2ldIC8gZW5naW5lRGVsdGFNZWFuKSAtIDE7IH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzaG93IGVuZ2luZSB1cGRhdGVzIHBlciBmcmFtZVxuICAgICAgICBSZW5kZXIuc3RhdHVzKFxuICAgICAgICAgICAgY29udGV4dCwgeCArIChnYXAgKyB3aWR0aCkgKiAyLCB5LCB3aWR0aCwgZ3JhcGhIZWlnaHQsIGVuZ2luZVVwZGF0ZXNIaXN0b3J5Lmxlbmd0aCxcbiAgICAgICAgICAgIGxhc3RFbmdpbmVVcGRhdGVzUGVyRnJhbWUgKyAnIHVwZicsIFxuICAgICAgICAgICAgTWF0aC5wb3coQ29tbW9uLmNsYW1wKChlbmdpbmVVcGRhdGVzTWVhbiAvIG5lZWRlZFVwZGF0ZXNQZXJGcmFtZSkgfHwgMSwgMCwgMSksIDQpLFxuICAgICAgICAgICAgZnVuY3Rpb24oaSkgeyByZXR1cm4gKGVuZ2luZVVwZGF0ZXNIaXN0b3J5W2ldIC8gZW5naW5lVXBkYXRlc01lYW4pIC0gMTsgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgZW5naW5lIHVwZGF0ZSB0aW1lXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4ICsgKGdhcCArIHdpZHRoKSAqIDMsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgZW5naW5lRWxhcHNlZEhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgZW5naW5lRWxhcHNlZE1lYW4udG9GaXhlZCgyKSArICcgdXQnLCBcbiAgICAgICAgICAgIDEgLSAobGFzdEVuZ2luZVVwZGF0ZXNQZXJGcmFtZSAqIGVuZ2luZUVsYXBzZWRNZWFuIC8gUmVuZGVyLl9nb29kRnBzKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIChlbmdpbmVFbGFwc2VkSGlzdG9yeVtpXSAvIGVuZ2luZUVsYXBzZWRNZWFuKSAtIDE7IH1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzaG93IHJlbmRlciB0aW1lXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4ICsgKGdhcCArIHdpZHRoKSAqIDQsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgZWxhcHNlZEhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgZWxhcHNlZE1lYW4udG9GaXhlZCgyKSArICcgcnQnLCBcbiAgICAgICAgICAgIDEgLSAoZWxhcHNlZE1lYW4gLyBSZW5kZXIuX2dvb2RGcHMpLFxuICAgICAgICAgICAgZnVuY3Rpb24oaSkgeyByZXR1cm4gKGVsYXBzZWRIaXN0b3J5W2ldIC8gZWxhcHNlZE1lYW4pIC0gMTsgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgZWZmZWN0aXZlIHNwZWVkXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4ICsgKGdhcCArIHdpZHRoKSAqIDUsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgdGltZXN0YW1wRWxhcHNlZEhpc3RvcnkubGVuZ3RoLCBcbiAgICAgICAgICAgIHJhdGVNZWFuLnRvRml4ZWQoMikgKyAnIHgnLCBcbiAgICAgICAgICAgIHJhdGVNZWFuICogcmF0ZU1lYW4gKiByYXRlTWVhbixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuICgoKHRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5W2ldIC8gZGVsdGFIaXN0b3J5W2ldKSAvIHJhdGVNZWFuKSB8fCAwKSAtIDE7IH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGxhYmVsLCBpbmRpY2F0b3IgYW5kIGEgY2hhcnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHN0YXR1c1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGljYXRvclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHBsb3RZXG4gICAgICovXG4gICAgUmVuZGVyLnN0YXR1cyA9IGZ1bmN0aW9uKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvdW50LCBsYWJlbCwgaW5kaWNhdG9yLCBwbG90WSkge1xuICAgICAgICAvLyBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIzg4OCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyM0NDQnO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSArIDcsIHdpZHRoLCAxKTtcblxuICAgICAgICAvLyBjaGFydFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgNyAtIGhlaWdodCAqIENvbW1vbi5jbGFtcCgwLjQgKiBwbG90WSgwKSwgLTIsIDIpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgaSwgeSArIDcgLSAoaSA8IGNvdW50ID8gaGVpZ2h0ICogQ29tbW9uLmNsYW1wKDAuNCAqIHBsb3RZKGkpLCAtMiwgMikgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICAvLyBpbmRpY2F0b3JcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnaHNsKCcgKyBDb21tb24uY2xhbXAoMjUgKyA5NSAqIGluZGljYXRvciwgMCwgMTIwKSArICcsMTAwJSw2MCUpJztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5IC0gNywgNCwgNCk7XG5cbiAgICAgICAgLy8gbGFiZWxcbiAgICAgICAgY29udGV4dC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNlZWUnO1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCB4ICsgd2lkdGgsIHkgLSA1KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgY29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge2NvbnN0cmFpbnRbXX0gY29uc3RyYWludHNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuY29uc3RyYWludHMgPSBmdW5jdGlvbihjb25zdHJhaW50cywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKCFjb25zdHJhaW50LnJlbmRlci52aXNpYmxlIHx8ICFjb25zdHJhaW50LnBvaW50QSB8fCAhY29uc3RyYWludC5wb2ludEIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICAgICAgYm9keUIgPSBjb25zdHJhaW50LmJvZHlCLFxuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDtcblxuICAgICAgICAgICAgaWYgKGJvZHlBKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gY29uc3RyYWludC5wb2ludEE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnJlbmRlci50eXBlID09PSAncGluJykge1xuICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgYy5hcmMoc3RhcnQueCwgc3RhcnQueSwgMywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChib2R5Qikge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50Qik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gY29uc3RyYWludC5wb2ludEI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcblxuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnJlbmRlci50eXBlID09PSAnc3ByaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBWZWN0b3Iuc3ViKGVuZCwgc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLnBlcnAoVmVjdG9yLm5vcm1hbGlzZShkZWx0YSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29pbHMgPSBNYXRoLmNlaWwoQ29tbW9uLmNsYW1wKGNvbnN0cmFpbnQubGVuZ3RoIC8gNSwgMTIsIDIwKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBjb2lsczsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBqICUgMiA9PT0gMCA/IDEgOiAtMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQueCArIGRlbHRhLnggKiAoaiAvIGNvaWxzKSArIG5vcm1hbC54ICogb2Zmc2V0ICogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC55ICsgZGVsdGEueSAqIChqIC8gY29pbHMpICsgbm9ybWFsLnkgKiBvZmZzZXQgKiA0XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmVuZGVyLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGMubGluZVdpZHRoID0gY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSBjb25zdHJhaW50LnJlbmRlci5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICBjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yZW5kZXIuYW5jaG9ycykge1xuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gY29uc3RyYWludC5yZW5kZXIuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjLmFyYyhzdGFydC54LCBzdGFydC55LCAzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYy5hcmMoZW5kLngsIGVuZC55LCAzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjLmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2RpZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgc2hvd0ludGVybmFsRWRnZXMgPSBvcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzIHx8ICFvcHRpb25zLndpcmVmcmFtZXMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBmb3IgKGsgPSBib2R5LnBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IGJvZHkucGFydHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gYm9keS5wYXJ0c1trXTtcblxuICAgICAgICAgICAgICAgIGlmICghcGFydC5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93U2xlZXBpbmcgJiYgYm9keS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAwLjUgKiBwYXJ0LnJlbmRlci5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC5yZW5kZXIub3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjLmdsb2JhbEFscGhhID0gcGFydC5yZW5kZXIub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFydC5yZW5kZXIuc3ByaXRlICYmIHBhcnQucmVuZGVyLnNwcml0ZS50ZXh0dXJlICYmICFvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBzcHJpdGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHBhcnQucmVuZGVyLnNwcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUgPSBfZ2V0VGV4dHVyZShyZW5kZXIsIHNwcml0ZS50ZXh0dXJlKTtcblxuICAgICAgICAgICAgICAgICAgICBjLnRyYW5zbGF0ZShwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgICAgIGMucm90YXRlKHBhcnQuYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGMuZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUud2lkdGggKiAtc3ByaXRlLnhPZmZzZXQgKiBzcHJpdGUueFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5oZWlnaHQgKiAtc3ByaXRlLnlPZmZzZXQgKiBzcHJpdGUueVNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53aWR0aCAqIHNwcml0ZS54U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCAqIHNwcml0ZS55U2NhbGVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlcnQgdHJhbnNsYXRpb24sIGhvcGVmdWxseSBmYXN0ZXIgdGhhbiBzYXZlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICBjLnJvdGF0ZSgtcGFydC5hbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKC1wYXJ0LnBvc2l0aW9uLngsIC1wYXJ0LnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnQgcG9seWdvblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaXJjbGVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmFyYyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSwgcGFydC5jaXJjbGVSYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydC52ZXJ0aWNlc1tqIC0gMV0uaXNJbnRlcm5hbCB8fCBzaG93SW50ZXJuYWxFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhwYXJ0LnZlcnRpY2VzW2pdLngsIHBhcnQudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1tqXS54LCBwYXJ0LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS54LCBwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gcGFydC5yZW5kZXIuZmlsbFN0eWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5yZW5kZXIubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSBwYXJ0LnJlbmRlci5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IHBhcnQucmVuZGVyLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IHJlbmRlci5vcHRpb25zLndpcmVmcmFtZVN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlXaXJlZnJhbWVzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVdpcmVmcmFtZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IHJlbmRlci5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgYWxsIGJvZGllc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgZm9yIChrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XG5cbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueCwgcGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gcmVuZGVyLm9wdGlvbnMud2lyZWZyYW1lU3Ryb2tlU3R5bGU7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSBjb252ZXggaHVsbCB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlDb252ZXhIdWxsc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlDb252ZXhIdWxscyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGNvbnZleCBodWxsc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUgfHwgYm9keS5wYXJ0cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHkudmVydGljZXNbMF0ueCwgYm9keS52ZXJ0aWNlc1swXS55KTtcblxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IGJvZHkudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzW2pdLngsIGJvZHkudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGMubGluZVRvKGJvZHkudmVydGljZXNbMF0ueCwgYm9keS52ZXJ0aWNlc1swXS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMiknO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJvZHkgdmVydGV4IG51bWJlcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHZlcnRleE51bWJlcnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci52ZXJ0ZXhOdW1iZXJzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcbiAgICAgICAgICAgIGZvciAoayA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgayA8IHBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1trXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMiknO1xuICAgICAgICAgICAgICAgICAgICBjLmZpbGxUZXh0KGkgKyAnXycgKyBqLCBwYXJ0LnBvc2l0aW9uLnggKyAocGFydC52ZXJ0aWNlc1tqXS54IC0gcGFydC5wb3NpdGlvbi54KSAqIDAuOCwgcGFydC5wb3NpdGlvbi55ICsgKHBhcnQudmVydGljZXNbal0ueSAtIHBhcnQucG9zaXRpb24ueSkgKiAwLjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIG1vdXNlIHBvc2l0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBtb3VzZVBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLm1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihyZW5kZXIsIG1vdXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dDtcbiAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjgpJztcbiAgICAgICAgYy5maWxsVGV4dChtb3VzZS5wb3NpdGlvbi54ICsgJyAgJyArIG1vdXNlLnBvc2l0aW9uLnksIG1vdXNlLnBvc2l0aW9uLnggKyA1LCBtb3VzZS5wb3NpdGlvbi55IC0gNSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlCb3VuZHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5Qm91bmRzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucztcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkucmVuZGVyLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBib2RpZXNbaV0ucGFydHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbal07XG4gICAgICAgICAgICAgICAgICAgIGMucmVjdChwYXJ0LmJvdW5kcy5taW4ueCwgcGFydC5ib3VuZHMubWluLnksIHBhcnQuYm91bmRzLm1heC54IC0gcGFydC5ib3VuZHMubWluLngsIHBhcnQuYm91bmRzLm1heC55IC0gcGFydC5ib3VuZHMubWluLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjA4KSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgYW5nbGUgaW5kaWNhdG9ycyBhbmQgYXhlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5QXhlc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlBeGVzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGJvZHkucGFydHM7XG5cbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0F4ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgYWxsIGF4ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbal07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBwYXJ0LmF4ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGlzID0gcGFydC5heGVzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC5wb3NpdGlvbi54ICsgYXhpcy54ICogMjAsIHBhcnQucG9zaXRpb24ueSArIGF4aXMueSAqIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydC5heGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgYSBzaW5nbGUgYXhpcyBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKChwYXJ0LnZlcnRpY2VzWzBdLnggKyBwYXJ0LnZlcnRpY2VzW3BhcnQudmVydGljZXMubGVuZ3RoLTFdLngpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFydC52ZXJ0aWNlc1swXS55ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS55KSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdpbmRpYW5yZWQnO1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNCknO1xuICAgICAgICAgICAgYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnb3ZlcmxheSc7XG4gICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBjLnN0cm9rZSgpO1xuICAgICAgICBjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlQb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5UG9zaXRpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XG4gICAgICAgICAgICAgICAgYy5hcmMocGFydC5wb3NpdGlvbi54LCBwYXJ0LnBvc2l0aW9uLnksIDMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ2luZGlhbnJlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNSknO1xuICAgICAgICB9XG4gICAgICAgIGMuZmlsbCgpO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIHByZXZpb3VzIHBvc2l0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkucmVuZGVyLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjLmFyYyhib2R5LnBvc2l0aW9uUHJldi54LCBib2R5LnBvc2l0aW9uUHJldi55LCAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjgpJztcbiAgICAgICAgYy5maWxsKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgdmVsb2NpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keVZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVZlbG9jaXR5ID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0O1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IEJvZHkuZ2V0VmVsb2NpdHkoYm9keSk7XG5cbiAgICAgICAgICAgIGMubW92ZVRvKGJvZHkucG9zaXRpb24ueCwgYm9keS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHkucG9zaXRpb24ueCArIHZlbG9jaXR5LngsIGJvZHkucG9zaXRpb24ueSArIHZlbG9jaXR5LnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAzO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ2Nvcm5mbG93ZXJibHVlJztcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9keSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keUlkc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlJZHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJvZGllc1tpXS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xuICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgIGMuZm9udCA9IFwiMTJweCBBcmlhbFwiO1xuICAgICAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC41KSc7XG4gICAgICAgICAgICAgICAgYy5maWxsVGV4dChwYXJ0LmlkLCBwYXJ0LnBvc2l0aW9uLnggKyAxMCwgcGFydC5wb3NpdGlvbi55IC0gMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGNvbGxpc2lvbnNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmNvbGxpc2lvbnMgPSBmdW5jdGlvbihyZW5kZXIsIHBhaXJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb2xsaXNpb24sXG4gICAgICAgICAgICBjb3JyZWN0ZWQsXG4gICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgY29sbGlzaW9uIHBvc2l0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYWlyLmNvbnRhY3RDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSBwYWlyLmNvbnRhY3RzW2pdLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBjb250YWN0LnZlcnRleDtcbiAgICAgICAgICAgICAgICBjLnJlY3QodmVydGV4LnggLSAxLjUsIHZlcnRleC55IC0gMS41LCAzLjUsIDMuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnb3JhbmdlJztcbiAgICAgICAgfVxuICAgICAgICBjLmZpbGwoKTtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBjb2xsaXNpb24gbm9ybWFsc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcblxuICAgICAgICAgICAgaWYgKHBhaXIuY29udGFjdENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxQb3NYID0gcGFpci5jb250YWN0c1swXS52ZXJ0ZXgueCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWSA9IHBhaXIuY29udGFjdHNbMF0udmVydGV4Lnk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFpci5jb250YWN0Q291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWCA9IChwYWlyLmNvbnRhY3RzWzBdLnZlcnRleC54ICsgcGFpci5jb250YWN0c1sxXS52ZXJ0ZXgueCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxQb3NZID0gKHBhaXIuY29udGFjdHNbMF0udmVydGV4LnkgKyBwYWlyLmNvbnRhY3RzWzFdLnZlcnRleC55KSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbi5ib2R5QiA9PT0gY29sbGlzaW9uLnN1cHBvcnRzWzBdLmJvZHkgfHwgY29sbGlzaW9uLmJvZHlBLmlzU3RhdGljID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKG5vcm1hbFBvc1ggLSBjb2xsaXNpb24ubm9ybWFsLnggKiA4LCBub3JtYWxQb3NZIC0gY29sbGlzaW9uLm5vcm1hbC55ICogOCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8obm9ybWFsUG9zWCArIGNvbGxpc2lvbi5ub3JtYWwueCAqIDgsIG5vcm1hbFBvc1kgKyBjb2xsaXNpb24ubm9ybWFsLnkgKiA4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhub3JtYWxQb3NYLCBub3JtYWxQb3NZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC43KSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHNlcGFyYXRpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5zZXBhcmF0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgcGFpcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGNvbGxpc2lvbixcbiAgICAgICAgICAgIGNvcnJlY3RlZCxcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBzZXBhcmF0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUI7XG5cbiAgICAgICAgICAgIHZhciBrID0gMTtcblxuICAgICAgICAgICAgaWYgKCFib2R5Qi5pc1N0YXRpYyAmJiAhYm9keUEuaXNTdGF0aWMpIGsgPSAwLjU7XG4gICAgICAgICAgICBpZiAoYm9keUIuaXNTdGF0aWMpIGsgPSAwO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5Qi5wb3NpdGlvbi54LCBib2R5Qi5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlCLnBvc2l0aW9uLnggLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlCLnBvc2l0aW9uLnkgLSBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xuXG4gICAgICAgICAgICBrID0gMTtcblxuICAgICAgICAgICAgaWYgKCFib2R5Qi5pc1N0YXRpYyAmJiAhYm9keUEuaXNTdGF0aWMpIGsgPSAwLjU7XG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMpIGsgPSAwO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5QS5wb3NpdGlvbi54LCBib2R5QS5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgIGMubGluZVRvKGJvZHlBLnBvc2l0aW9uLnggKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCAqIGssIGJvZHlBLnBvc2l0aW9uLnkgKyBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSAqIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjUpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnb3JhbmdlJztcbiAgICAgICAgfVxuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBpbnNwZWN0b3JcbiAgICAgKiBAcGFyYW0ge2luc3BlY3Rvcn0gaW5zcGVjdG9yXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmluc3BlY3RvciA9IGZ1bmN0aW9uKGluc3BlY3RvciwgY29udGV4dCkge1xuICAgICAgICB2YXIgZW5naW5lID0gaW5zcGVjdG9yLmVuZ2luZSxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gaW5zcGVjdG9yLnNlbGVjdGVkLFxuICAgICAgICAgICAgcmVuZGVyID0gaW5zcGVjdG9yLnJlbmRlcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGJvdW5kcztcblxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHNXaWR0aCA9IHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54LFxuICAgICAgICAgICAgICAgIGJvdW5kc0hlaWdodCA9IHJlbmRlci5ib3VuZHMubWF4LnkgLSByZW5kZXIuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgYm91bmRzU2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBib3VuZHNTY2FsZVgsIDEgLyBib3VuZHNTY2FsZVkpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLXJlbmRlci5ib3VuZHMubWluLngsIC1yZW5kZXIuYm91bmRzLm1pbi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gc2VsZWN0ZWRbaV0uZGF0YTtcblxuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjkpJztcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsMl0pO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdib2R5JzpcblxuICAgICAgICAgICAgICAgIC8vIHJlbmRlciBib2R5IHNlbGVjdGlvbnNcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBpdGVtLmJvdW5kcztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChNYXRoLmZsb29yKGJvdW5kcy5taW4ueCAtIDMpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSAtIDMpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCArIDYpLCBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSArIDYpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XG5cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgY29uc3RyYWludCBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gaXRlbS5wb2ludEE7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYm9keUEpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gaXRlbS5wb2ludEI7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhwb2ludC54LCBwb2ludC55LCAxMCwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTAuNSwgLTAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXIgc2VsZWN0aW9uIHJlZ2lvblxuICAgICAgICBpZiAoaW5zcGVjdG9yLnNlbGVjdFN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLjUsIDAuNSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNiknO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC4xKSc7XG4gICAgICAgICAgICBib3VuZHMgPSBpbnNwZWN0b3Iuc2VsZWN0Qm91bmRzO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVjdChNYXRoLmZsb29yKGJvdW5kcy5taW4ueCksIE1hdGguZmxvb3IoYm91bmRzLm1pbi55KSxcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCksIE1hdGguZmxvb3IoYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTAuNSwgLTAuNSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpXG4gICAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyByZW5kZXIgdGltaW5nLlxuICAgICAqIEBtZXRob2QgX3VwZGF0ZVRpbWluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gICAgICovXG4gICAgdmFyIF91cGRhdGVUaW1pbmcgPSBmdW5jdGlvbihyZW5kZXIsIHRpbWUpIHtcbiAgICAgICAgdmFyIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICB0aW1pbmcgPSByZW5kZXIudGltaW5nLFxuICAgICAgICAgICAgaGlzdG9yeVNpemUgPSB0aW1pbmcuaGlzdG9yeVNpemUsXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcDtcblxuICAgICAgICB0aW1pbmcuZGVsdGEgPSB0aW1lIC0gdGltaW5nLmxhc3RUaW1lIHx8IFJlbmRlci5fZ29vZERlbHRhO1xuICAgICAgICB0aW1pbmcubGFzdFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIHRpbWluZy50aW1lc3RhbXBFbGFwc2VkID0gdGltZXN0YW1wIC0gdGltaW5nLmxhc3RUaW1lc3RhbXAgfHwgMDtcbiAgICAgICAgdGltaW5nLmxhc3RUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgdGltaW5nLmRlbHRhSGlzdG9yeS51bnNoaWZ0KHRpbWluZy5kZWx0YSk7XG4gICAgICAgIHRpbWluZy5kZWx0YUhpc3RvcnkubGVuZ3RoID0gTWF0aC5taW4odGltaW5nLmRlbHRhSGlzdG9yeS5sZW5ndGgsIGhpc3RvcnlTaXplKTtcblxuICAgICAgICB0aW1pbmcuZW5naW5lRGVsdGFIaXN0b3J5LnVuc2hpZnQoZW5naW5lLnRpbWluZy5sYXN0RGVsdGEpO1xuICAgICAgICB0aW1pbmcuZW5naW5lRGVsdGFIaXN0b3J5Lmxlbmd0aCA9IE1hdGgubWluKHRpbWluZy5lbmdpbmVEZWx0YUhpc3RvcnkubGVuZ3RoLCBoaXN0b3J5U2l6ZSk7XG5cbiAgICAgICAgdGltaW5nLnRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5LnVuc2hpZnQodGltaW5nLnRpbWVzdGFtcEVsYXBzZWQpO1xuICAgICAgICB0aW1pbmcudGltZXN0YW1wRWxhcHNlZEhpc3RvcnkubGVuZ3RoID0gTWF0aC5taW4odGltaW5nLnRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5Lmxlbmd0aCwgaGlzdG9yeVNpemUpO1xuXG4gICAgICAgIHRpbWluZy5lbmdpbmVVcGRhdGVzSGlzdG9yeS51bnNoaWZ0KGVuZ2luZS50aW1pbmcubGFzdFVwZGF0ZXNQZXJGcmFtZSk7XG4gICAgICAgIHRpbWluZy5lbmdpbmVVcGRhdGVzSGlzdG9yeS5sZW5ndGggPSBNYXRoLm1pbih0aW1pbmcuZW5naW5lVXBkYXRlc0hpc3RvcnkubGVuZ3RoLCBoaXN0b3J5U2l6ZSk7XG5cbiAgICAgICAgdGltaW5nLmVuZ2luZUVsYXBzZWRIaXN0b3J5LnVuc2hpZnQoZW5naW5lLnRpbWluZy5sYXN0RWxhcHNlZCk7XG4gICAgICAgIHRpbWluZy5lbmdpbmVFbGFwc2VkSGlzdG9yeS5sZW5ndGggPSBNYXRoLm1pbih0aW1pbmcuZW5naW5lRWxhcHNlZEhpc3RvcnkubGVuZ3RoLCBoaXN0b3J5U2l6ZSk7XG5cbiAgICAgICAgdGltaW5nLmVsYXBzZWRIaXN0b3J5LnVuc2hpZnQodGltaW5nLmxhc3RFbGFwc2VkKTtcbiAgICAgICAgdGltaW5nLmVsYXBzZWRIaXN0b3J5Lmxlbmd0aCA9IE1hdGgubWluKHRpbWluZy5lbGFwc2VkSGlzdG9yeS5sZW5ndGgsIGhpc3RvcnlTaXplKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWVhbiB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbnVtYmVycy5cbiAgICAgKiBAbWV0aG9kIF9tZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBtZWFuIG9mIGdpdmVuIHZhbHVlc1xuICAgICAqL1xuICAgIHZhciBfbWVhbiA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZXN1bHQgLyB2YWx1ZXMubGVuZ3RoKSB8fCAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVDYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSB3aWR0aFxuICAgICAqIEBwYXJhbSB7fSBoZWlnaHRcbiAgICAgKiBAcmV0dXJuIGNhbnZhc1xuICAgICAqL1xuICAgIHZhciBfY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjYW52YXMub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIGNhbnZhcy5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBAbWV0aG9kIF9nZXRQaXhlbFJhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXG4gICAgICovXG4gICAgdmFyIF9nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gPSBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVQaXhlbFJhdGlvO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZXF1ZXN0ZWQgdGV4dHVyZSAoYW4gSW1hZ2UpIHZpYSBpdHMgcGF0aFxuICAgICAqIEBtZXRob2QgX2dldFRleHR1cmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VQYXRoXG4gICAgICogQHJldHVybiB7SW1hZ2V9IHRleHR1cmVcbiAgICAgKi9cbiAgICB2YXIgX2dldFRleHR1cmUgPSBmdW5jdGlvbihyZW5kZXIsIGltYWdlUGF0aCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXTtcblxuICAgICAgICBpZiAoaW1hZ2UpXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XG5cbiAgICAgICAgaW1hZ2UgPSByZW5kZXIudGV4dHVyZXNbaW1hZ2VQYXRoXSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVBhdGg7XG5cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBiYWNrZ3JvdW5kIHRvIHRoZSBjYW52YXMgdXNpbmcgQ1NTLlxuICAgICAqIEBtZXRob2QgYXBwbHlCYWNrZ3JvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRcbiAgICAgKi9cbiAgICB2YXIgX2FwcGx5QmFja2dyb3VuZCA9IGZ1bmN0aW9uKHJlbmRlciwgYmFja2dyb3VuZCkge1xuICAgICAgICB2YXIgY3NzQmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgICAgICAgaWYgKC8oanBnfGdpZnxwbmcpJC8udGVzdChiYWNrZ3JvdW5kKSlcbiAgICAgICAgICAgIGNzc0JhY2tncm91bmQgPSAndXJsKCcgKyBiYWNrZ3JvdW5kICsgJyknO1xuXG4gICAgICAgIHJlbmRlci5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IGNzc0JhY2tncm91bmQ7XG4gICAgICAgIHJlbmRlci5jYW52YXMuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBcImNvbnRhaW5cIjtcbiAgICAgICAgcmVuZGVyLmN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYmVmb3JlIHJlbmRlcmluZ1xuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVSZW5kZXJcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIHJlbmRlcmluZ1xuICAgICpcbiAgICAqIEBldmVudCBhZnRlclJlbmRlclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBiYWNrLXJlZmVyZW5jZSB0byB0aGUgYE1hdHRlci5SZW5kZXJgIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHByb3BlcnR5IGNvbnRyb2xsZXJcbiAgICAgKiBAdHlwZSByZW5kZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgTWF0dGVyLkVuZ2luZWAgaW5zdGFuY2UgdG8gYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmdpbmVcbiAgICAgKiBAdHlwZSBlbmdpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IHdoZXJlIHRoZSBjYW52YXMgaXMgdG8gYmUgaW5zZXJ0ZWQgKGlmIGByZW5kZXIuY2FudmFzYCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVsZW1lbnRcbiAgICAgKiBAdHlwZSBIVE1MRWxlbWVudFxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBjYW52YXMgZWxlbWVudCB0byByZW5kZXIgdG8uIElmIG5vdCBzcGVjaWZpZWQsIG9uZSB3aWxsIGJlIGNyZWF0ZWQgaWYgYHJlbmRlci5lbGVtZW50YCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY2FudmFzXG4gICAgICogQHR5cGUgSFRNTENhbnZhc0VsZW1lbnRcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgZHJhd2luZyB2aWV3IHJlZ2lvbi5cbiAgICAgKiBSZW5kZXJpbmcgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybWVkIGFuZCBzY2FsZWQgdG8gZml0IHdpdGhpbiB0aGUgY2FudmFzIHNpemUgKGByZW5kZXIub3B0aW9ucy53aWR0aGAgYW5kIGByZW5kZXIub3B0aW9ucy5oZWlnaHRgKS5cbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgY3JlYXRpbmcgdmlld3MgdGhhdCBjYW4gcGFuIG9yIHpvb20gYXJvdW5kIHRoZSBzY2VuZS5cbiAgICAgKiBZb3UgbXVzdCBhbHNvIHNldCBgcmVuZGVyLm9wdGlvbnMuaGFzQm91bmRzYCB0byBgdHJ1ZWAgdG8gZW5hYmxlIGJvdW5kZWQgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJvdW5kc1xuICAgICAqIEB0eXBlIGJvdW5kc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIDJkIHJlbmRlcmluZyBjb250ZXh0IGZyb20gdGhlIGByZW5kZXIuY2FudmFzYCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbnRleHRcbiAgICAgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzcHJpdGUgdGV4dHVyZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0ZXh0dXJlc1xuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW91c2UgdG8gcmVuZGVyIGlmIGByZW5kZXIub3B0aW9ucy5zaG93TW91c2VQb3NpdGlvbmAgaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZVxuICAgICAqIEB0eXBlIG1vdXNlXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IHdpZHRoIGluIHBpeGVscyBvZiB0aGUgYHJlbmRlci5jYW52YXNgIHRvIGJlIGNyZWF0ZWQuXG4gICAgICogU2VlIGFsc28gdGhlIGBvcHRpb25zLnBpeGVsUmF0aW9gIHByb3BlcnR5IHRvIGNoYW5nZSByZW5kZXIgcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLndpZHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgODAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IGhlaWdodCBpbiBwaXhlbHMgb2YgdGhlIGByZW5kZXIuY2FudmFzYCB0byBiZSBjcmVhdGVkLlxuICAgICAqIFNlZSBhbHNvIHRoZSBgb3B0aW9ucy5waXhlbFJhdGlvYCBwcm9wZXJ0eSB0byBjaGFuZ2UgcmVuZGVyIHF1YWxpdHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5oZWlnaHRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA2MDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBbcGl4ZWwgcmF0aW9dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvZGV2aWNlUGl4ZWxSYXRpbykgdG8gdXNlIHdoZW4gcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMucGl4ZWxSYXRpb1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgQ1NTIGJhY2tncm91bmQgY29sb3Igc3RyaW5nIHRvIHVzZSB3aGVuIGByZW5kZXIub3B0aW9ucy53aXJlZnJhbWVzYCBpcyBkaXNhYmxlZC5cbiAgICAgKiBUaGlzIG1heSBiZSBhbHNvIHNldCB0byBgJ3RyYW5zcGFyZW50J2Agb3IgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLmJhY2tncm91bmRcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnIzE0MTUxZidcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgQ1NTIGNvbG9yIHN0cmluZyB0byB1c2UgZm9yIGJhY2tncm91bmQgd2hlbiBgcmVuZGVyLm9wdGlvbnMud2lyZWZyYW1lc2AgaXMgZW5hYmxlZC5cbiAgICAgKiBUaGlzIG1heSBiZSBhbHNvIHNldCB0byBgJ3RyYW5zcGFyZW50J2Agb3IgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLndpcmVmcmFtZUJhY2tncm91bmRcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnIzE0MTUxZidcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgQ1NTIGNvbG9yIHN0cmluZyB0byB1c2UgZm9yIHN0cm9rZSB3aGVuIGByZW5kZXIub3B0aW9ucy53aXJlZnJhbWVzYCBpcyBlbmFibGVkLlxuICAgICAqIFRoaXMgbWF5IGJlIGFsc28gc2V0IHRvIGAndHJhbnNwYXJlbnQnYCBvciBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMud2lyZWZyYW1lU3Ryb2tlU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAnI2JiYidcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyBpZiBgcmVuZGVyLmJvdW5kc2Agc2hvdWxkIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5oYXNCb3VuZHNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSBhbGwgZGVidWcgaW5mb3JtYXRpb24gb3ZlcmxheXMgdG9nZXRoZXIuICBcbiAgICAgKiBUaGlzIGluY2x1ZGVzIGFuZCBoYXMgcHJpb3JpdHkgb3ZlciB0aGUgdmFsdWVzIG9mOlxuICAgICAqXG4gICAgICogLSBgcmVuZGVyLm9wdGlvbnMuc2hvd1N0YXRzYFxuICAgICAqIC0gYHJlbmRlci5vcHRpb25zLnNob3dQZXJmb3JtYW5jZWBcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dEZWJ1Z1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBlbmdpbmUgc3RhdHMgaW5mbyBvdmVybGF5LiAgXG4gICAgICogRnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGUgdmFsdWVzIHNob3duIGFyZTpcbiAgICAgKlxuICAgICAqIC0gYm9keSBwYXJ0cyB0b3RhbFxuICAgICAqIC0gYm9keSB0b3RhbFxuICAgICAqIC0gY29uc3RyYWludHMgdG90YWxcbiAgICAgKiAtIGNvbXBvc2l0ZXMgdG90YWxcbiAgICAgKiAtIGNvbGxpc2lvbiBwYWlycyB0b3RhbFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1N0YXRzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgcGVyZm9ybWFuY2UgY2hhcnRzLiAgXG4gICAgICogRnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGUgdmFsdWVzIHNob3duIGFyZTpcbiAgICAgKlxuICAgICAqIC0gYXZlcmFnZSByZW5kZXIgZnJlcXVlbmN5IChlLmcuIDYwIGZwcylcbiAgICAgKiAtIGV4YWN0IGVuZ2luZSBkZWx0YSB0aW1lIHVzZWQgZm9yIGxhc3QgdXBkYXRlIChlLmcuIDE2LjY2bXMpXG4gICAgICogLSBhdmVyYWdlIHVwZGF0ZXMgcGVyIGZyYW1lIChlLmcuIDEpXG4gICAgICogLSBhdmVyYWdlIGVuZ2luZSBleGVjdXRpb24gZHVyYXRpb24gKGUuZy4gNS4wMG1zKVxuICAgICAqIC0gYXZlcmFnZSByZW5kZXIgZXhlY3V0aW9uIGR1cmF0aW9uIChlLmcuIDAuNDBtcylcbiAgICAgKiAtIGF2ZXJhZ2UgZWZmZWN0aXZlIHBsYXkgc3BlZWQgKGUuZy4gJzEuMDB4JyBpcyAncmVhbC10aW1lJylcbiAgICAgKlxuICAgICAqIEVhY2ggdmFsdWUgaXMgcmVjb3JkZWQgb3ZlciBhIGZpeGVkIHNhbXBsZSBvZiBwYXN0IGZyYW1lcyAoNjAgZnJhbWVzKS5cbiAgICAgKlxuICAgICAqIEEgY2hhcnQgc2hvd24gYmVsb3cgZWFjaCB2YWx1ZSBpbmRpY2F0ZXMgdGhlIHZhcmlhbmNlIGZyb20gdGhlIGF2ZXJhZ2Ugb3ZlciB0aGUgc2FtcGxlLlxuICAgICAqIFRoZSBtb3JlIHN0YWJsZSBvciBmaXhlZCB0aGUgdmFsdWUgaXMgdGhlIGZsYXR0ZXIgdGhlIGNoYXJ0IHdpbGwgYXBwZWFyLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1BlcmZvcm1hbmNlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHJlbmRlcmluZyBlbnRpcmVseS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLmVuYWJsZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byB0b2dnbGUgd2lyZWZyYW1lIHJlbmRlcmluZyBvdGhlcndpc2Ugc29saWQgZmlsbCByZW5kZXJpbmcgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLndpcmVmcmFtZXNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHNsZWVwaW5nIGJvZGllcyBpbmRpY2F0b3JzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1NsZWVwaW5nXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZGVidWcgaW5mb3JtYXRpb24gb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dEZWJ1Z1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBjb2xsaXNpb24gYnJvYWRwaGFzZSBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgbm8gbG9uZ2VyIGltcGxlbWVudGVkXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd0Jyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBib3VuZHMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dCb3VuZHNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSB2ZWxvY2l0eSBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1ZlbG9jaXR5XG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgY29sbGlzaW9ucyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd0NvbGxpc2lvbnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgY29sbGlzaW9uIHJlc29sdmVyIHNlcGFyYXRpb25zIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93U2VwYXJhdGlvbnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBheGVzIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93QXhlc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBib2R5IHBvc2l0aW9ucyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1Bvc2l0aW9uc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBib2R5IGFuZ2xlIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93QW5nbGVJbmRpY2F0b3JcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBhbmQgcGFydCBpZHMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dJZHNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSB2ZXJ0ZXggbnVtYmVycyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1ZlcnRleE51bWJlcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBjb252ZXggaHVsbHMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dDb252ZXhIdWxsc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBib2R5IGludGVybmFsIGVkZ2VzIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93SW50ZXJuYWxFZGdlc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBtb3VzZSBwb3NpdGlvbiBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd01vdXNlUG9zaXRpb25cbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5SdW5uZXJgIG1vZHVsZSBpcyBhbiBvcHRpb25hbCB1dGlsaXR5IHRoYXQgcHJvdmlkZXMgYSBnYW1lIGxvb3AgZm9yIHJ1bm5pbmcgYSBgTWF0dGVyLkVuZ2luZWAgaW5zaWRlIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cbiogQSBydW5uZXIgd2lsbCBjb250aW51b3VzbHkgdXBkYXRlIGEgYE1hdHRlci5FbmdpbmVgIHdoaWxzdCBzeW5jaHJvbmlzaW5nIGVuZ2luZSB1cGRhdGVzIHdpdGggdGhlIGJyb3dzZXIgZnJhbWUgcmF0ZS5cbiogVGhpcyBydW5uZXIgZmF2b3VycyBhIHNtb290aGVyIHVzZXIgZXhwZXJpZW5jZSBvdmVyIHBlcmZlY3QgdGltZSBrZWVwaW5nLlxuKiBUaGlzIHJ1bm5lciBpcyBvcHRpb25hbCBhbmQgaXMgdXNlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBidXQgY291bGQgYmUgdXNlZnVsIGFzIGEgc3RhcnRpbmcgcG9pbnQgZm9yIGltcGxlbWVudGluZyBzb21lIGdhbWVzIGFuZCBleHBlcmllbmNlcy5cbiogQWx0ZXJuYXRpdmVseSBzZWUgYEVuZ2luZS51cGRhdGVgIHRvIHN0ZXAgdGhlIGVuZ2luZSBkaXJlY3RseSBpbnNpZGUgeW91ciBvd24gZ2FtZSBsb29wIGltcGxlbWVudGF0aW9uIGFzIG1heSBiZSBuZWVkZWQgaW5zaWRlIG90aGVyIGVudmlyb25tZW50cy5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFJ1bm5lclxuKi9cblxudmFyIFJ1bm5lciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcblxudmFyIEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRW5naW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgUnVubmVyLl9tYXhGcmFtZURlbHRhID0gMTAwMCAvIDE1O1xuICAgIFJ1bm5lci5fZnJhbWVEZWx0YUZhbGxiYWNrID0gMTAwMCAvIDYwO1xuICAgIFJ1bm5lci5fdGltZUJ1ZmZlck1hcmdpbiA9IDEuNTtcbiAgICBSdW5uZXIuX2VsYXBzZWROZXh0RXN0aW1hdGUgPSAxO1xuICAgIFJ1bm5lci5fc21vb3RoaW5nTG93ZXJCb3VuZCA9IDAuMTtcbiAgICBSdW5uZXIuX3Ntb290aGluZ1VwcGVyQm91bmQgPSAwLjk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJ1bm5lci4gXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICovXG4gICAgUnVubmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgZGVsdGE6IDEwMDAgLyA2MCxcbiAgICAgICAgICAgIGZyYW1lRGVsdGE6IG51bGwsXG4gICAgICAgICAgICBmcmFtZURlbHRhU21vb3RoaW5nOiB0cnVlLFxuICAgICAgICAgICAgZnJhbWVEZWx0YVNuYXBwaW5nOiB0cnVlLFxuICAgICAgICAgICAgZnJhbWVEZWx0YUhpc3Rvcnk6IFtdLFxuICAgICAgICAgICAgZnJhbWVEZWx0YUhpc3RvcnlTaXplOiAxMDAsXG4gICAgICAgICAgICBmcmFtZVJlcXVlc3RJZDogbnVsbCxcbiAgICAgICAgICAgIHRpbWVCdWZmZXI6IDAsXG4gICAgICAgICAgICB0aW1lTGFzdFRpY2s6IG51bGwsXG4gICAgICAgICAgICBtYXhVcGRhdGVzOiBudWxsLFxuICAgICAgICAgICAgbWF4RnJhbWVUaW1lOiAxMDAwIC8gMzAsXG4gICAgICAgICAgICBsYXN0VXBkYXRlc0RlZmVycmVkOiAwLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBydW5uZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBmb3IgdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICAgIHJ1bm5lci5mcHMgPSAwO1xuXG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBgTWF0dGVyLkVuZ2luZWAgd2hpbHN0IHN5bmNocm9uaXNpbmcgZW5naW5lIHVwZGF0ZXMgd2l0aCB0aGUgYnJvd3NlciBmcmFtZSByYXRlLiBcbiAgICAgKiBTZWUgbW9kdWxlIGFuZCBwcm9wZXJ0aWVzIGRlc2NyaXB0aW9ucyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGlzIHJ1bm5lci5cbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHNlZSBgRW5naW5lLnVwZGF0ZWAgdG8gc3RlcCB0aGUgZW5naW5lIGRpcmVjdGx5IGluc2lkZSB5b3VyIG93biBnYW1lIGxvb3AgaW1wbGVtZW50YXRpb24uXG4gICAgICogQG1ldGhvZCBydW5cbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IFtlbmdpbmVdXG4gICAgICogQHJldHVybiB7cnVubmVyfSBydW5uZXJcbiAgICAgKi9cbiAgICBSdW5uZXIucnVuID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUpIHtcbiAgICAgICAgLy8gaW5pdGlhbCB0aW1lIGJ1ZmZlciBmb3IgdGhlIGZpcnN0IGZyYW1lXG4gICAgICAgIHJ1bm5lci50aW1lQnVmZmVyID0gUnVubmVyLl9mcmFtZURlbHRhRmFsbGJhY2s7XG5cbiAgICAgICAgKGZ1bmN0aW9uIG9uRnJhbWUodGltZSl7XG4gICAgICAgICAgICBydW5uZXIuZnJhbWVSZXF1ZXN0SWQgPSBSdW5uZXIuX29uTmV4dEZyYW1lKHJ1bm5lciwgb25GcmFtZSk7XG5cbiAgICAgICAgICAgIGlmICh0aW1lICYmIHJ1bm5lci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgUnVubmVyLnRpY2socnVubmVyLCBlbmdpbmUsIHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2luZ2xlIHJ1bm5lciB0aWNrIGFzIHVzZWQgaW5zaWRlIGBSdW5uZXIucnVuYC5cbiAgICAgKiBTZWUgbW9kdWxlIGFuZCBwcm9wZXJ0aWVzIGRlc2NyaXB0aW9ucyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGlzIHJ1bm5lci5cbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHNlZSBgRW5naW5lLnVwZGF0ZWAgdG8gc3RlcCB0aGUgZW5naW5lIGRpcmVjdGx5IGluc2lkZSB5b3VyIG93biBnYW1lIGxvb3AgaW1wbGVtZW50YXRpb24uXG4gICAgICogQG1ldGhvZCB0aWNrXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICAgICAqL1xuICAgIFJ1bm5lci50aWNrID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUsIHRpbWUpIHtcbiAgICAgICAgdmFyIHRpY2tTdGFydFRpbWUgPSBDb21tb24ubm93KCksXG4gICAgICAgICAgICBlbmdpbmVEZWx0YSA9IHJ1bm5lci5kZWx0YSxcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50ID0gMDtcblxuICAgICAgICAvLyBmaW5kIGZyYW1lIGRlbHRhIHRpbWUgc2luY2UgbGFzdCBjYWxsXG4gICAgICAgIHZhciBmcmFtZURlbHRhID0gdGltZSAtIHJ1bm5lci50aW1lTGFzdFRpY2s7XG5cbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIHVudXNhYmxlIGZyYW1lIGRlbHRhIHZhbHVlcyAoZS5nLiAwLCBOYU4sIG9uIGZpcnN0IGZyYW1lIG9yIGxvbmcgcGF1c2VzKVxuICAgICAgICBpZiAoIWZyYW1lRGVsdGEgfHwgIXJ1bm5lci50aW1lTGFzdFRpY2sgfHwgZnJhbWVEZWx0YSA+IE1hdGgubWF4KFJ1bm5lci5fbWF4RnJhbWVEZWx0YSwgcnVubmVyLm1heEZyYW1lVGltZSkpIHtcbiAgICAgICAgICAgIC8vIHJldXNlIGxhc3QgYWNjZXB0ZWQgZnJhbWUgZGVsdGEgZWxzZSBmYWxsYmFja1xuICAgICAgICAgICAgZnJhbWVEZWx0YSA9IHJ1bm5lci5mcmFtZURlbHRhIHx8IFJ1bm5lci5fZnJhbWVEZWx0YUZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bm5lci5mcmFtZURlbHRhU21vb3RoaW5nKSB7XG4gICAgICAgICAgICAvLyByZWNvcmQgZnJhbWUgZGVsdGEgb3ZlciBhIG51bWJlciBvZiBmcmFtZXNcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZURlbHRhSGlzdG9yeS5wdXNoKGZyYW1lRGVsdGEpO1xuICAgICAgICAgICAgcnVubmVyLmZyYW1lRGVsdGFIaXN0b3J5ID0gcnVubmVyLmZyYW1lRGVsdGFIaXN0b3J5LnNsaWNlKC1ydW5uZXIuZnJhbWVEZWx0YUhpc3RvcnlTaXplKTtcblxuICAgICAgICAgICAgLy8gc29ydCBmcmFtZSBkZWx0YSBoaXN0b3J5XG4gICAgICAgICAgICB2YXIgZGVsdGFIaXN0b3J5U29ydGVkID0gcnVubmVyLmZyYW1lRGVsdGFIaXN0b3J5LnNsaWNlKDApLnNvcnQoKTtcblxuICAgICAgICAgICAgLy8gc2FtcGxlIGEgY2VudHJhbCB3aW5kb3cgdG8gbGltaXQgb3V0bGllcnNcbiAgICAgICAgICAgIHZhciBkZWx0YUhpc3RvcnlXaW5kb3cgPSBydW5uZXIuZnJhbWVEZWx0YUhpc3Rvcnkuc2xpY2UoXG4gICAgICAgICAgICAgICAgZGVsdGFIaXN0b3J5U29ydGVkLmxlbmd0aCAqIFJ1bm5lci5fc21vb3RoaW5nTG93ZXJCb3VuZCwgXG4gICAgICAgICAgICAgICAgZGVsdGFIaXN0b3J5U29ydGVkLmxlbmd0aCAqIFJ1bm5lci5fc21vb3RoaW5nVXBwZXJCb3VuZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gdGFrZSB0aGUgbWVhbiBvZiB0aGUgY2VudHJhbCB3aW5kb3dcbiAgICAgICAgICAgIHZhciBmcmFtZURlbHRhU21vb3RoZWQgPSBfbWVhbihkZWx0YUhpc3RvcnlXaW5kb3cpO1xuICAgICAgICAgICAgZnJhbWVEZWx0YSA9IGZyYW1lRGVsdGFTbW9vdGhlZCB8fCBmcmFtZURlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bm5lci5mcmFtZURlbHRhU25hcHBpbmcpIHtcbiAgICAgICAgICAgIC8vIHNuYXAgZnJhbWUgZGVsdGEgdG8gdGhlIG5lYXJlc3QgMSBIelxuICAgICAgICAgICAgZnJhbWVEZWx0YSA9IDEwMDAgLyBNYXRoLnJvdW5kKDEwMDAgLyBmcmFtZURlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBydW5uZXIgdmFsdWVzIGZvciBuZXh0IGNhbGxcbiAgICAgICAgcnVubmVyLmZyYW1lRGVsdGEgPSBmcmFtZURlbHRhO1xuICAgICAgICBydW5uZXIudGltZUxhc3RUaWNrID0gdGltZTtcblxuICAgICAgICAvLyBhY2N1bXVsYXRlIGVsYXBzZWQgdGltZVxuICAgICAgICBydW5uZXIudGltZUJ1ZmZlciArPSBydW5uZXIuZnJhbWVEZWx0YTtcblxuICAgICAgICAvLyBsaW1pdCB0aW1lIGJ1ZmZlciBzaXplIHRvIGEgc2luZ2xlIGZyYW1lIG9mIHVwZGF0ZXNcbiAgICAgICAgcnVubmVyLnRpbWVCdWZmZXIgPSBDb21tb24uY2xhbXAoXG4gICAgICAgICAgICBydW5uZXIudGltZUJ1ZmZlciwgMCwgcnVubmVyLmZyYW1lRGVsdGEgKyBlbmdpbmVEZWx0YSAqIFJ1bm5lci5fdGltZUJ1ZmZlck1hcmdpblxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJlc2V0IGNvdW50IG9mIG92ZXIgYnVkZ2V0IHVwZGF0ZXNcbiAgICAgICAgcnVubmVyLmxhc3RVcGRhdGVzRGVmZXJyZWQgPSAwO1xuXG4gICAgICAgIC8vIGdldCBtYXggdXBkYXRlcyBwZXIgZnJhbWVcbiAgICAgICAgdmFyIG1heFVwZGF0ZXMgPSBydW5uZXIubWF4VXBkYXRlcyB8fCBNYXRoLmNlaWwocnVubmVyLm1heEZyYW1lVGltZSAvIGVuZ2luZURlbHRhKTtcblxuICAgICAgICAvLyBjcmVhdGUgZXZlbnQgb2JqZWN0XG4gICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZW5naW5lLnRpbWluZy50aW1lc3RhbXBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aWNrIGV2ZW50cyBiZWZvcmUgdXBkYXRlXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2JlZm9yZVRpY2snLCBldmVudCk7XG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ3RpY2snLCBldmVudCk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVN0YXJ0VGltZSA9IENvbW1vbi5ub3coKTtcblxuICAgICAgICAvLyBzaW11bGF0ZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBjYWxsc1xuICAgICAgICB3aGlsZSAoZW5naW5lRGVsdGEgPiAwICYmIHJ1bm5lci50aW1lQnVmZmVyID49IGVuZ2luZURlbHRhICogUnVubmVyLl90aW1lQnVmZmVyTWFyZ2luKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGVuZ2luZVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlVXBkYXRlJywgZXZlbnQpO1xuICAgICAgICAgICAgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGVuZ2luZURlbHRhKTtcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2FmdGVyVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBjb25zdW1lIHRpbWUgc2ltdWxhdGVkIGZyb20gYnVmZmVyXG4gICAgICAgICAgICBydW5uZXIudGltZUJ1ZmZlciAtPSBlbmdpbmVEZWx0YTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50ICs9IDE7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgZWxhcHNlZCB0aW1lIGR1cmluZyB0aGlzIHRpY2tcbiAgICAgICAgICAgIHZhciBlbGFwc2VkVGltZVRvdGFsID0gQ29tbW9uLm5vdygpIC0gdGlja1N0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbGFwc2VkVGltZVVwZGF0ZXMgPSBDb21tb24ubm93KCkgLSB1cGRhdGVTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZWxhcHNlZE5leHRFc3RpbWF0ZSA9IGVsYXBzZWRUaW1lVG90YWwgKyBSdW5uZXIuX2VsYXBzZWROZXh0RXN0aW1hdGUgKiBlbGFwc2VkVGltZVVwZGF0ZXMgLyB1cGRhdGVDb3VudDtcblxuICAgICAgICAgICAgLy8gZGVmZXIgdXBkYXRlcyBpZiBvdmVyIHBlcmZvcm1hbmNlIGJ1ZGdldHMgZm9yIHRoaXMgZnJhbWVcbiAgICAgICAgICAgIGlmICh1cGRhdGVDb3VudCA+PSBtYXhVcGRhdGVzIHx8IGVsYXBzZWROZXh0RXN0aW1hdGUgPiBydW5uZXIubWF4RnJhbWVUaW1lKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmxhc3RVcGRhdGVzRGVmZXJyZWQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIChydW5uZXIudGltZUJ1ZmZlciAvIGVuZ2luZURlbHRhKSAtIFJ1bm5lci5fdGltZUJ1ZmZlck1hcmdpbikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhY2sgdGltaW5nIG1ldHJpY3NcbiAgICAgICAgZW5naW5lLnRpbWluZy5sYXN0VXBkYXRlc1BlckZyYW1lID0gdXBkYXRlQ291bnQ7XG5cbiAgICAgICAgLy8gdGljayBldmVudHMgYWZ0ZXIgdXBkYXRlXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKHJ1bm5lciwgJ2FmdGVyVGljaycsIGV2ZW50KTtcblxuICAgICAgICAvLyBzaG93IHVzZWZ1bCB3YXJuaW5ncyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHJ1bm5lci5mcmFtZURlbHRhSGlzdG9yeS5sZW5ndGggPj0gMTAwKSB7XG4gICAgICAgICAgICBpZiAocnVubmVyLmxhc3RVcGRhdGVzRGVmZXJyZWQgJiYgTWF0aC5yb3VuZChydW5uZXIuZnJhbWVEZWx0YSAvIGVuZ2luZURlbHRhKSA+IG1heFVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2Fybk9uY2UoJ01hdHRlci5SdW5uZXI6IHJ1bm5lciByZWFjaGVkIHJ1bm5lci5tYXhVcGRhdGVzLCBzZWUgZG9jcy4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVubmVyLmxhc3RVcGRhdGVzRGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2Fybk9uY2UoJ01hdHRlci5SdW5uZXI6IHJ1bm5lciByZWFjaGVkIHJ1bm5lci5tYXhGcmFtZVRpbWUsIHNlZSBkb2NzLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJ1bm5lci5pc0ZpeGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuT25jZSgnTWF0dGVyLlJ1bm5lcjogcnVubmVyLmlzRml4ZWQgaXMgbm93IHJlZHVuZGFudCwgc2VlIGRvY3MuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChydW5uZXIuZGVsdGFNaW4gfHwgcnVubmVyLmRlbHRhTWF4KSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm5PbmNlKCdNYXR0ZXIuUnVubmVyOiBydW5uZXIuZGVsdGFNaW4gYW5kIHJ1bm5lci5kZWx0YU1heCB3ZXJlIHJlbW92ZWQsIHNlZSBkb2NzLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVubmVyLmZwcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuT25jZSgnTWF0dGVyLlJ1bm5lcjogcnVubmVyLmZwcyB3YXMgcmVwbGFjZWQgYnkgcnVubmVyLmRlbHRhLCBzZWUgZG9jcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUnVubmVyLnJ1bmAgb24gdGhlIGdpdmVuIGBydW5uZXJgIGJ5IGNhbmNlbGluZyB0aGUgZnJhbWUgbG9vcC5cbiAgICAgKiBBbHRlcm5hdGl2ZWx5IHRvIHRlbXBvcmFyaWx5IHBhdXNlIHRoZSBydW5uZXIsIHNlZSBgcnVubmVyLmVuYWJsZWRgLlxuICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcbiAgICAgKi9cbiAgICBSdW5uZXIuc3RvcCA9IGZ1bmN0aW9uKHJ1bm5lcikge1xuICAgICAgICBSdW5uZXIuX2NhbmNlbE5leHRGcmFtZShydW5uZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhlIGBjYWxsYmFja2Agb24gdGhpcyBgcnVubmVyYCBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBfb25OZXh0RnJhbWVcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGZyYW1lUmVxdWVzdElkXG4gICAgICovXG4gICAgUnVubmVyLl9vbk5leHRGcmFtZSA9IGZ1bmN0aW9uKHJ1bm5lciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZVJlcXVlc3RJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXR0ZXIuUnVubmVyOiBtaXNzaW5nIHJlcXVpcmVkIGdsb2JhbCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bm5lci5mcmFtZVJlcXVlc3RJZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgbGFzdCBjYWxsYmFjayBzY2hlZHVsZWQgYnkgYFJ1bm5lci5fb25OZXh0RnJhbWVgIG9uIHRoaXMgYHJ1bm5lcmAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIF9jYW5jZWxOZXh0RnJhbWVcbiAgICAgKiBAcGFyYW0ge3J1bm5lcn0gcnVubmVyXG4gICAgICovXG4gICAgUnVubmVyLl9jYW5jZWxOZXh0RnJhbWUgPSBmdW5jdGlvbihydW5uZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJ1bm5lci5mcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHRlci5SdW5uZXI6IG1pc3NpbmcgcmVxdWlyZWQgZ2xvYmFsIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZS4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIG9mIHRoZSBnaXZlbiBudW1iZXJzLlxuICAgICAqIEBtZXRob2QgX21lYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIG1lYW4gb2YgZ2l2ZW4gdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBfbWVhbiA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXNMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAocmVzdWx0IC8gdmFsdWVzTGVuZ3RoKSB8fCAwO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBvbmNlIGF0IHRoZSBzdGFydCBvZiB0aGUgYnJvd3NlciBmcmFtZSwgYmVmb3JlIGFueSBlbmdpbmUgdXBkYXRlcy5cbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlVGlja1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgb25jZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGJyb3dzZXIgZnJhbWUsIGFmdGVyIGBiZWZvcmVUaWNrYC5cbiAgICAqXG4gICAgKiBAZXZlbnQgdGlja1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgb25jZSBhdCB0aGUgZW5kIG9mIHRoZSBicm93c2VyIGZyYW1lLCBhZnRlciBgYmVmb3JlVGlja2AsIGB0aWNrYCBhbmQgYWZ0ZXIgYW55IGVuZ2luZSB1cGRhdGVzLlxuICAgICpcbiAgICAqIEBldmVudCBhZnRlclRpY2tcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGJlZm9yZSBlYWNoIGFuZCBldmVyeSBlbmdpbmUgdXBkYXRlIGluIHRoaXMgYnJvd3NlciBmcmFtZSAoaWYgYW55KS4gXG4gICAgKiBUaGVyZSBtYXkgYmUgbXVsdGlwbGUgZW5naW5lIHVwZGF0ZSBjYWxscyBwZXIgYnJvd3NlciBmcmFtZSAob3Igbm9uZSkgZGVwZW5kaW5nIG9uIGZyYW1lcmF0ZSBhbmQgdGltZXN0ZXAgZGVsdGEuXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZWFjaCBhbmQgZXZlcnkgZW5naW5lIHVwZGF0ZSBpbiB0aGlzIGJyb3dzZXIgZnJhbWUgKGlmIGFueSkuIFxuICAgICogVGhlcmUgbWF5IGJlIG11bHRpcGxlIGVuZ2luZSB1cGRhdGUgY2FsbHMgcGVyIGJyb3dzZXIgZnJhbWUgKG9yIG5vbmUpIGRlcGVuZGluZyBvbiBmcmFtZXJhdGUgYW5kIHRpbWVzdGVwIGRlbHRhLlxuICAgICpcbiAgICAqIEBldmVudCBhZnRlclVwZGF0ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpeGVkIHRpbWVzdGVwIHNpemUgdXNlZCBmb3IgYEVuZ2luZS51cGRhdGVgIGNhbGxzIGluIG1pbGxpc2Vjb25kcywga25vd24gYXMgYGRlbHRhYC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHJlY29tbWVuZGVkIHRvIGJlIGAxMDAwIC8gNjBgIG1zIG9yIHNtYWxsZXIgKGkuZS4gZXF1aXZhbGVudCB0byBhdCBsZWFzdCA2MGh6KS5cbiAgICAgKiBcbiAgICAgKiBTbWFsbGVyIGBkZWx0YWAgdmFsdWVzIHByb3ZpZGUgaGlnaGVyIHF1YWxpdHkgcmVzdWx0cyBhdCB0aGUgY29zdCBvZiBwZXJmb3JtYW5jZS5cbiAgICAgKiBcbiAgICAgKiBZb3Ugc2hvdWxkIHVzdWFsbHkgYXZvaWQgY2hhbmdpbmcgYGRlbHRhYCBkdXJpbmcgcnVubmluZywgb3RoZXJ3aXNlIHF1YWxpdHkgbWF5IGJlIGFmZmVjdGVkLiBcbiAgICAgKiBcbiAgICAgKiBGb3Igc21vb3RoZXIgZnJhbWUgcGFjaW5nIGNob29zZSBhIGBkZWx0YWAgdGhhdCBpcyBhbiBldmVuIG11bHRpcGxlIG9mIGVhY2ggZGlzcGxheSBGUFMgeW91IHRhcmdldCwgaS5lLiBgMTAwMCAvIChuICogZnBzKWAgYXMgdGhpcyBoZWxwcyBkaXN0cmlidXRlIGFuIGVxdWFsIG51bWJlciBvZiB1cGRhdGVzIG92ZXIgZWFjaCBkaXNwbGF5IGZyYW1lLlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlIHdpdGggYSA2MCBIeiBgZGVsdGFgIGkuZS4gYDEwMDAgLyA2MGAgdGhlIHJ1bm5lciB3aWxsIG9uIGF2ZXJhZ2UgcGVyZm9ybSBvbmUgdXBkYXRlIHBlciBmcmFtZSBvbiBkaXNwbGF5cyBydW5uaW5nIDYwIEZQUyBhbmQgb25lIHVwZGF0ZSBldmVyeSB0d28gZnJhbWVzIG9uIGRpc3BsYXlzIHJ1bm5pbmcgMTIwIEZQUywgZXRjLlxuICAgICAqIFxuICAgICAqIFdoZXJlIGFzIGUuZy4gdXNpbmcgYSAyNDAgSHogYGRlbHRhYCBpLmUuIGAxMDAwIC8gMjQwYCB0aGUgcnVubmVyIHdpbGwgb24gYXZlcmFnZSBwZXJmb3JtIGZvdXIgdXBkYXRlcyBwZXIgZnJhbWUgb24gZGlzcGxheXMgcnVubmluZyA2MCBGUFMgYW5kIHR3byB1cGRhdGVzIHBlciBmcmFtZSBvbiBkaXNwbGF5cyBydW5uaW5nIDEyMCBGUFMsIGV0Yy5cbiAgICAgKiBcbiAgICAgKiBUaGVyZWZvcmUgYFJ1bm5lci5ydW5gIHdpbGwgY2FsbCBtdWx0aXBsZSBlbmdpbmUgdXBkYXRlcyAob3Igbm9uZSkgYXMgbmVlZGVkIHRvIHNpbXVsYXRlIHRoZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBicm93c2VyIGZyYW1lcy4gXG4gICAgICogXG4gICAgICogSW4gcHJhY3RpY2UgdGhlIG51bWJlciBvZiB1cGRhdGVzIGluIGFueSBwYXJ0aWN1bGFyIGZyYW1lIG1heSBiZSByZXN0cmljdGVkIHRvIHJlc3BlY3QgdGhlIHJ1bm5lcidzIHBlcmZvcm1hbmNlIGJ1ZGdldHMuIFRoZXNlIGFyZSBzcGVjaWZpZWQgYnkgYHJ1bm5lci5tYXhGcmFtZVRpbWVgIGFuZCBgcnVubmVyLm1heFVwZGF0ZXNgLCBzZWUgdGhvc2UgcHJvcGVydGllcyBmb3IgZGV0YWlscy5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgZGVsdGFcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxMDAwIC8gNjBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGNhbiBiZSB0b2dnbGVkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRpY2sgY2FsbHMgb24gdGhpcyBydW5uZXIsIHRoZXJlZm9yZSBwYXVzaW5nIGVuZ2luZSB1cGRhdGVzIGFuZCBldmVudHMgd2hpbGUgdGhlIHJ1bm5lciBsb29wIHJlbWFpbnMgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhY2N1bXVsYXRlZCB0aW1lIGVsYXBzZWQgdGhhdCBoYXMgeWV0IHRvIGJlIHNpbXVsYXRlZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogVGhpcyB2YWx1ZSBpcyBjbGFtcGVkIHdpdGhpbiBjZXJ0YWluIGxpbWl0cyAoc2VlIGBSdW5uZXIudGlja2AgY29kZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB0aW1lQnVmZmVyXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1lYXN1cmVkIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIHRoZSBsYXN0IHR3byBicm93c2VyIGZyYW1lcyBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZS5nLiB0byBlc3RpbWF0ZSB0aGUgY3VycmVudCBicm93c2VyIEZQUyB1c2luZyBgMTAwMCAvIHJ1bm5lci5mcmFtZURlbHRhYC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcm9wZXJ0eSBmcmFtZURlbHRhXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGF2ZXJhZ2luZyB0byBzbW9vdGggZnJhbWUgcmF0ZSBtZWFzdXJlbWVudHMgYW5kIHRoZXJlZm9yZSBzdGFiaWxpc2UgcGxheSByYXRlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyYW1lRGVsdGFTbW9vdGhpbmdcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUm91bmRzIG1lYXN1cmVkIGJyb3dzZXIgZnJhbWUgZGVsdGEgdG8gdGhlIG5lYXJlc3QgMSBIei5cbiAgICAgKiBUaGlzIG9wdGlvbiBjYW4gaGVscCBzbW9vdGggZnJhbWUgcmF0ZSBtZWFzdXJlbWVudHMgYW5kIHNpbXBsaWZ5IGhhbmRsaW5nIGhhcmR3YXJlIHRpbWluZyBkaWZmZXJlbmNlcyBlLmcuIDU5Ljk0SHogYW5kIDYwSHogZGlzcGxheXMuXG4gICAgICogRm9yIGJlc3QgcmVzdWx0cyB5b3Ugc2hvdWxkIGFsc28gcm91bmQgeW91ciBgcnVubmVyLmRlbHRhYCBlcXVpdmFsZW50IHRvIHRoZSBuZWFyZXN0IDEgSHouXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVEZWx0YVNuYXBwaW5nXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgcGVyZm9ybWFuY2UgYnVkZ2V0IHRoYXQgbGltaXRzIGV4ZWN1dGlvbiB0aW1lIGFsbG93ZWQgZm9yIHRoaXMgcnVubmVyIHBlciBicm93c2VyIGZyYW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBcbiAgICAgKiBUbyBjYWxjdWxhdGUgdGhlIGVmZmVjdGl2ZSBicm93c2VyIEZQUyBhdCB3aGljaCB0aGlzIHRocm90dGxlIGlzIGFwcGxpZWQgdXNlIGAxMDAwIC8gcnVubmVyLm1heEZyYW1lVGltZWAuXG4gICAgICogXG4gICAgICogVGhpcyBwZXJmb3JtYW5jZSBidWRnZXQgaXMgaW50ZW5kZWQgdG8gaGVscCBtYWludGFpbiBicm93c2VyIGludGVyYWN0aXZpdHkgYW5kIGhlbHAgaW1wcm92ZSBmcmFtZXJhdGUgcmVjb3ZlcnkgZHVyaW5nIHRlbXBvcmFyeSBoaWdoIENQVSB1c2FnZS5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGJ1ZGdldCBvbmx5IGNvdmVycyB0aGUgbWVhc3VyZWQgdGltZSBlbGFwc2VkIGV4ZWN1dGluZyB0aGUgZnVuY3Rpb25zIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJ1bm5lciB0aWNrLCBpbmNsdWRpbmcgYEVuZ2luZS51cGRhdGVgIGFuZCBpdHMgcmVsYXRlZCB1c2VyIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgKiBcbiAgICAgKiBZb3UgbWF5IGFsc28gcmVkdWNlIHRoaXMgYnVkZ2V0IHRvIGFsbG93IGZvciBhbnkgc2lnbmlmaWNhbnQgYWRkaXRpb25hbCBwcm9jZXNzaW5nIHlvdSBwZXJmb3JtIG9uIHRoZSBzYW1lIHRocmVhZCBvdXRzaWRlIHRoZSBzY29wZSBvZiB0aGlzIHJ1bm5lciB0aWNrLCBlLmcuIHJlbmRlcmluZyB0aW1lLlxuICAgICAqIFxuICAgICAqIFNlZSBhbHNvIGBydW5uZXIubWF4VXBkYXRlc2AuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWF4RnJhbWVUaW1lXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMTAwMCAvIDMwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBsaW1pdCBmb3IgbWF4aW11bSBlbmdpbmUgdXBkYXRlIGNvdW50IGFsbG93ZWQgcGVyIGZyYW1lIHRpY2sgaW4gYWRkaXRpb24gdG8gYHJ1bm5lci5tYXhGcmFtZVRpbWVgLlxuICAgICAqIFxuICAgICAqIFVubGVzcyB5b3Ugc2V0IGEgdmFsdWUgaXQgaXMgYXV0b21hdGljYWxseSBjaG9zZW4gYmFzZWQgb24gYHJ1bm5lci5kZWx0YWAgYW5kIGBydW5uZXIubWF4RnJhbWVUaW1lYC5cbiAgICAgKiBcbiAgICAgKiBTZWUgYWxzbyBgcnVubmVyLm1heEZyYW1lVGltZWAuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IG1heFVwZGF0ZXNcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IGNhbGwgdG8gYFJ1bm5lci50aWNrYCB1c2VkIHRvIG1lYXN1cmUgYGZyYW1lRGVsdGFgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgdGltZUxhc3RUaWNrXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGlkIG9mIHRoZSBsYXN0IGNhbGwgdG8gYFJ1bm5lci5fb25OZXh0RnJhbWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgZnJhbWVSZXF1ZXN0SWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhpcyBtb2R1bGUgaGFzIG5vdyBiZWVuIHJlcGxhY2VkIGJ5IGBNYXR0ZXIuQ29sbGlzaW9uYC5cbipcbiogQWxsIHVzYWdlIHNob3VsZCBiZSBtaWdyYXRlZCB0byBgTWF0dGVyLkNvbGxpc2lvbmAuXG4qIEZvciBiYWNrLWNvbXBhdGliaWxpdHkgcHVycG9zZXMgdGhpcyBtb2R1bGUgd2lsbCByZW1haW4gZm9yIGEgc2hvcnQgdGVybSBhbmQgdGhlbiBsYXRlciByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4qXG4qIFRoZSBgTWF0dGVyLlNBVGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGRldGVjdGluZyBjb2xsaXNpb25zIHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbS5cbipcbiogQGNsYXNzIFNBVFxuKiBAZGVwcmVjYXRlZFxuKi9cblxudmFyIFNBVCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNBVDtcblxudmFyIENvbGxpc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBkZXByZWNhdGVkID0gQ29tbW9uLmRlcHJlY2F0ZWQ7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBjb2xsaXNpb24gYmV0d2VlbiB0d28gYm9kaWVzIHVzaW5nIHRoZSBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbS5cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBDb2xsaXNpb24uY29sbGlkZXNcbiAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcmV0dXJuIHtjb2xsaXNpb259IGNvbGxpc2lvblxuICAgICAqL1xuICAgIFNBVC5jb2xsaWRlcyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICByZXR1cm4gQ29sbGlzaW9uLmNvbGxpZGVzKGJvZHlBLCBib2R5Qik7XG4gICAgfTtcblxuICAgIGRlcHJlY2F0ZWQoU0FULCAnY29sbGlkZXMnLCAnU0FULmNvbGxpZGVzIOKepCByZXBsYWNlZCBieSBDb2xsaXNpb24uY29sbGlkZXMnKTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5TdmdgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjb252ZXJ0aW5nIFNWRyBpbWFnZXMgaW50byBhbiBhcnJheSBvZiB2ZWN0b3IgcG9pbnRzLlxuKlxuKiBUbyB1c2UgdGhpcyBtb2R1bGUgeW91IGFsc28gbmVlZCB0aGUgU1ZHUGF0aFNlZyBwb2x5ZmlsbDogaHR0cHM6Ly9naXRodWIuY29tL3Byb2dlcnMvcGF0aHNlZ1xuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgU3ZnXG4qL1xuXG52YXIgU3ZnID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU3ZnO1xuXG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBTVkcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHZlY3RvciBwb2ludHMuXG4gICAgICogSWYgdGhlIGlucHV0IHBhdGggZm9ybXMgYSBjb25jYXZlIHNoYXBlLCB5b3UgbXVzdCBkZWNvbXBvc2UgdGhlIHJlc3VsdCBpbnRvIGNvbnZleCBwYXJ0cyBiZWZvcmUgdXNlLlxuICAgICAqIFNlZSBgQm9kaWVzLmZyb21WZXJ0aWNlc2Agd2hpY2ggcHJvdmlkZXMgc3VwcG9ydCBmb3IgdGhpcy5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBub3QgZ3VhcmFudGVlZCB0byBzdXBwb3J0IGNvbXBsZXggcGF0aHMgKHN1Y2ggYXMgdGhvc2Ugd2l0aCBob2xlcykuXG4gICAgICogWW91IG11c3QgbG9hZCB0aGUgYHBhdGhzZWcuanNgIHBvbHlmaWxsIG9uIG5ld2VyIGJyb3dzZXJzLlxuICAgICAqIEBtZXRob2QgcGF0aFRvVmVydGljZXNcbiAgICAgKiBAcGFyYW0ge1NWR1BhdGhFbGVtZW50fSBwYXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVMZW5ndGg9MTVdXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHBvaW50c1xuICAgICAqL1xuICAgIFN2Zy5wYXRoVG9WZXJ0aWNlcyA9IGZ1bmN0aW9uKHBhdGgsIHNhbXBsZUxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISgnU1ZHUGF0aFNlZycgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1N2Zy5wYXRoVG9WZXJ0aWNlczogU1ZHUGF0aFNlZyBub3QgZGVmaW5lZCwgYSBwb2x5ZmlsbCBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93b3V0L3N2Zy50b3BvbHkuanMvYmxvYi9tYXN0ZXIvc3ZnLnRvcG9seS5qc1xuICAgICAgICB2YXIgaSwgaWwsIHRvdGFsLCBwb2ludCwgc2VnbWVudCwgc2VnbWVudHMsIFxuICAgICAgICAgICAgc2VnbWVudHNRdWV1ZSwgbGFzdFNlZ21lbnQsIFxuICAgICAgICAgICAgbGFzdFBvaW50LCBzZWdtZW50SW5kZXgsIHBvaW50cyA9IFtdLFxuICAgICAgICAgICAgbHgsIGx5LCBsZW5ndGggPSAwLCB4ID0gMCwgeSA9IDA7XG5cbiAgICAgICAgc2FtcGxlTGVuZ3RoID0gc2FtcGxlTGVuZ3RoIHx8IDE1O1xuXG4gICAgICAgIHZhciBhZGRQb2ludCA9IGZ1bmN0aW9uKHB4LCBweSwgcGF0aFNlZ1R5cGUpIHtcbiAgICAgICAgICAgIC8vIGFsbCBvZGQtbnVtYmVyZWQgcGF0aCB0eXBlcyBhcmUgcmVsYXRpdmUgZXhjZXB0IFBBVEhTRUdfQ0xPU0VQQVRIICgxKVxuICAgICAgICAgICAgdmFyIGlzUmVsYXRpdmUgPSBwYXRoU2VnVHlwZSAlIDIgPT09IDEgJiYgcGF0aFNlZ1R5cGUgPiAxO1xuXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBsYXN0IHBvaW50IGRvZXNuJ3QgZXF1YWwgdGhlIGN1cnJlbnQgcG9pbnQgYWRkIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCBweCAhPSBsYXN0UG9pbnQueCB8fCBweSAhPSBsYXN0UG9pbnQueSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgJiYgaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBseCA9IGxhc3RQb2ludC54O1xuICAgICAgICAgICAgICAgICAgICBseSA9IGxhc3RQb2ludC55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGx4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbHkgPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogbHggKyBweCxcbiAgICAgICAgICAgICAgICAgICAgeTogbHkgKyBweVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgbGFzdCBwb2ludFxuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlIHx8ICFsYXN0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgeCA9IGx4ICsgcHg7XG4gICAgICAgICAgICAgICAgeSA9IGx5ICsgcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkZFNlZ21lbnRQb2ludCA9IGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBzZWdUeXBlID0gc2VnbWVudC5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIHNraXAgcGF0aCBlbmRzXG4gICAgICAgICAgICBpZiAoc2VnVHlwZSA9PT0gJ1onKSBcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG1hcCBzZWdtZW50IHRvIHggYW5kIHlcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICB5ID0gc2VnbWVudC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgeCA9IHNlZ21lbnQueDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgIHkgPSBzZWdtZW50Lnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZFBvaW50KHgsIHksIHNlZ21lbnQucGF0aFNlZ1R5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVuc3VyZSBwYXRoIGlzIGFic29sdXRlXG4gICAgICAgIFN2Zy5fc3ZnUGF0aFRvQWJzb2x1dGUocGF0aCk7XG5cbiAgICAgICAgLy8gZ2V0IHRvdGFsIGxlbmd0aFxuICAgICAgICB0b3RhbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcblxuICAgICAgICAvLyBxdWV1ZSBzZWdtZW50c1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zOyBpICs9IDEpXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHBhdGgucGF0aFNlZ0xpc3QuZ2V0SXRlbShpKSk7XG5cbiAgICAgICAgc2VnbWVudHNRdWV1ZSA9IHNlZ21lbnRzLmNvbmNhdCgpO1xuXG4gICAgICAgIC8vIHNhbXBsZSB0aHJvdWdoIHBhdGhcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA8IHRvdGFsKSB7XG4gICAgICAgICAgICAvLyBnZXQgc2VnbWVudCBhdCBwb3NpdGlvblxuICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gcGF0aC5nZXRQYXRoU2VnQXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBuZXcgc2VnbWVudFxuICAgICAgICAgICAgaWYgKHNlZ21lbnQgIT0gbGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VnbWVudHNRdWV1ZS5sZW5ndGggJiYgc2VnbWVudHNRdWV1ZVswXSAhPSBzZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZS5zaGlmdCgpKTtcblxuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHBvaW50cyBpbiBiZXR3ZWVuIHdoZW4gY3VydmluZ1xuICAgICAgICAgICAgLy8gVE9ETzogYWRhcHRpdmUgc2FtcGxpbmdcbiAgICAgICAgICAgIHN3aXRjaCAoc2VnbWVudC5wYXRoU2VnVHlwZUFzTGV0dGVyLnRvVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICBwb2ludCA9IHBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LngsIHBvaW50LnksIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBieSBzYW1wbGUgdmFsdWVcbiAgICAgICAgICAgIGxlbmd0aCArPSBzYW1wbGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHNlZ21lbnRzIG5vdCBwYXNzZWQgYnkgc2FtcGxpbmdcbiAgICAgICAgZm9yIChpID0gMCwgaWwgPSBzZWdtZW50c1F1ZXVlLmxlbmd0aDsgaSA8IGlsOyArK2kpXG4gICAgICAgICAgICBhZGRTZWdtZW50UG9pbnQoc2VnbWVudHNRdWV1ZVtpXSk7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9O1xuXG4gICAgU3ZnLl9zdmdQYXRoVG9BYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgLy8gaHR0cDovL3Bocm9nei5uZXQvY29udmVydC1zdmctcGF0aC10by1hbGwtYWJzb2x1dGUtY29tbWFuZHNcbiAgICAgICAgLy8gQ29weXJpZ2h0IChjKSBHYXZpbiBLaXN0bmVyXG4gICAgICAgIC8vIGh0dHA6Ly9waHJvZ3oubmV0L2pzL19SZXVzZUxpY2Vuc2UudHh0XG4gICAgICAgIC8vIE1vZGlmaWNhdGlvbnM6IHRpZHkgZm9ybWF0dGluZyBhbmQgbmFtaW5nXG4gICAgICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCBzZWdzID0gcGF0aC5wYXRoU2VnTGlzdCxcbiAgICAgICAgICAgIHggPSAwLCB5ID0gMCwgbGVuID0gc2Vncy5udW1iZXJPZkl0ZW1zO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzLmdldEl0ZW0oaSksXG4gICAgICAgICAgICAgICAgc2VnVHlwZSA9IHNlZy5wYXRoU2VnVHlwZUFzTGV0dGVyO1xuXG4gICAgICAgICAgICBpZiAoL1tNTEhWQ1NRVEFdLy50ZXN0KHNlZ1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSA9IHNlZy55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3gxJyBpbiBzZWcpIHgxID0geCArIHNlZy54MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3gyJyBpbiBzZWcpIHgyID0geCArIHNlZy54MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3kxJyBpbiBzZWcpIHkxID0geSArIHNlZy55MTtcbiAgICAgICAgICAgICAgICBpZiAoJ3kyJyBpbiBzZWcpIHkyID0geSArIHNlZy55MjtcbiAgICAgICAgICAgICAgICBpZiAoJ3gnIGluIHNlZykgeCArPSBzZWcueDtcbiAgICAgICAgICAgICAgICBpZiAoJ3knIGluIHNlZykgeSArPSBzZWcueTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VnVHlwZSkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzKHgsIHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFicyh4KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzKHkpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzKHgsIHksIHgxLCB5MSwgeDIsIHkyKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyh4LCB5LCB4MiwgeTIpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Ficyh4LCB5LCB4MSwgeTEpLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucmVwbGFjZUl0ZW0ocGF0aC5jcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFicyh4LCB5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0FyY0Ficyh4LCB5LCBzZWcucjEsIHNlZy5yMiwgc2VnLmFuZ2xlLCBzZWcubGFyZ2VBcmNGbGFnLCBzZWcuc3dlZXBGbGFnKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICB4ID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdUeXBlID09ICdNJyB8fCBzZWdUeXBlID09ICdtJykge1xuICAgICAgICAgICAgICAgIHgwID0geDtcbiAgICAgICAgICAgICAgICB5MCA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGlzIG1vZHVsZSBoYXMgbm93IGJlZW4gcmVwbGFjZWQgYnkgYE1hdHRlci5Db21wb3NpdGVgLlxuKlxuKiBBbGwgdXNhZ2Ugc2hvdWxkIGJlIG1pZ3JhdGVkIHRvIHRoZSBlcXVpdmFsZW50IGZ1bmN0aW9ucyBmb3VuZCBvbiBgTWF0dGVyLkNvbXBvc2l0ZWAuXG4qIEZvciBleGFtcGxlIGBXb3JsZC5hZGQod29ybGQsIGJvZHkpYCBub3cgYmVjb21lcyBgQ29tcG9zaXRlLmFkZCh3b3JsZCwgYm9keSlgLlxuKlxuKiBUaGUgcHJvcGVydHkgYHdvcmxkLmdyYXZpdHlgIGhhcyBiZWVuIG1vdmVkIHRvIGBlbmdpbmUuZ3Jhdml0eWAuXG4qXG4qIEZvciBiYWNrLWNvbXBhdGliaWxpdHkgcHVycG9zZXMgdGhpcyBtb2R1bGUgd2lsbCByZW1haW4gYXMgYSBkaXJlY3QgYWxpYXMgdG8gYE1hdHRlci5Db21wb3NpdGVgIGluIHRoZSBzaG9ydCB0ZXJtIGR1cmluZyBtaWdyYXRpb24uXG4qIEV2ZW50dWFsbHkgdGhpcyBhbGlhcyBtb2R1bGUgd2lsbCBiZSBtYXJrZWQgYXMgZGVwcmVjYXRlZCBhbmQgdGhlbiBsYXRlciByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4qXG4qIEBjbGFzcyBXb3JsZFxuKi9cblxudmFyIFdvcmxkID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gV29ybGQ7XG5cbnZhciBDb21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFNlZSBhYm92ZSwgYWxpYXNlcyBmb3IgYmFjayBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgKi9cbiAgICBXb3JsZC5jcmVhdGUgPSBDb21wb3NpdGUuY3JlYXRlO1xuICAgIFdvcmxkLmFkZCA9IENvbXBvc2l0ZS5hZGQ7XG4gICAgV29ybGQucmVtb3ZlID0gQ29tcG9zaXRlLnJlbW92ZTtcbiAgICBXb3JsZC5jbGVhciA9IENvbXBvc2l0ZS5jbGVhcjtcbiAgICBXb3JsZC5hZGRDb21wb3NpdGUgPSBDb21wb3NpdGUuYWRkQ29tcG9zaXRlO1xuICAgIFdvcmxkLmFkZEJvZHkgPSBDb21wb3NpdGUuYWRkQm9keTtcbiAgICBXb3JsZC5hZGRDb25zdHJhaW50ID0gQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQ7XG5cbn0pKCk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiQ29tbW9uIiwiX2Jhc2VEZWx0YSIsIl9uZXh0SWQiLCJfc2VlZCIsIl9ub3dTdGFydFRpbWUiLCJEYXRlIiwiX3dhcm5lZE9uY2UiLCJfZGVjb21wIiwiZXh0ZW5kIiwib2JqIiwiZGVlcCIsImFyZ3NTdGFydCIsImFyZ3MiLCJkZWVwQ2xvbmUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJwcm9wIiwiY29uc3RydWN0b3IiLCJjbG9uZSIsImtleXMiLCJwdXNoIiwidmFsdWVzIiwicGF0aCIsImJlZ2luIiwiZW5kIiwic3BsaXQiLCJzbGljZSIsInNldCIsInZhbCIsInBhcnRzIiwic2h1ZmZsZSIsImFycmF5IiwiaiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRlbXAiLCJjaG9vc2UiLCJjaG9pY2VzIiwiaXNFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJub2RlVHlwZSIsIm5vZGVOYW1lIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiaXNGdW5jdGlvbiIsImlzUGxhaW5PYmplY3QiLCJpc1N0cmluZyIsImNsYW1wIiwibWluIiwibWF4Iiwic2lnbiIsIm5vdyIsIndpbmRvdyIsInBlcmZvcm1hbmNlIiwid2Via2l0Tm93IiwiX3NlZWRlZFJhbmRvbSIsImNvbG9yVG9OdW1iZXIiLCJjb2xvclN0cmluZyIsInJlcGxhY2UiLCJjaGFyQXQiLCJwYXJzZUludCIsImxvZ0xldmVsIiwibG9nIiwiY29uc29sZSIsImFwcGx5IiwiY29uY2F0IiwiQXJyYXkiLCJpbmZvIiwid2FybiIsIndhcm5PbmNlIiwibWVzc2FnZSIsImpvaW4iLCJkZXByZWNhdGVkIiwid2FybmluZyIsImNoYWluIiwibmV4dElkIiwiaW5kZXhPZiIsImhheXN0YWNrIiwibmVlZGxlIiwibWFwIiwibGlzdCIsImZ1bmMiLCJtYXBwZWQiLCJ0b3BvbG9naWNhbFNvcnQiLCJncmFwaCIsInJlc3VsdCIsInZpc2l0ZWQiLCJub2RlIiwiX3RvcG9sb2dpY2FsU29ydCIsIm5laWdoYm9ycyIsIm5laWdoYm9yIiwiZnVuY3MiLCJfY2hhaW5lZCIsImxhc3RSZXN1bHQiLCJjaGFpblBhdGhCZWZvcmUiLCJiYXNlIiwiY2hhaW5QYXRoQWZ0ZXIiLCJzZXREZWNvbXAiLCJkZWNvbXAiLCJnZXREZWNvbXAiLCJnbG9iYWwiLCJlIiwiQm91bmRzIiwidmVydGljZXMiLCJib3VuZHMiLCJ4IiwieSIsInVwZGF0ZSIsInZlbG9jaXR5IiwiSW5maW5pdHkiLCJ2ZXJ0ZXgiLCJjb250YWlucyIsInBvaW50Iiwib3ZlcmxhcHMiLCJib3VuZHNBIiwiYm91bmRzQiIsInRyYW5zbGF0ZSIsInZlY3RvciIsInNoaWZ0IiwicG9zaXRpb24iLCJkZWx0YVgiLCJkZWx0YVkiLCJWZWN0b3IiLCJtYWduaXR1ZGUiLCJzcXJ0IiwibWFnbml0dWRlU3F1YXJlZCIsInJvdGF0ZSIsImFuZ2xlIiwib3V0cHV0IiwiY29zIiwic2luIiwicm90YXRlQWJvdXQiLCJub3JtYWxpc2UiLCJkb3QiLCJ2ZWN0b3JBIiwidmVjdG9yQiIsImNyb3NzIiwiY3Jvc3MzIiwidmVjdG9yQyIsImFkZCIsInN1YiIsIm11bHQiLCJzY2FsYXIiLCJkaXYiLCJwZXJwIiwibmVnYXRlIiwibmVnIiwiYXRhbjIiLCJfdGVtcCIsIlZlcnRpY2VzIiwicG9pbnRzIiwiYm9keSIsImluZGV4IiwiaXNJbnRlcm5hbCIsImZyb21QYXRoIiwicGF0aFBhdHRlcm4iLCJtYXRjaCIsInBhcnNlRmxvYXQiLCJjZW50cmUiLCJhcmVhIiwibWVhbiIsImF2ZXJhZ2UiLCJzaWduZWQiLCJhYnMiLCJpbmVydGlhIiwibWFzcyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwidiIsInZlcnRpY2VzTGVuZ3RoIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJwb2ludFgiLCJwb2ludFkiLCJkeCIsImR5IiwibmV4dFZlcnRleCIsInNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiZGVsdGEiLCJjaGFtZmVyIiwicmFkaXVzIiwicXVhbGl0eSIsInF1YWxpdHlNaW4iLCJxdWFsaXR5TWF4IiwibmV3VmVydGljZXMiLCJwcmV2VmVydGV4IiwiY3VycmVudFJhZGl1cyIsInByZXZOb3JtYWwiLCJuZXh0Tm9ybWFsIiwiZGlhZ29uYWxSYWRpdXMiLCJwb3ciLCJyYWRpdXNWZWN0b3IiLCJtaWROb3JtYWwiLCJzY2FsZWRWZXJ0ZXgiLCJwcmVjaXNpb24iLCJhbHBoYSIsImFjb3MiLCJ0aGV0YSIsImNsb2Nrd2lzZVNvcnQiLCJzb3J0IiwidmVydGV4QSIsInZlcnRleEIiLCJpc0NvbnZleCIsImZsYWciLCJrIiwieiIsImh1bGwiLCJ1cHBlciIsImxvd2VyIiwicG9wIiwiQm9keSIsIlNsZWVwaW5nIiwiQXhlcyIsIl90aW1lQ29ycmVjdGlvbiIsIl9pbmVydGlhU2NhbGUiLCJfbmV4dENvbGxpZGluZ0dyb3VwSWQiLCJfbmV4dE5vbkNvbGxpZGluZ0dyb3VwSWQiLCJfbmV4dENhdGVnb3J5Iiwib3B0aW9ucyIsImRlZmF1bHRzIiwiaWQiLCJ0eXBlIiwibGFiZWwiLCJwbHVnaW4iLCJmb3JjZSIsInRvcnF1ZSIsInBvc2l0aW9uSW1wdWxzZSIsImNvbnN0cmFpbnRJbXB1bHNlIiwidG90YWxDb250YWN0cyIsInNwZWVkIiwiYW5ndWxhclNwZWVkIiwiYW5ndWxhclZlbG9jaXR5IiwiaXNTZW5zb3IiLCJpc1N0YXRpYyIsImlzU2xlZXBpbmciLCJtb3Rpb24iLCJzbGVlcFRocmVzaG9sZCIsImRlbnNpdHkiLCJyZXN0aXR1dGlvbiIsImZyaWN0aW9uIiwiZnJpY3Rpb25TdGF0aWMiLCJmcmljdGlvbkFpciIsImNvbGxpc2lvbkZpbHRlciIsImNhdGVnb3J5IiwibWFzayIsImdyb3VwIiwic2xvcCIsInRpbWVTY2FsZSIsInJlbmRlciIsInZpc2libGUiLCJvcGFjaXR5Iiwic3Ryb2tlU3R5bGUiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJzcHJpdGUiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImV2ZW50cyIsImNpcmNsZVJhZGl1cyIsInBvc2l0aW9uUHJldiIsImFuZ2xlUHJldiIsInBhcmVudCIsImF4ZXMiLCJkZWx0YVRpbWUiLCJfb3JpZ2luYWwiLCJfaW5pdFByb3BlcnRpZXMiLCJuZXh0R3JvdXAiLCJpc05vbkNvbGxpZGluZyIsIm5leHRDYXRlZ29yeSIsImRlZmF1bHRGaWxsU3R5bGUiLCJkZWZhdWx0U3Ryb2tlU3R5bGUiLCJkZWZhdWx0TGluZVdpZHRoIiwic2V0dGluZ3MiLCJzZXRTdGF0aWMiLCJzZXRNYXNzIiwic2V0RGVuc2l0eSIsInNldEluZXJ0aWEiLCJzZXRWZXJ0aWNlcyIsInNldFBvc2l0aW9uIiwic2V0QW5nbGUiLCJzZXRWZWxvY2l0eSIsInNldEFuZ3VsYXJWZWxvY2l0eSIsInNldFNwZWVkIiwic2V0QW5ndWxhclNwZWVkIiwic2V0UGFydHMiLCJzZXRDZW50cmUiLCJwYXJ0IiwiaW52ZXJzZU1hc3MiLCJpbnZlcnNlSW5lcnRpYSIsIm1vbWVudCIsImZyb21WZXJ0aWNlcyIsImF1dG9IdWxsIiwiaHVsbENlbnRyZSIsInRvdGFsIiwiX3RvdGFsUHJvcGVydGllcyIsInJlbGF0aXZlIiwidXBkYXRlVmVsb2NpdHkiLCJnZXRWZWxvY2l0eSIsImdldFNwZWVkIiwiZ2V0QW5ndWxhclZlbG9jaXR5IiwiZ2V0QW5ndWxhclNwZWVkIiwidHJhbnNsYXRpb24iLCJyb3RhdGlvbiIsInRvdGFsQXJlYSIsInRvdGFsSW5lcnRpYSIsImRlbHRhVGltZVNxdWFyZWQiLCJjb3JyZWN0aW9uIiwidmVsb2NpdHlQcmV2WCIsInZlbG9jaXR5UHJldlkiLCJ1cGRhdGVWZWxvY2l0aWVzIiwiYm9keVZlbG9jaXR5IiwiYXBwbHlGb3JjZSIsIm9mZnNldCIsInByb3BlcnRpZXMiLCJFdmVudHMiLCJvbiIsImV2ZW50TmFtZXMiLCJjYWxsYmFjayIsIm5hbWVzIiwib2ZmIiwiY2FsbGJhY2tzIiwibmV3Q2FsbGJhY2tzIiwidHJpZ2dlciIsImV2ZW50IiwiZXZlbnRDbG9uZSIsIkNvbXBvc2l0ZSIsImlzTW9kaWZpZWQiLCJib2RpZXMiLCJjb25zdHJhaW50cyIsImNvbXBvc2l0ZXMiLCJjYWNoZSIsImFsbEJvZGllcyIsImFsbENvbnN0cmFpbnRzIiwiYWxsQ29tcG9zaXRlcyIsInNldE1vZGlmaWVkIiwiY29tcG9zaXRlIiwidXBkYXRlUGFyZW50cyIsInVwZGF0ZUNoaWxkcmVuIiwiY2hpbGRDb21wb3NpdGUiLCJvYmplY3RzIiwiYWRkQm9keSIsImFkZENvbnN0cmFpbnQiLCJhZGRDb21wb3NpdGUiLCJjb25zdHJhaW50IiwicmVtb3ZlIiwicmVtb3ZlQm9keSIsInJlbW92ZUNvbnN0cmFpbnQiLCJyZW1vdmVDb21wb3NpdGUiLCJjb21wb3NpdGVBIiwiY29tcG9zaXRlQiIsInJlbW92ZUNvbXBvc2l0ZUF0Iiwic2xlZXBDb3VudGVyIiwic3BsaWNlIiwicmVtb3ZlQm9keUF0IiwicmVtb3ZlQ29uc3RyYWludEF0IiwiY2xlYXIiLCJrZWVwU3RhdGljIiwiZmlsdGVyIiwibW92ZSIsInJlYmFzZSIsInJlY3Vyc2l2ZSIsIl9tb3Rpb25XYWtlVGhyZXNob2xkIiwiX21vdGlvblNsZWVwVGhyZXNob2xkIiwiX21pbkJpYXMiLCJtb3Rpb25TbGVlcFRocmVzaG9sZCIsIm1pbk1vdGlvbiIsIm1heE1vdGlvbiIsImFmdGVyQ29sbGlzaW9ucyIsInBhaXJzIiwicGFpciIsImlzQWN0aXZlIiwiY29sbGlzaW9uIiwiYm9keUEiLCJib2R5QiIsInNsZWVwaW5nQm9keSIsIm1vdmluZ0JvZHkiLCJ3YXNTbGVlcGluZyIsIkNvbGxpc2lvbiIsIlBhaXIiLCJfc3VwcG9ydHMiLCJfb3ZlcmxhcEFCIiwib3ZlcmxhcCIsImF4aXMiLCJfb3ZlcmxhcEJBIiwiY29sbGlkZWQiLCJwYXJlbnRBIiwicGFyZW50QiIsImRlcHRoIiwibm9ybWFsIiwidGFuZ2VudCIsInBlbmV0cmF0aW9uIiwic3VwcG9ydHMiLCJzdXBwb3J0Q291bnQiLCJjb2xsaWRlcyIsIl9vdmVybGFwQXhlcyIsInRhYmxlIiwibWluT3ZlcmxhcCIsIm1pbkF4aXMiLCJub3JtYWxYIiwibm9ybWFsWSIsInN1cHBvcnRzQiIsIl9maW5kU3VwcG9ydHMiLCJzdXBwb3J0c0EiLCJ2ZXJ0aWNlc0EiLCJ2ZXJ0aWNlc0IiLCJ2ZXJ0aWNlc0FMZW5ndGgiLCJ2ZXJ0aWNlc0JMZW5ndGgiLCJ2ZXJ0aWNlc0FYIiwidmVydGljZXNBWSIsInZlcnRpY2VzQlgiLCJ2ZXJ0aWNlc0JZIiwiYXhlc0xlbmd0aCIsIm92ZXJsYXBNaW4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJvdmVybGFwQXhpc051bWJlciIsIm92ZXJsYXBBQiIsIm92ZXJsYXBCQSIsImF4aXNYIiwiYXhpc1kiLCJtaW5BIiwibWluQiIsIm1heEEiLCJtYXhCIiwiZGlyZWN0aW9uIiwiYm9keUFQb3NpdGlvblgiLCJib2R5QVBvc2l0aW9uWSIsIm5lYXJlc3REaXN0YW5jZSIsInZlcnRleEMiLCJkaXN0YW5jZSIsIkNvbnRhY3QiLCJ0aW1lc3RhbXAiLCJjb250YWN0cyIsImNvbnRhY3RDb3VudCIsInNlcGFyYXRpb24iLCJ0aW1lQ3JlYXRlZCIsInRpbWVVcGRhdGVkIiwic3VwcG9ydEEiLCJjb250YWN0QSIsInN1cHBvcnRCIiwiY29udGFjdEIiLCJzZXRBY3RpdmUiLCJDb25zdHJhaW50IiwiX3dhcm1pbmciLCJfdG9ycXVlRGFtcGVuIiwiX21pbkxlbmd0aCIsInBvaW50QSIsInBvaW50QiIsImluaXRpYWxQb2ludEEiLCJpbml0aWFsUG9pbnRCIiwic3RpZmZuZXNzIiwiZGFtcGluZyIsImFuZ3VsYXJTdGlmZm5lc3MiLCJhbmdsZUEiLCJhbmdsZUIiLCJhbmNob3JzIiwicHJlU29sdmVBbGwiLCJpbXB1bHNlIiwic29sdmVBbGwiLCJmaXhlZEEiLCJmaXhlZEIiLCJzb2x2ZSIsInBvaW50QVdvcmxkIiwicG9pbnRCV29ybGQiLCJjdXJyZW50TGVuZ3RoIiwiZGlmZmVyZW5jZSIsImlzUmlnaWQiLCJtYXNzVG90YWwiLCJpbmVydGlhVG90YWwiLCJyZXNpc3RhbmNlVG90YWwiLCJzaGFyZSIsIm5vcm1hbFZlbG9jaXR5IiwicmVsYXRpdmVWZWxvY2l0eSIsInplcm8iLCJwb3N0U29sdmVBbGwiLCJwb2ludEFYIiwicG9pbnRBWSIsInBvaW50QlgiLCJwb2ludEJZIiwiZ3JhZGllbnQiLCJ0b0ZpeGVkIiwieHgiLCJCb2RpZXMiLCJyZWN0YW5nbGUiLCJ3aWR0aCIsImhlaWdodCIsInRyYXBlem9pZCIsInNsb3BlIiwicm9vZiIsIngxIiwieDIiLCJ4MyIsInZlcnRpY2VzUGF0aCIsImNpcmNsZSIsIm1heFNpZGVzIiwic2lkZXMiLCJjZWlsIiwicG9seWdvbiIsIlBJIiwieXkiLCJ2ZXJ0ZXhTZXRzIiwiZmxhZ0ludGVybmFsIiwicmVtb3ZlQ29sbGluZWFyIiwibWluaW11bUFyZWEiLCJyZW1vdmVEdXBsaWNhdGVQb2ludHMiLCJjYW5EZWNvbXAiLCJpc0NvbmNhdmUiLCJCb29sZWFuIiwicXVpY2tEZWNvbXAiLCJjb25jYXZlIiwibWFrZUNDVyIsInJlbW92ZUNvbGxpbmVhclBvaW50cyIsImRlY29tcG9zZWQiLCJjaHVuayIsImNodW5rVmVydGljZXMiLCJjb2luY2lkZW50X21heF9kaXN0IiwicGFydEEiLCJwYXJ0QiIsInBhdiIsInBidiIsImRhIiwiZGIiLCJEZXRlY3RvciIsImNvbGxpc2lvbnMiLCJzZXRCb2RpZXMiLCJkZXRlY3RvciIsImJvZGllc0xlbmd0aCIsImNhbkNvbGxpZGUiLCJjb2xsaXNpb25JbmRleCIsIl9jb21wYXJlQm91bmRzWCIsImJvdW5kWE1heCIsImJvdW5kWU1heCIsImJvdW5kWU1pbiIsImJvZHlBU3RhdGljIiwicGFydHNBTGVuZ3RoIiwicGFydHNBU2luZ2xlIiwicGFydHNCTGVuZ3RoIiwicGFydHNBU3RhcnQiLCJwYXJ0c0JTdGFydCIsImZpbHRlckEiLCJmaWx0ZXJCIiwiTW91c2UiLCJlbGVtZW50IiwibW91c2UiLCJkb2N1bWVudCIsImFic29sdXRlIiwibW91c2Vkb3duUG9zaXRpb24iLCJtb3VzZXVwUG9zaXRpb24iLCJ3aGVlbERlbHRhIiwiYnV0dG9uIiwicGl4ZWxSYXRpbyIsImdldEF0dHJpYnV0ZSIsInNvdXJjZUV2ZW50cyIsIm1vdXNlbW92ZSIsIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZXdoZWVsIiwiX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbiIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsInByZXZlbnREZWZhdWx0IiwiZGV0YWlsIiwic2V0RWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYXJTb3VyY2VFdmVudHMiLCJzZXRPZmZzZXQiLCJzZXRTY2FsZSIsImVsZW1lbnRCb3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyb290Tm9kZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJzY3JvbGxYIiwicGFnZVhPZmZzZXQiLCJ1bmRlZmluZWQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVgiLCJsZWZ0IiwicGFnZVkiLCJ0b3AiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIlBsdWdpbiIsIl9yZWdpc3RyeSIsInJlZ2lzdGVyIiwiaXNQbHVnaW4iLCJyZWdpc3RlcmVkIiwicGx1Z2luVmVyc2lvbiIsInZlcnNpb25QYXJzZSIsInZlcnNpb24iLCJudW1iZXIiLCJyZWdpc3RlcmVkVmVyc2lvbiIsInJlc29sdmUiLCJkZXBlbmRlbmN5IiwiZGVwZW5kZW5jeVBhcnNlIiwicmFuZ2UiLCJpbnN0YWxsIiwiaXNVc2VkIiwidXNlZCIsImlzRm9yIiwicGFyc2VkIiwiZm9yIiwidmVyc2lvblNhdGlzZmllcyIsInVzZSIsInBsdWdpbnMiLCJ1c2VzIiwiZGVwZW5kZW5jaWVzIiwic29ydGVkRGVwZW5kZW5jaWVzIiwic3RhdHVzIiwiX3dhcm5lZCIsInRyYWNrZWQiLCJwYXJzZWRCYXNlIiwicmVzb2x2ZWQiLCJwYXR0ZXJuIiwidGVzdCIsImV4ZWMiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJpc1JhbmdlIiwib3BlcmF0b3IiLCJwcmVyZWxlYXNlIiwibm9ybWFsSW1wdWxzZSIsInRhbmdlbnRJbXB1bHNlIiwiRW5naW5lIiwiUmVzb2x2ZXIiLCJQYWlycyIsIl9kZWx0YU1heCIsInBvc2l0aW9uSXRlcmF0aW9ucyIsInZlbG9jaXR5SXRlcmF0aW9ucyIsImNvbnN0cmFpbnRJdGVyYXRpb25zIiwiZW5hYmxlU2xlZXBpbmciLCJncmF2aXR5IiwidGltaW5nIiwibGFzdERlbHRhIiwibGFzdEVsYXBzZWQiLCJsYXN0VXBkYXRlc1BlckZyYW1lIiwiZW5naW5lIiwid29ybGQiLCJncmlkIiwiYnVja2V0cyIsImJyb2FkcGhhc2UiLCJtZXRyaWNzIiwic3RhcnRUaW1lIiwiX2JvZGllc0FwcGx5R3Jhdml0eSIsIl9ib2RpZXNVcGRhdGUiLCJjb2xsaXNpb25TdGFydCIsInBvc2l0aW9uRGFtcGluZyIsInByZVNvbHZlUG9zaXRpb24iLCJzb2x2ZVBvc2l0aW9uIiwicG9zdFNvbHZlUG9zaXRpb24iLCJwcmVTb2x2ZVZlbG9jaXR5Iiwic29sdmVWZWxvY2l0eSIsIl9ib2RpZXNVcGRhdGVWZWxvY2l0aWVzIiwiY29sbGlzaW9uQWN0aXZlIiwiY29sbGlzaW9uRW5kIiwiX2JvZGllc0NsZWFyRm9yY2VzIiwibWVyZ2UiLCJlbmdpbmVBIiwiZW5naW5lQiIsImdyYXZpdHlTY2FsZSIsIl9yZXN0aW5nVGhyZXNoIiwiX3Jlc3RpbmdUaHJlc2hUYW5nZW50IiwiX3Bvc2l0aW9uRGFtcGVuIiwiX3Bvc2l0aW9uV2FybWluZyIsIl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIiLCJfZnJpY3Rpb25NYXhTdGF0aWMiLCJwYWlyc0xlbmd0aCIsImNvbnRhY3RTaGFyZSIsInBvc2l0aW9uRGFtcGVuIiwic2xvcERhbXBlbiIsInBvc2l0aW9uV2FybWluZyIsInZlcnRpY2VzVHJhbnNsYXRlIiwiYm91bmRzVXBkYXRlIiwicG9zaXRpb25JbXB1bHNlWCIsInBvc2l0aW9uSW1wdWxzZVkiLCJjb250YWN0IiwiY29udGFjdFZlcnRleCIsImltcHVsc2VYIiwiaW1wdWxzZVkiLCJ0aW1lU2NhbGVTcXVhcmVkIiwidGltZVNjYWxlQ3ViZWQiLCJyZXN0aW5nVGhyZXNoIiwicmVzdGluZ1RocmVzaFRhbmdlbnQiLCJmcmljdGlvbk5vcm1hbE11bHRpcGxpZXIiLCJmcmljdGlvbk1heFN0YXRpYyIsIm1heEZyaWN0aW9uIiwidGFuZ2VudFgiLCJ0YW5nZW50WSIsImludmVyc2VNYXNzVG90YWwiLCJib2R5QVZlbG9jaXR5WCIsImJvZHlBVmVsb2NpdHlZIiwiYm9keUFBbmd1bGFyVmVsb2NpdHkiLCJib2R5QlZlbG9jaXR5WCIsImJvZHlCVmVsb2NpdHlZIiwiYm9keUJBbmd1bGFyVmVsb2NpdHkiLCJvZmZzZXRBWCIsIm9mZnNldEFZIiwib2Zmc2V0QlgiLCJvZmZzZXRCWSIsInZlbG9jaXR5UG9pbnRBWCIsInZlbG9jaXR5UG9pbnRBWSIsInZlbG9jaXR5UG9pbnRCWCIsInZlbG9jaXR5UG9pbnRCWSIsInJlbGF0aXZlVmVsb2NpdHlYIiwicmVsYXRpdmVWZWxvY2l0eVkiLCJ0YW5nZW50VmVsb2NpdHkiLCJub3JtYWxPdmVybGFwIiwibm9ybWFsRm9yY2UiLCJmcmljdGlvbkxpbWl0Iiwib0FjTiIsIm9CY04iLCJjb250YWN0Tm9ybWFsSW1wdWxzZSIsImNvbnRhY3RUYW5nZW50SW1wdWxzZSIsInBhaXJVcGRhdGUiLCJwYWlyQ3JlYXRlIiwicGFpclNldEFjdGl2ZSIsInBhaXJzVGFibGUiLCJwYWlyc0xpc3QiLCJwYWlyc0xpc3RMZW5ndGgiLCJwYWlyc0xpc3RJbmRleCIsImNvbGxpc2lvbnNMZW5ndGgiLCJjb2xsaXNpb25TdGFydEluZGV4IiwiY29sbGlzaW9uRW5kSW5kZXgiLCJjb2xsaXNpb25BY3RpdmVJbmRleCIsIk1hdHRlciIsIkNvbXBvc2l0ZXMiLCJHcmlkIiwiTW91c2VDb25zdHJhaW50IiwiUXVlcnkiLCJSZW5kZXIiLCJSdW5uZXIiLCJTQVQiLCJTdmciLCJXb3JsZCIsInJ1biIsImJlZm9yZSIsImFmdGVyIiwic3RhY2siLCJjb2x1bW5zIiwicm93cyIsImNvbHVtbkdhcCIsInJvd0dhcCIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJsYXN0Qm9keSIsInJvdyIsIm1heEhlaWdodCIsImNvbHVtbiIsImJvZHlIZWlnaHQiLCJib2R5V2lkdGgiLCJ4T2Zmc2V0QSIsInlPZmZzZXRBIiwieE9mZnNldEIiLCJ5T2Zmc2V0QiIsImJvZHlBSGVpZ2h0IiwiYm9keUFXaWR0aCIsImJvZHlCSGVpZ2h0IiwiYm9keUJXaWR0aCIsIm1lc2giLCJjcm9zc0JyYWNlIiwiY29sIiwiYm9keUMiLCJweXJhbWlkIiwic3RhY2tYIiwic3RhY2tZIiwiYWN0dWFsUm93cyIsImxhc3RCb2R5V2lkdGgiLCJzdGFydCIsIm5ld3RvbnNDcmFkbGUiLCJzaXplIiwiY2FyIiwid2hlZWxTaXplIiwid2hlZWxCYXNlIiwid2hlZWxBT2Zmc2V0Iiwid2hlZWxCT2Zmc2V0Iiwid2hlZWxZT2Zmc2V0Iiwid2hlZWxBIiwid2hlZWxCIiwiYXhlbEEiLCJheGVsQiIsInNvZnRCb2R5IiwicGFydGljbGVSYWRpdXMiLCJwYXJ0aWNsZU9wdGlvbnMiLCJjb25zdHJhaW50T3B0aW9ucyIsImJ1Y2tldFdpZHRoIiwiYnVja2V0SGVpZ2h0IiwiZm9yY2VVcGRhdGUiLCJidWNrZXQiLCJidWNrZXRJZCIsImdyaWRDaGFuZ2VkIiwibmV3UmVnaW9uIiwiX2dldFJlZ2lvbiIsInJlZ2lvbiIsInVuaW9uIiwiX3JlZ2lvblVuaW9uIiwic3RhcnRDb2wiLCJlbmRDb2wiLCJzdGFydFJvdyIsImVuZFJvdyIsIl9nZXRCdWNrZXRJZCIsImlzSW5zaWRlTmV3UmVnaW9uIiwiaXNJbnNpZGVPbGRSZWdpb24iLCJfYnVja2V0UmVtb3ZlQm9keSIsIl9jcmVhdGVCdWNrZXQiLCJfYnVja2V0QWRkQm9keSIsIl9jcmVhdGVBY3RpdmVQYWlyc0xpc3QiLCJyZWdpb25BIiwicmVnaW9uQiIsIl9jcmVhdGVSZWdpb24iLCJncmlkUGFpcnMiLCJwYWlySWQiLCJidWNrZXRMZW5ndGgiLCJwYWlyS2V5cyIsInBhaXJLZXlzTGVuZ3RoIiwiY2FudmFzIiwibW91c2VDb25zdHJhaW50IiwiX3RyaWdnZXJFdmVudHMiLCJtb3VzZUV2ZW50cyIsInJheSIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInJheVdpZHRoIiwicmF5QW5nbGUiLCJyYXlMZW5ndGgiLCJyYXlYIiwicmF5WSIsIm91dHNpZGUiLCJfcmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX2NhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtb3pDYW5jZWxBbmltYXRpb25GcmFtZSIsIndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIiwibXNDYW5jZWxBbmltYXRpb25GcmFtZSIsIl9nb29kRnBzIiwiX2dvb2REZWx0YSIsImZyYW1lUmVxdWVzdElkIiwiaGlzdG9yeVNpemUiLCJkZWx0YUhpc3RvcnkiLCJsYXN0VGltZSIsImxhc3RUaW1lc3RhbXAiLCJ0aW1lc3RhbXBFbGFwc2VkIiwidGltZXN0YW1wRWxhcHNlZEhpc3RvcnkiLCJlbmdpbmVEZWx0YUhpc3RvcnkiLCJlbmdpbmVFbGFwc2VkSGlzdG9yeSIsImVuZ2luZVVwZGF0ZXNIaXN0b3J5IiwiZWxhcHNlZEhpc3RvcnkiLCJiYWNrZ3JvdW5kIiwid2lyZWZyYW1lQmFja2dyb3VuZCIsIndpcmVmcmFtZVN0cm9rZVN0eWxlIiwiaGFzQm91bmRzIiwiZW5hYmxlZCIsIndpcmVmcmFtZXMiLCJzaG93U2xlZXBpbmciLCJzaG93RGVidWciLCJzaG93U3RhdHMiLCJzaG93UGVyZm9ybWFuY2UiLCJzaG93Qm91bmRzIiwic2hvd1ZlbG9jaXR5Iiwic2hvd0NvbGxpc2lvbnMiLCJzaG93U2VwYXJhdGlvbnMiLCJzaG93QXhlcyIsInNob3dQb3NpdGlvbnMiLCJzaG93QW5nbGVJbmRpY2F0b3IiLCJzaG93SWRzIiwic2hvd1ZlcnRleE51bWJlcnMiLCJzaG93Q29udmV4SHVsbHMiLCJzaG93SW50ZXJuYWxFZGdlcyIsInNob3dNb3VzZVBvc2l0aW9uIiwiX2NyZWF0ZUNhbnZhcyIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwidGV4dHVyZXMiLCJjb250cm9sbGVyIiwic2hvd0Jyb2FkcGhhc2UiLCJzZXRQaXhlbFJhdGlvIiwiYXBwZW5kQ2hpbGQiLCJsb29wIiwidGltZSIsIl91cGRhdGVUaW1pbmciLCJzZXRUcmFuc2Zvcm0iLCJzdGF0cyIsInN0b3AiLCJfZ2V0UGl4ZWxSYXRpbyIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwic2V0U2l6ZSIsImxvb2tBdCIsInBhZGRpbmciLCJjZW50ZXIiLCJ2aWV3SGVpZ2h0Iiwidmlld1dpZHRoIiwib3V0ZXJSYXRpbyIsImlubmVyUmF0aW8iLCJzdGFydFZpZXdUcmFuc2Zvcm0iLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsImJvdW5kc1NjYWxlWCIsImJvdW5kc1NjYWxlWSIsImVuZFZpZXdUcmFuc2Zvcm0iLCJjdXJyZW50QmFja2dyb3VuZCIsIl9hcHBseUJhY2tncm91bmQiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJmaWxsUmVjdCIsImJvZHlDb252ZXhIdWxscyIsImJvZHlXaXJlZnJhbWVzIiwiYm9keUJvdW5kcyIsImJvZHlBeGVzIiwiYm9keVBvc2l0aW9ucyIsImJvZHlJZHMiLCJzZXBhcmF0aW9ucyIsInZlcnRleE51bWJlcnMiLCJtb3VzZVBvc2l0aW9uIiwic2VjdGlvbnMiLCJmb250IiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwic2VjdGlvbiIsImZpbGxUZXh0IiwibGFzdEVuZ2luZVVwZGF0ZXNQZXJGcmFtZSIsImxhc3RFbmdpbmVEZWx0YSIsImRlbHRhTWVhbiIsIl9tZWFuIiwiZWxhcHNlZE1lYW4iLCJlbmdpbmVEZWx0YU1lYW4iLCJlbmdpbmVVcGRhdGVzTWVhbiIsImVuZ2luZUVsYXBzZWRNZWFuIiwidGltZXN0YW1wRWxhcHNlZE1lYW4iLCJyYXRlTWVhbiIsIm5lZWRlZFVwZGF0ZXNQZXJGcmFtZSIsInJvdW5kIiwiZnBzIiwiZ3JhcGhIZWlnaHQiLCJnYXAiLCJjb3VudCIsImluZGljYXRvciIsInBsb3RZIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiYXJjIiwiY2xvc2VQYXRoIiwiY29pbHMiLCJmaWxsIiwiZ2xvYmFsQWxwaGEiLCJ0ZXh0dXJlIiwiX2dldFRleHR1cmUiLCJkcmF3SW1hZ2UiLCJyZWN0IiwiY29ycmVjdGVkIiwibm9ybWFsUG9zWCIsIm5vcm1hbFBvc1kiLCJpbnNwZWN0b3IiLCJzZWxlY3RlZCIsIml0ZW0iLCJkYXRhIiwic2V0TGluZURhc2giLCJzZWxlY3RTdGFydCIsInNlbGVjdEJvdW5kcyIsInVuc2hpZnQiLCJjcmVhdGVFbGVtZW50Iiwib25jb250ZXh0bWVudSIsIm9uc2VsZWN0c3RhcnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwibXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwib0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJpbWFnZVBhdGgiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwiY3NzQmFja2dyb3VuZCIsImJhY2tncm91bmRTaXplIiwiX21heEZyYW1lRGVsdGEiLCJfZnJhbWVEZWx0YUZhbGxiYWNrIiwiX3RpbWVCdWZmZXJNYXJnaW4iLCJfZWxhcHNlZE5leHRFc3RpbWF0ZSIsIl9zbW9vdGhpbmdMb3dlckJvdW5kIiwiX3Ntb290aGluZ1VwcGVyQm91bmQiLCJmcmFtZURlbHRhIiwiZnJhbWVEZWx0YVNtb290aGluZyIsImZyYW1lRGVsdGFTbmFwcGluZyIsImZyYW1lRGVsdGFIaXN0b3J5IiwiZnJhbWVEZWx0YUhpc3RvcnlTaXplIiwidGltZUJ1ZmZlciIsInRpbWVMYXN0VGljayIsIm1heFVwZGF0ZXMiLCJtYXhGcmFtZVRpbWUiLCJsYXN0VXBkYXRlc0RlZmVycmVkIiwicnVubmVyIiwib25GcmFtZSIsIl9vbk5leHRGcmFtZSIsInRpY2siLCJ0aWNrU3RhcnRUaW1lIiwiZW5naW5lRGVsdGEiLCJ1cGRhdGVDb3VudCIsImRlbHRhSGlzdG9yeVNvcnRlZCIsImRlbHRhSGlzdG9yeVdpbmRvdyIsImZyYW1lRGVsdGFTbW9vdGhlZCIsInVwZGF0ZVN0YXJ0VGltZSIsImVsYXBzZWRUaW1lVG90YWwiLCJlbGFwc2VkVGltZVVwZGF0ZXMiLCJlbGFwc2VkTmV4dEVzdGltYXRlIiwiaXNGaXhlZCIsImRlbHRhTWluIiwiZGVsdGFNYXgiLCJfY2FuY2VsTmV4dEZyYW1lIiwiRXJyb3IiLCJ2YWx1ZXNMZW5ndGgiLCJwYXRoVG9WZXJ0aWNlcyIsInNhbXBsZUxlbmd0aCIsImlsIiwic2VnbWVudCIsInNlZ21lbnRzIiwic2VnbWVudHNRdWV1ZSIsImxhc3RTZWdtZW50IiwibGFzdFBvaW50Iiwic2VnbWVudEluZGV4IiwibHgiLCJseSIsImFkZFBvaW50IiwicHgiLCJweSIsInBhdGhTZWdUeXBlIiwiaXNSZWxhdGl2ZSIsImFkZFNlZ21lbnRQb2ludCIsInNlZ1R5cGUiLCJwYXRoU2VnVHlwZUFzTGV0dGVyIiwidG9VcHBlckNhc2UiLCJfc3ZnUGF0aFRvQWJzb2x1dGUiLCJnZXRUb3RhbExlbmd0aCIsInBhdGhTZWdMaXN0IiwibnVtYmVyT2ZJdGVtcyIsImdldEl0ZW0iLCJnZXRQYXRoU2VnQXRMZW5ndGgiLCJnZXRQb2ludEF0TGVuZ3RoIiwieDAiLCJ5MCIsInkxIiwieTIiLCJzZWdzIiwibGVuIiwic2VnIiwicmVwbGFjZUl0ZW0iLCJjcmVhdGVTVkdQYXRoU2VnTW92ZXRvQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0FicyIsImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FicyIsImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMiLCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0FicyIsImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0FyY0FicyIsInIxIiwicjIiLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/matter-js/build/matter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/Animations/FallingText.tsx":
/*!****************************************!*\
  !*** ./src/Animations/FallingText.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! matter-js */ \"(app-pages-browser)/./node_modules/matter-js/build/matter.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(matter_js__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst FallingText = (param)=>{\n    let { text = \"\", highlightWords = [], trigger = \"auto\", backgroundColor = \"transparent\", wireframes = false, gravity = 1, mouseConstraintStiffness = 0.2, fontSize = \"1rem\" } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const textRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [effectStarted, setEffectStarted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!textRef.current) return;\n        const words = text.split(\" \");\n        const newHTML = words.map((word)=>{\n            const isHighlighted = highlightWords.some((hw)=>word.startsWith(hw));\n            return '<span\\n          class=\"inline-block mx-[2px] select-none '.concat(isHighlighted ? \"text-cyan-500 font-bold\" : \"\", '\"\\n        >\\n          ').concat(word, \"\\n        </span>\");\n        }).join(\" \");\n        textRef.current.innerHTML = newHTML;\n    }, [\n        text,\n        highlightWords\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (trigger === \"auto\") {\n            setEffectStarted(true);\n            return;\n        }\n        if (trigger === \"scroll\" && containerRef.current) {\n            const observer = new IntersectionObserver((param)=>{\n                let [entry] = param;\n                if (entry.isIntersecting) {\n                    setEffectStarted(true);\n                    observer.disconnect();\n                }\n            }, {\n                threshold: 0.1\n            });\n            observer.observe(containerRef.current);\n            return ()=>observer.disconnect();\n        }\n    }, [\n        trigger\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!effectStarted) return;\n        const { Engine, Render, World, Bodies, Runner, Mouse, MouseConstraint } = (matter_js__WEBPACK_IMPORTED_MODULE_2___default());\n        if (!containerRef.current || !canvasContainerRef.current) return;\n        const containerRect = containerRef.current.getBoundingClientRect();\n        const width = containerRect.width;\n        const height = containerRect.height;\n        if (width <= 0 || height <= 0) return;\n        const engine = Engine.create();\n        engine.world.gravity.y = gravity;\n        const render = Render.create({\n            element: canvasContainerRef.current,\n            engine,\n            options: {\n                width,\n                height,\n                background: backgroundColor,\n                wireframes\n            }\n        });\n        const boundaryOptions = {\n            isStatic: true,\n            render: {\n                fillStyle: \"transparent\"\n            }\n        };\n        const floor = Bodies.rectangle(width / 2, height + 25, width, 50, boundaryOptions);\n        const leftWall = Bodies.rectangle(-25, height / 2, 50, height, boundaryOptions);\n        const rightWall = Bodies.rectangle(width + 25, height / 2, 50, height, boundaryOptions);\n        const ceiling = Bodies.rectangle(width / 2, -25, width, 50, boundaryOptions);\n        if (!textRef.current) return;\n        const wordSpans = textRef.current.querySelectorAll(\"span\");\n        const wordBodies = Array.from(wordSpans).map((elem)=>{\n            const rect = elem.getBoundingClientRect();\n            const x = rect.left - containerRect.left + rect.width / 2;\n            const y = rect.top - containerRect.top + rect.height / 2;\n            const body = Bodies.rectangle(x, y, rect.width, rect.height, {\n                render: {\n                    fillStyle: \"transparent\"\n                },\n                restitution: 0.8,\n                frictionAir: 0.01,\n                friction: 0.2\n            });\n            matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setVelocity(body, {\n                x: (Math.random() - 0.5) * 5,\n                y: 0\n            });\n            matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setAngularVelocity(body, (Math.random() - 0.5) * 0.05);\n            return {\n                elem,\n                body\n            };\n        });\n        wordBodies.forEach((param)=>{\n            let { elem, body } = param;\n            elem.style.position = \"absolute\";\n            elem.style.left = \"\".concat(body.position.x - body.bounds.max.x + body.bounds.min.x / 2, \"px\");\n            elem.style.top = \"\".concat(body.position.y - body.bounds.max.y + body.bounds.min.y / 2, \"px\");\n            elem.style.transform = \"none\";\n        });\n        const mouse = Mouse.create(containerRef.current);\n        const mouseConstraint = MouseConstraint.create(engine, {\n            mouse,\n            constraint: {\n                stiffness: mouseConstraintStiffness,\n                render: {\n                    visible: false\n                }\n            }\n        });\n        render.mouse = mouse;\n        World.add(engine.world, [\n            floor,\n            leftWall,\n            rightWall,\n            ceiling,\n            mouseConstraint,\n            ...wordBodies.map((wb)=>wb.body)\n        ]);\n        const runner = Runner.create();\n        Runner.run(runner, engine);\n        Render.run(render);\n        const updateLoop = ()=>{\n            wordBodies.forEach((param)=>{\n                let { body, elem } = param;\n                const { x, y } = body.position;\n                elem.style.left = \"\".concat(x, \"px\");\n                elem.style.top = \"\".concat(y, \"px\");\n                elem.style.transform = \"translate(-50%, -50%) rotate(\".concat(body.angle, \"rad)\");\n            });\n            matter_js__WEBPACK_IMPORTED_MODULE_2___default().Engine.update(engine);\n            requestAnimationFrame(updateLoop);\n        };\n        updateLoop();\n        return ()=>{\n            Render.stop(render);\n            Runner.stop(runner);\n            if (render.canvas && canvasContainerRef.current) {\n                canvasContainerRef.current.removeChild(render.canvas);\n            }\n            World.clear(engine.world, false);\n            Engine.clear(engine);\n        };\n    }, [\n        effectStarted,\n        gravity,\n        wireframes,\n        backgroundColor,\n        mouseConstraintStiffness\n    ]);\n    const handleTrigger = ()=>{\n        if (!effectStarted && (trigger === \"click\" || trigger === \"hover\")) {\n            setEffectStarted(true);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative z-[1] w-full h-full cursor-pointer text-center pt-8 overflow-hidden\",\n        onClick: trigger === \"click\" ? handleTrigger : undefined,\n        onMouseOver: trigger === \"hover\" ? handleTrigger : undefined,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: textRef,\n                className: \"inline-block\",\n                style: {\n                    fontSize,\n                    lineHeight: 1.4\n                }\n            }, void 0, false, {\n                fileName: \"/Users/csh/Projet/cshStudio/cshStudio/src/Animations/FallingText.tsx\",\n                lineNumber: 233,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-0 left-0 z-0\",\n                ref: canvasContainerRef\n            }, void 0, false, {\n                fileName: \"/Users/csh/Projet/cshStudio/cshStudio/src/Animations/FallingText.tsx\",\n                lineNumber: 242,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/csh/Projet/cshStudio/cshStudio/src/Animations/FallingText.tsx\",\n        lineNumber: 227,\n        columnNumber: 5\n    }, undefined);\n};\n_s(FallingText, \"eHvFl6O29bOgs5Z9Y2zvcA3Wbb4=\");\n_c = FallingText;\n/* harmony default export */ __webpack_exports__[\"default\"] = (FallingText);\nvar _c;\n$RefreshReg$(_c, \"FallingText\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9BbmltYXRpb25zL0ZhbGxpbmdUZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVvRDtBQUNyQjtBQWEvQixNQUFNSSxjQUEwQztRQUFDLEVBQy9DQyxPQUFPLEVBQUUsRUFDVEMsaUJBQWlCLEVBQUUsRUFDbkJDLFVBQVUsTUFBTSxFQUNoQkMsa0JBQWtCLGFBQWEsRUFDL0JDLGFBQWEsS0FBSyxFQUNsQkMsVUFBVSxDQUFDLEVBQ1hDLDJCQUEyQixHQUFHLEVBQzlCQyxXQUFXLE1BQU0sRUFDbEI7O0lBQ0MsTUFBTUMsZUFBZWIsNkNBQU1BLENBQXdCO0lBQ25ELE1BQU1jLFVBQVVkLDZDQUFNQSxDQUF3QjtJQUM5QyxNQUFNZSxxQkFBcUJmLDZDQUFNQSxDQUF3QjtJQUV6RCxNQUFNLENBQUNnQixlQUFlQyxpQkFBaUIsR0FBR2hCLCtDQUFRQSxDQUFDO0lBRW5EQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ1ksUUFBUUksT0FBTyxFQUFFO1FBQ3RCLE1BQU1DLFFBQVFkLEtBQUtlLEtBQUssQ0FBQztRQUV6QixNQUFNQyxVQUFVRixNQUNiRyxHQUFHLENBQUMsQ0FBQ0M7WUFDSixNQUFNQyxnQkFBZ0JsQixlQUFlbUIsSUFBSSxDQUFDLENBQUNDLEtBQU9ILEtBQUtJLFVBQVUsQ0FBQ0Q7WUFDbEUsT0FBTyw2REFLSEgsT0FIQUMsZ0JBQWdCLDRCQUE0QixJQUM3Qyw0QkFFTSxPQUFMRCxNQUFLO1FBRVgsR0FDQ0ssSUFBSSxDQUFDO1FBRVJkLFFBQVFJLE9BQU8sQ0FBQ1csU0FBUyxHQUFHUjtJQUM5QixHQUFHO1FBQUNoQjtRQUFNQztLQUFlO0lBRXpCSixnREFBU0EsQ0FBQztRQUNSLElBQUlLLFlBQVksUUFBUTtZQUN0QlUsaUJBQWlCO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJVixZQUFZLFlBQVlNLGFBQWFLLE9BQU8sRUFBRTtZQUNoRCxNQUFNWSxXQUFXLElBQUlDLHFCQUNuQjtvQkFBQyxDQUFD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O2dCQUFJRSxXQUFVO2dCQUE0QkQsS0FBSzlGOzs7Ozs7Ozs7Ozs7QUFHdEQ7R0FwT01YO0tBQUFBO0FBc09OLCtEQUFlQSxXQUFXQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9BbmltYXRpb25zL0ZhbGxpbmdUZXh0LnRzeD9kMjZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBNYXR0ZXIgZnJvbSBcIm1hdHRlci1qc1wiO1xuXG5pbnRlcmZhY2UgRmFsbGluZ1RleHRQcm9wcyB7XG4gIHRleHQ/OiBzdHJpbmc7XG4gIGhpZ2hsaWdodFdvcmRzPzogc3RyaW5nW107XG4gIHRyaWdnZXI/OiBcImF1dG9cIiB8IFwic2Nyb2xsXCIgfCBcImNsaWNrXCIgfCBcImhvdmVyXCI7XG4gIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcbiAgd2lyZWZyYW1lcz86IGJvb2xlYW47XG4gIGdyYXZpdHk/OiBudW1iZXI7XG4gIG1vdXNlQ29uc3RyYWludFN0aWZmbmVzcz86IG51bWJlcjtcbiAgZm9udFNpemU/OiBzdHJpbmc7XG59XG5cbmNvbnN0IEZhbGxpbmdUZXh0OiBSZWFjdC5GQzxGYWxsaW5nVGV4dFByb3BzPiA9ICh7XG4gIHRleHQgPSBcIlwiLFxuICBoaWdobGlnaHRXb3JkcyA9IFtdLFxuICB0cmlnZ2VyID0gXCJhdXRvXCIsXG4gIGJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIixcbiAgd2lyZWZyYW1lcyA9IGZhbHNlLFxuICBncmF2aXR5ID0gMSxcbiAgbW91c2VDb25zdHJhaW50U3RpZmZuZXNzID0gMC4yLFxuICBmb250U2l6ZSA9IFwiMXJlbVwiLFxufSkgPT4ge1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgdGV4dFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjYW52YXNDb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBbZWZmZWN0U3RhcnRlZCwgc2V0RWZmZWN0U3RhcnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXRleHRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IHdvcmRzID0gdGV4dC5zcGxpdChcIiBcIik7XG5cbiAgICBjb25zdCBuZXdIVE1MID0gd29yZHNcbiAgICAgIC5tYXAoKHdvcmQpID0+IHtcbiAgICAgICAgY29uc3QgaXNIaWdobGlnaHRlZCA9IGhpZ2hsaWdodFdvcmRzLnNvbWUoKGh3KSA9PiB3b3JkLnN0YXJ0c1dpdGgoaHcpKTtcbiAgICAgICAgcmV0dXJuIGA8c3BhblxuICAgICAgICAgIGNsYXNzPVwiaW5saW5lLWJsb2NrIG14LVsycHhdIHNlbGVjdC1ub25lICR7XG4gICAgICAgICAgICBpc0hpZ2hsaWdodGVkID8gXCJ0ZXh0LWN5YW4tNTAwIGZvbnQtYm9sZFwiIDogXCJcIlxuICAgICAgICAgIH1cIlxuICAgICAgICA+XG4gICAgICAgICAgJHt3b3JkfVxuICAgICAgICA8L3NwYW4+YDtcbiAgICAgIH0pXG4gICAgICAuam9pbihcIiBcIik7XG5cbiAgICB0ZXh0UmVmLmN1cnJlbnQuaW5uZXJIVE1MID0gbmV3SFRNTDtcbiAgfSwgW3RleHQsIGhpZ2hsaWdodFdvcmRzXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJpZ2dlciA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIHNldEVmZmVjdFN0YXJ0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyID09PSBcInNjcm9sbFwiICYmIGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgICAgKFtlbnRyeV0pID0+IHtcbiAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIHNldEVmZmVjdFN0YXJ0ZWQodHJ1ZSk7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IHRocmVzaG9sZDogMC4xIH1cbiAgICAgICk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9LCBbdHJpZ2dlcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlZmZlY3RTdGFydGVkKSByZXR1cm47XG5cbiAgICBjb25zdCB7IEVuZ2luZSwgUmVuZGVyLCBXb3JsZCwgQm9kaWVzLCBSdW5uZXIsIE1vdXNlLCBNb3VzZUNvbnN0cmFpbnQgfSA9XG4gICAgICBNYXR0ZXI7XG5cbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50IHx8ICFjYW52YXNDb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHdpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodDtcblxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBlbmdpbmUgPSBFbmdpbmUuY3JlYXRlKCk7XG4gICAgZW5naW5lLndvcmxkLmdyYXZpdHkueSA9IGdyYXZpdHk7XG5cbiAgICBjb25zdCByZW5kZXIgPSBSZW5kZXIuY3JlYXRlKHtcbiAgICAgIGVsZW1lbnQ6IGNhbnZhc0NvbnRhaW5lclJlZi5jdXJyZW50LFxuICAgICAgZW5naW5lLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIHdpcmVmcmFtZXMsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgYm91bmRhcnlPcHRpb25zID0ge1xuICAgICAgaXNTdGF0aWM6IHRydWUsXG4gICAgICByZW5kZXI6IHsgZmlsbFN0eWxlOiBcInRyYW5zcGFyZW50XCIgfSxcbiAgICB9O1xuICAgIGNvbnN0IGZsb29yID0gQm9kaWVzLnJlY3RhbmdsZShcbiAgICAgIHdpZHRoIC8gMixcbiAgICAgIGhlaWdodCArIDI1LFxuICAgICAgd2lkdGgsXG4gICAgICA1MCxcbiAgICAgIGJvdW5kYXJ5T3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgbGVmdFdhbGwgPSBCb2RpZXMucmVjdGFuZ2xlKFxuICAgICAgLTI1LFxuICAgICAgaGVpZ2h0IC8gMixcbiAgICAgIDUwLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYm91bmRhcnlPcHRpb25zXG4gICAgKTtcbiAgICBjb25zdCByaWdodFdhbGwgPSBCb2RpZXMucmVjdGFuZ2xlKFxuICAgICAgd2lkdGggKyAyNSxcbiAgICAgIGhlaWdodCAvIDIsXG4gICAgICA1MCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJvdW5kYXJ5T3B0aW9uc1xuICAgICk7XG4gICAgY29uc3QgY2VpbGluZyA9IEJvZGllcy5yZWN0YW5nbGUoXG4gICAgICB3aWR0aCAvIDIsXG4gICAgICAtMjUsXG4gICAgICB3aWR0aCxcbiAgICAgIDUwLFxuICAgICAgYm91bmRhcnlPcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghdGV4dFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3Qgd29yZFNwYW5zID0gdGV4dFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzcGFuXCIpO1xuICAgIGNvbnN0IHdvcmRCb2RpZXMgPSBBcnJheS5mcm9tKHdvcmRTcGFucykubWFwKChlbGVtKSA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgY29uc3QgeCA9IHJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyO1xuICAgICAgY29uc3QgeSA9IHJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIGNvbnN0IGJvZHkgPSBCb2RpZXMucmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB7XG4gICAgICAgIHJlbmRlcjogeyBmaWxsU3R5bGU6IFwidHJhbnNwYXJlbnRcIiB9LFxuICAgICAgICByZXN0aXR1dGlvbjogMC44LFxuICAgICAgICBmcmljdGlvbkFpcjogMC4wMSxcbiAgICAgICAgZnJpY3Rpb246IDAuMixcbiAgICAgIH0pO1xuICAgICAgTWF0dGVyLkJvZHkuc2V0VmVsb2NpdHkoYm9keSwge1xuICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiA1LFxuICAgICAgICB5OiAwLFxuICAgICAgfSk7XG4gICAgICBNYXR0ZXIuQm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYm9keSwgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wNSk7XG5cbiAgICAgIHJldHVybiB7IGVsZW0sIGJvZHkgfTtcbiAgICB9KTtcblxuICAgIHdvcmRCb2RpZXMuZm9yRWFjaCgoeyBlbGVtLCBib2R5IH0pID0+IHtcbiAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBlbGVtLnN0eWxlLmxlZnQgPSBgJHtcbiAgICAgICAgYm9keS5wb3NpdGlvbi54IC0gYm9keS5ib3VuZHMubWF4LnggKyBib2R5LmJvdW5kcy5taW4ueCAvIDJcbiAgICAgIH1weGA7XG4gICAgICBlbGVtLnN0eWxlLnRvcCA9IGAke1xuICAgICAgICBib2R5LnBvc2l0aW9uLnkgLSBib2R5LmJvdW5kcy5tYXgueSArIGJvZHkuYm91bmRzLm1pbi55IC8gMlxuICAgICAgfXB4YDtcbiAgICAgIGVsZW0uc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgfSk7XG5cbiAgICBjb25zdCBtb3VzZSA9IE1vdXNlLmNyZWF0ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgY29uc3QgbW91c2VDb25zdHJhaW50ID0gTW91c2VDb25zdHJhaW50LmNyZWF0ZShlbmdpbmUsIHtcbiAgICAgIG1vdXNlLFxuICAgICAgY29uc3RyYWludDoge1xuICAgICAgICBzdGlmZm5lc3M6IG1vdXNlQ29uc3RyYWludFN0aWZmbmVzcyxcbiAgICAgICAgcmVuZGVyOiB7IHZpc2libGU6IGZhbHNlIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJlbmRlci5tb3VzZSA9IG1vdXNlO1xuXG4gICAgV29ybGQuYWRkKGVuZ2luZS53b3JsZCwgW1xuICAgICAgZmxvb3IsXG4gICAgICBsZWZ0V2FsbCxcbiAgICAgIHJpZ2h0V2FsbCxcbiAgICAgIGNlaWxpbmcsXG4gICAgICBtb3VzZUNvbnN0cmFpbnQsXG4gICAgICAuLi53b3JkQm9kaWVzLm1hcCgod2IpID0+IHdiLmJvZHkpLFxuICAgIF0pO1xuXG4gICAgY29uc3QgcnVubmVyID0gUnVubmVyLmNyZWF0ZSgpO1xuICAgIFJ1bm5lci5ydW4ocnVubmVyLCBlbmdpbmUpO1xuICAgIFJlbmRlci5ydW4ocmVuZGVyKTtcblxuICAgIGNvbnN0IHVwZGF0ZUxvb3AgPSAoKSA9PiB7XG4gICAgICB3b3JkQm9kaWVzLmZvckVhY2goKHsgYm9keSwgZWxlbSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gYm9keS5wb3NpdGlvbjtcbiAgICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gICAgICAgIGVsZW0uc3R5bGUudG9wID0gYCR7eX1weGA7XG4gICAgICAgIGVsZW0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSByb3RhdGUoJHtib2R5LmFuZ2xlfXJhZClgO1xuICAgICAgfSk7XG4gICAgICBNYXR0ZXIuRW5naW5lLnVwZGF0ZShlbmdpbmUpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUxvb3ApO1xuICAgIH07XG4gICAgdXBkYXRlTG9vcCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIFJlbmRlci5zdG9wKHJlbmRlcik7XG4gICAgICBSdW5uZXIuc3RvcChydW5uZXIpO1xuICAgICAgaWYgKHJlbmRlci5jYW52YXMgJiYgY2FudmFzQ29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FudmFzQ29udGFpbmVyUmVmLmN1cnJlbnQucmVtb3ZlQ2hpbGQocmVuZGVyLmNhbnZhcyk7XG4gICAgICB9XG4gICAgICBXb3JsZC5jbGVhcihlbmdpbmUud29ybGQsIGZhbHNlKTtcbiAgICAgIEVuZ2luZS5jbGVhcihlbmdpbmUpO1xuICAgIH07XG4gIH0sIFtcbiAgICBlZmZlY3RTdGFydGVkLFxuICAgIGdyYXZpdHksXG4gICAgd2lyZWZyYW1lcyxcbiAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgbW91c2VDb25zdHJhaW50U3RpZmZuZXNzLFxuICBdKTtcblxuICBjb25zdCBoYW5kbGVUcmlnZ2VyID0gKCkgPT4ge1xuICAgIGlmICghZWZmZWN0U3RhcnRlZCAmJiAodHJpZ2dlciA9PT0gXCJjbGlja1wiIHx8IHRyaWdnZXIgPT09IFwiaG92ZXJcIikpIHtcbiAgICAgIHNldEVmZmVjdFN0YXJ0ZWQodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSB6LVsxXSB3LWZ1bGwgaC1mdWxsIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHB0LTggb3ZlcmZsb3ctaGlkZGVuXCJcbiAgICAgIG9uQ2xpY2s9e3RyaWdnZXIgPT09IFwiY2xpY2tcIiA/IGhhbmRsZVRyaWdnZXIgOiB1bmRlZmluZWR9XG4gICAgICBvbk1vdXNlT3Zlcj17dHJpZ2dlciA9PT0gXCJob3ZlclwiID8gaGFuZGxlVHJpZ2dlciA6IHVuZGVmaW5lZH1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17dGV4dFJlZn1cbiAgICAgICAgY2xhc3NOYW1lPVwiaW5saW5lLWJsb2NrXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIH19XG4gICAgICAvPlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0wIGxlZnQtMCB6LTBcIiByZWY9e2NhbnZhc0NvbnRhaW5lclJlZn0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZhbGxpbmdUZXh0O1xuIl0sIm5hbWVzIjpbInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTWF0dGVyIiwiRmFsbGluZ1RleHQiLCJ0ZXh0IiwiaGlnaGxpZ2h0V29yZHMiLCJ0cmlnZ2VyIiwiYmFja2dyb3VuZENvbG9yIiwid2lyZWZyYW1lcyIsImdyYXZpdHkiLCJtb3VzZUNvbnN0cmFpbnRTdGlmZm5lc3MiLCJmb250U2l6ZSIsImNvbnRhaW5lclJlZiIsInRleHRSZWYiLCJjYW52YXNDb250YWluZXJSZWYiLCJlZmZlY3RTdGFydGVkIiwic2V0RWZmZWN0U3RhcnRlZCIsImN1cnJlbnQiLCJ3b3JkcyIsInNwbGl0IiwibmV3SFRNTCIsIm1hcCIsIndvcmQiLCJpc0hpZ2hsaWdodGVkIiwic29tZSIsImh3Iiwic3RhcnRzV2l0aCIsImpvaW4iLCJpbm5lckhUTUwiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cnkiLCJpc0ludGVyc2VjdGluZyIsImRpc2Nvbm5lY3QiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwiRW5naW5lIiwiUmVuZGVyIiwiV29ybGQiLCJCb2RpZXMiLCJSdW5uZXIiLCJNb3VzZSIsIk1vdXNlQ29uc3RyYWludCIsImNvbnRhaW5lclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImVuZ2luZSIsImNyZWF0ZSIsIndvcmxkIiwieSIsInJlbmRlciIsImVsZW1lbnQiLCJvcHRpb25zIiwiYmFja2dyb3VuZCIsImJvdW5kYXJ5T3B0aW9ucyIsImlzU3RhdGljIiwiZmlsbFN0eWxlIiwiZmxvb3IiLCJyZWN0YW5nbGUiLCJsZWZ0V2FsbCIsInJpZ2h0V2FsbCIsImNlaWxpbmciLCJ3b3JkU3BhbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwid29yZEJvZGllcyIsIkFycmF5IiwiZnJvbSIsImVsZW0iLCJyZWN0IiwieCIsImxlZnQiLCJ0b3AiLCJib2R5IiwicmVzdGl0dXRpb24iLCJmcmljdGlvbkFpciIsImZyaWN0aW9uIiwiQm9keSIsInNldFZlbG9jaXR5IiwiTWF0aCIsInJhbmRvbSIsInNldEFuZ3VsYXJWZWxvY2l0eSIsImZvckVhY2giLCJzdHlsZSIsInBvc2l0aW9uIiwiYm91bmRzIiwibWF4IiwibWluIiwidHJhbnNmb3JtIiwibW91c2UiLCJtb3VzZUNvbnN0cmFpbnQiLCJjb25zdHJhaW50Iiwic3RpZmZuZXNzIiwidmlzaWJsZSIsImFkZCIsIndiIiwicnVubmVyIiwicnVuIiwidXBkYXRlTG9vcCIsImFuZ2xlIiwidXBkYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic3RvcCIsImNhbnZhcyIsInJlbW92ZUNoaWxkIiwiY2xlYXIiLCJoYW5kbGVUcmlnZ2VyIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIiwib25DbGljayIsInVuZGVmaW5lZCIsIm9uTW91c2VPdmVyIiwibGluZUhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/Animations/FallingText.tsx\n"));

/***/ })

});